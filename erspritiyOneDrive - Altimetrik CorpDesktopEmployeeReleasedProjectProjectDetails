[1mdiff --git a/ProjectDetails/Employee_project_management/__init__.py b/ProjectDetails/Employee_project_management/__init__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..e69de29[m
[1mdiff --git a/ProjectDetails/Employee_project_management/__pycache__/__init__.cpython-312.pyc b/ProjectDetails/Employee_project_management/__pycache__/__init__.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..b6c3b06[m
Binary files /dev/null and b/ProjectDetails/Employee_project_management/__pycache__/__init__.cpython-312.pyc differ
[1mdiff --git a/ProjectDetails/Employee_project_management/__pycache__/admin.cpython-312.pyc b/ProjectDetails/Employee_project_management/__pycache__/admin.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..4c30504[m
Binary files /dev/null and b/ProjectDetails/Employee_project_management/__pycache__/admin.cpython-312.pyc differ
[1mdiff --git a/ProjectDetails/Employee_project_management/__pycache__/apps.cpython-312.pyc b/ProjectDetails/Employee_project_management/__pycache__/apps.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..b21aa47[m
Binary files /dev/null and b/ProjectDetails/Employee_project_management/__pycache__/apps.cpython-312.pyc differ
[1mdiff --git a/ProjectDetails/Employee_project_management/__pycache__/forms.cpython-312.pyc b/ProjectDetails/Employee_project_management/__pycache__/forms.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..8c53d36[m
Binary files /dev/null and b/ProjectDetails/Employee_project_management/__pycache__/forms.cpython-312.pyc differ
[1mdiff --git a/ProjectDetails/Employee_project_management/__pycache__/models.cpython-312.pyc b/ProjectDetails/Employee_project_management/__pycache__/models.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..194deb4[m
Binary files /dev/null and b/ProjectDetails/Employee_project_management/__pycache__/models.cpython-312.pyc differ
[1mdiff --git a/ProjectDetails/Employee_project_management/__pycache__/urls.cpython-312.pyc b/ProjectDetails/Employee_project_management/__pycache__/urls.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..e4e1416[m
Binary files /dev/null and b/ProjectDetails/Employee_project_management/__pycache__/urls.cpython-312.pyc differ
[1mdiff --git a/ProjectDetails/Employee_project_management/__pycache__/views.cpython-312.pyc b/ProjectDetails/Employee_project_management/__pycache__/views.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..60a654a[m
Binary files /dev/null and b/ProjectDetails/Employee_project_management/__pycache__/views.cpython-312.pyc differ
[1mdiff --git a/ProjectDetails/Employee_project_management/admin.py b/ProjectDetails/Employee_project_management/admin.py[m
[1mnew file mode 100644[m
[1mindex 0000000..2bbb8f6[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/admin.py[m
[36m@@ -0,0 +1,5 @@[m
[32m+[m[32mfrom django.contrib import admin[m
[32m+[m
[32m+[m[32m# Register your models here.[m
[32m+[m[32mfrom Employee_project_management import models[m
[32m+[m[32madmin.site.register(models.EmployeeDetails)[m
[1mdiff --git a/ProjectDetails/Employee_project_management/apps.py b/ProjectDetails/Employee_project_management/apps.py[m
[1mnew file mode 100644[m
[1mindex 0000000..c40c02b[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/apps.py[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32mfrom django.apps import AppConfig[m
[32m+[m
[32m+[m
[32m+[m[32mclass ProjectEmpConfig(AppConfig):[m
[32m+[m[32m    default_auto_field = 'django.db.models.BigAutoField'[m
[32m+[m[32m    name = 'Employee_project_management'[m
[1mdiff --git a/ProjectDetails/Employee_project_management/forms.py b/ProjectDetails/Employee_project_management/forms.py[m
[1mnew file mode 100644[m
[1mindex 0000000..dd986c2[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/forms.py[m
[36m@@ -0,0 +1,3 @@[m
[32m+[m[32mfrom django import forms[m
[32m+[m[32mclass ExcelUploadForm(forms.Form):[m
[32m+[m[32m    excel_file = forms.FileField(label='Select a Excel file')[m
[1mdiff --git a/ProjectDetails/Employee_project_management/migrations/0001_initial.py b/ProjectDetails/Employee_project_management/migrations/0001_initial.py[m
[1mnew file mode 100644[m
[1mindex 0000000..160b3c3[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/migrations/0001_initial.py[m
[36m@@ -0,0 +1,32 @@[m
[32m+[m[32m# Generated by Django 5.0.4 on 2024-05-02 14:11[m
[32m+[m
[32m+[m[32mfrom django.db import migrations, models[m
[32m+[m
[32m+[m
[32m+[m[32mclass Migration(migrations.Migration):[m
[32m+[m
[32m+[m[32m    initial = True[m
[32m+[m
[32m+[m[32m    dependencies = [[m
[32m+[m[32m    ][m
[32m+[m
[32m+[m[32m    operations = [[m
[32m+[m[32m        migrations.CreateModel([m
[32m+[m[32m            name='EmployeeDetails',[m
[32m+[m[32m            fields=[[m
[32m+[m[32m                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),[m
[32m+[m[32m                ('Emp_id', models.CharField(max_length=100)),[m
[32m+[m[32m                ('emp_name', models.CharField(max_length=255)),[m
[32m+[m[32m                ('project_name', models.CharField(max_length=255)),[m
[32m+[m[32m                ('last_working_date', models.DateField()),[m
[32m+[m[32m                ('reporting_management_id', models.CharField(max_length=100)),[m
[32m+[m[32m                ('reporting_manager_name', models.CharField(max_length=255)),[m
[32m+[m[32m                ('project_released_feedback', models.TextField()),[m
[32m+[m[32m                ('pmo', models.CharField(max_length=255)),[m
[32m+[m[32m                ('pmo_name', models.CharField(max_length=255)),[m
[32m+[m[32m                ('pmo_email', models.EmailField(max_length=254)),[m
[32m+[m[32m                ('talent_central_contact_name', models.CharField(max_length=255)),[m
[32m+[m[32m                ('talent_central_contact_email', models.EmailField(max_length=254)),[m
[32m+[m[32m            ],[m
[32m+[m[32m        ),[m
[32m+[m[32m    ][m
[1mdiff --git a/ProjectDetails/Employee_project_management/migrations/0002_rename_emp_name_employeedetails_emp_name_and_more.py b/ProjectDetails/Employee_project_management/migrations/0002_rename_emp_name_employeedetails_emp_name_and_more.py[m
[1mnew file mode 100644[m
[1mindex 0000000..5053300[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/migrations/0002_rename_emp_name_employeedetails_emp_name_and_more.py[m
[36m@@ -0,0 +1,68 @@[m
[32m+[m[32m# Generated by Django 5.0.4 on 2024-05-06 05:41[m
[32m+[m
[32m+[m[32mfrom django.db import migrations[m
[32m+[m
[32m+[m
[32m+[m[32mclass Migration(migrations.Migration):[m
[32m+[m
[32m+[m[32m    dependencies = [[m
[32m+[m[32m        ('Employee_project_management', '0001_initial'),[m
[32m+[m[32m    ][m
[32m+[m
[32m+[m[32m    operations = [[m
[32m+[m[32m        migrations.RenameField([m
[32m+[m[32m            model_name='employeedetails',[m
[32m+[m[32m            old_name='emp_name',[m
[32m+[m[32m            new_name='Emp_name',[m
[32m+[m[32m        ),[m
[32m+[m[32m        migrations.RenameField([m
[32m+[m[32m            model_name='employeedetails',[m
[32m+[m[32m            old_name='last_working_date',[m
[32m+[m[32m            new_name='Last_working_date',[m
[32m+[m[32m        ),[m
[32m+[m[32m        migrations.RenameField([m
[32m+[m[32m            model_name='employeedetails',[m
[32m+[m[32m            old_name='pmo',[m
[32m+[m[32m            new_name='PMO',[m
[32m+[m[32m        ),[m
[32m+[m[32m        migrations.RenameField([m
[32m+[m[32m            model_name='employeedetails',[m
[32m+[m[32m            old_name='pmo_email',[m
[32m+[m[32m            new_name='PMO_email',[m
[32m+[m[32m        ),[m
[32m+[m[32m        migrations.RenameField([m
[32m+[m[32m            model_name='employeedetails',[m
[32m+[m[32m            old_name='pmo_name',[m
[32m+[m[32m            new_name='PMO_name',[m
[32m+[m[32m        ),[m
[32m+[m[32m        migrations.RenameField([m
[32m+[m[32m            model_name='employeedetails',[m
[32m+[m[32m            old_name='project_name',[m
[32m+[m[32m            new_name='Project_name',[m
[32m+[m[32m        ),[m
[32m+[m[32m        migrations.RenameField([m
[32m+[m[32m            model_name='employeedetails',[m
[32m+[m[32m            old_name='project_released_feedback',[m
[32m+[m[32m            new_name='Project_released_feedback',[m
[32m+[m[32m        ),[m
[32m+[m[32m        migrations.RenameField([m
[32m+[m[32m            model_name='employeedetails',[m
[32m+[m[32m            old_name='reporting_management_id',[m
[32m+[m[32m            new_name='Reporting_management_id',[m
[32m+[m[32m        ),[m
[32m+[m[32m        migrations.RenameField([m
[32m+[m[32m            model_name='employeedetails',[m
[32m+[m[32m            old_name='reporting_manager_name',[m
[32m+[m[32m            new_name='Reporting_manager_name',[m
[32m+[m[32m        ),[m
[32m+[m[32m        migrations.RenameField([m
[32m+[m[32m            model_name='employeedetails',[m
[32m+[m[32m            old_name='talent_central_contact_email',[m
[32m+[m[32m            new_name='Talent_central_contact_email',[m
[32m+[m[32m        ),[m
[32m+[m[32m        migrations.RenameField([m
[32m+[m[32m            model_name='employeedetails',[m
[32m+[m[32m            old_name='talent_central_contact_name',[m
[32m+[m[32m            new_name='Talent_central_contact_name',[m
[32m+[m[32m        ),[m
[32m+[m[32m    ][m
[1mdiff --git a/ProjectDetails/Employee_project_management/migrations/0003_rename_reporting_management_id_employeedetails_reporting_manager_id.py b/ProjectDetails/Employee_project_management/migrations/0003_rename_reporting_management_id_employeedetails_reporting_manager_id.py[m
[1mnew file mode 100644[m
[1mindex 0000000..38129b5[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/migrations/0003_rename_reporting_management_id_employeedetails_reporting_manager_id.py[m
[36m@@ -0,0 +1,18 @@[m
[32m+[m[32m# Generated by Django 5.0.4 on 2024-05-13 06:08[m
[32m+[m
[32m+[m[32mfrom django.db import migrations[m
[32m+[m
[32m+[m
[32m+[m[32mclass Migration(migrations.Migration):[m
[32m+[m
[32m+[m[32m    dependencies = [[m
[32m+[m[32m        ('Employee_project_management', '0002_rename_emp_name_employeedetails_emp_name_and_more'),[m
[32m+[m[32m    ][m
[32m+[m
[32m+[m[32m    operations = [[m
[32m+[m[32m        migrations.RenameField([m
[32m+[m[32m            model_name='employeedetails',[m
[32m+[m[32m            old_name='Reporting_management_id',[m
[32m+[m[32m            new_name='Reporting_manager_id',[m
[32m+[m[32m        ),[m
[32m+[m[32m    ][m
[1mdiff --git a/ProjectDetails/Employee_project_management/migrations/__init__.py b/ProjectDetails/Employee_project_management/migrations/__init__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..e69de29[m
[1mdiff --git a/ProjectDetails/Employee_project_management/migrations/__pycache__/0001_initial.cpython-312.pyc b/ProjectDetails/Employee_project_management/migrations/__pycache__/0001_initial.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..61fc5a3[m
Binary files /dev/null and b/ProjectDetails/Employee_project_management/migrations/__pycache__/0001_initial.cpython-312.pyc differ
[1mdiff --git a/ProjectDetails/Employee_project_management/migrations/__pycache__/0002_rename_emp_name_employeedetails_emp_name_and_more.cpython-312.pyc b/ProjectDetails/Employee_project_management/migrations/__pycache__/0002_rename_emp_name_employeedetails_emp_name_and_more.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..8d704e1[m
Binary files /dev/null and b/ProjectDetails/Employee_project_management/migrations/__pycache__/0002_rename_emp_name_employeedetails_emp_name_and_more.cpython-312.pyc differ
[1mdiff --git a/ProjectDetails/Employee_project_management/migrations/__pycache__/0003_rename_reporting_management_id_employeedetails_reporting_manager_id.cpython-312.pyc b/ProjectDetails/Employee_project_management/migrations/__pycache__/0003_rename_reporting_management_id_employeedetails_reporting_manager_id.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..1a94ffb[m
Binary files /dev/null and b/ProjectDetails/Employee_project_management/migrations/__pycache__/0003_rename_reporting_management_id_employeedetails_reporting_manager_id.cpython-312.pyc differ
[1mdiff --git a/ProjectDetails/Employee_project_management/migrations/__pycache__/__init__.cpython-312.pyc b/ProjectDetails/Employee_project_management/migrations/__pycache__/__init__.cpython-312.pyc[m
[1mnew file mode 100644[m
[1mindex 0000000..c6d57a5[m
Binary files /dev/null and b/ProjectDetails/Employee_project_management/migrations/__pycache__/__init__.cpython-312.pyc differ
[1mdiff --git a/ProjectDetails/Employee_project_management/models.py b/ProjectDetails/Employee_project_management/models.py[m
[1mnew file mode 100644[m
[1mindex 0000000..16978cd[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/models.py[m
[36m@@ -0,0 +1,21 @@[m
[32m+[m[32mfrom django.db import models[m
[32m+[m
[32m+[m[32m# Create your models here.[m
[32m+[m
[32m+[m
[32m+[m[32mclass EmployeeDetails(models.Model):[m
[32m+[m[32m    Emp_id = models.CharField(max_length=100)[m
[32m+[m[32m    Emp_name = models.CharField(max_length=255)[m
[32m+[m[32m    Project_name = models.CharField(max_length=255)[m
[32m+[m[32m    Last_working_date = models.DateField()[m
[32m+[m[32m    Reporting_manager_id = models.CharField(max_length=100)[m
[32m+[m[32m    Reporting_manager_name = models.CharField(max_length=255)[m
[32m+[m[32m    Project_released_feedback = models.TextField()[m
[32m+[m[32m    PMO = models.CharField(max_length=255)[m
[32m+[m[32m    PMO_name = models.CharField(max_length=255)[m
[32m+[m[32m    PMO_email = models.EmailField()[m
[32m+[m[32m    Talent_central_contact_name = models.CharField(max_length=255)[m
[32m+[m[32m    Talent_central_contact_email = models.EmailField()[m
[32m+[m
[32m+[m[32m    def __str__(self):[m
[32m+[m[32m        return f"{self.Emp_id} - {self.Emp_name}"[m
[1mdiff --git a/ProjectDetails/Employee_project_management/templates/employee_details.html b/ProjectDetails/Employee_project_management/templates/employee_details.html[m
[1mnew file mode 100644[m
[1mindex 0000000..43297f8[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/templates/employee_details.html[m
[36m@@ -0,0 +1,25 @@[m
[32m+[m[32m<!DOCTYPE html>[m
[32m+[m[32m<html lang="en">[m
[32m+[m[32m<head>[m
[32m+[m[32m    <meta charset="UTF-8">[m
[32m+[m[32m    <meta name="viewport" content="width=device-width, initial-scale=1.0">[m
[32m+[m[32m    <title>Employee Details</title>[m
[32m+[m[32m</head>[m
[32m+[m[32m<body>[m
[32m+[m[32m    <h1>Employee Details</h1>[m
[32m+[m[32m    <ul>[m
[32m+[m[32m        <li><strong>Employee ID:</strong> {{ employee.emp_id }}</li>[m
[32m+[m[32m        <li><strong>Employee Name:</strong> {{ employee.emp_name }}</li>[m
[32m+[m[32m        <li><strong>Project Name:</strong> {{ employee.project_name }}</li>[m
[32m+[m[32m        <li><strong>Last Working Date:</strong> {{ employee.last_working_date }}</li>[m
[32m+[m[32m        <li><strong>Reporting Management ID:</strong> {{ employee.reporting_management_id }}</li>[m
[32m+[m[32m        <li><strong>Reporting Manager Name:</strong> {{ employee.reporting_manager_name }}</li>[m
[32m+[m[32m        <li><strong>Project Released Feedback:</strong> {{ employee.project_released_feedback }}</li>[m
[32m+[m[32m        <li><strong>PMO:</strong> {{ employee.pmo }}</li>[m
[32m+[m[32m        <li><strong>PMO Name:</strong> {{ employee.pmo_name }}</li>[m
[32m+[m[32m        <li><strong>PMO Email:</strong> {{ employee.pmo_email }}</li>[m
[32m+[m[32m        <li><strong>Talent Central Contact Name:</strong> {{ employee.talent_central_contact_name }}</li>[m
[32m+[m[32m        <li><strong>Talent Central Contact Email:</strong> {{ employee.talent_central_contact_email }}</li>[m
[32m+[m[32m    </ul>[m
[32m+[m[32m</body>[m
[32m+[m[32m</html>[m
[1mdiff --git a/ProjectDetails/Employee_project_management/templates/success.html b/ProjectDetails/Employee_project_management/templates/success.html[m
[1mnew file mode 100644[m
[1mindex 0000000..3f47b80[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/templates/success.html[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m
[32m+[m[32m<!DOCTYPE html>[m
[32m+[m[32m<html lang="en">[m
[32m+[m[32m<head>[m
[32m+[m[32m    <meta charset="UTF-8">[m
[32m+[m[32m    <meta name="viewport" content="width=device-width, initial-scale=1.0">[m
[32m+[m[32m    <title>Upload Success</title>[m
[32m+[m[32m</head>[m
[32m+[m[32m<body>[m
[32m+[m[32m    <h1>Upload Successful</h1>[m
[32m+[m[32m    <p>Data has been successfully uploaded.</p>[m
[32m+[m[32m</body>[m
[32m+[m[32m</html>[m
[1mdiff --git a/ProjectDetails/Employee_project_management/templates/upload_excel.html b/ProjectDetails/Employee_project_management/templates/upload_excel.html[m
[1mnew file mode 100644[m
[1mindex 0000000..0d34cbf[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/templates/upload_excel.html[m
[36m@@ -0,0 +1,16 @@[m
[32m+[m[32m<!DOCTYPE html>[m
[32m+[m[32m<html lang="en">[m
[32m+[m[32m<head>[m
[32m+[m[32m    <meta charset="UTF-8">[m
[32m+[m[32m    <meta name="viewport" content="width=device-width, initial-scale=1.0">[m
[32m+[m[32m    <title>Upload Excel Files</title>[m
[32m+[m[32m</head>[m
[32m+[m[32m<body>[m
[32m+[m[32m    <h1>Upload Excel Files</h1>[m
[32m+[m[32m    <form method="post" enctype="multipart/form-data">[m
[32m+[m[32m        {% csrf_token %}[m
[32m+[m[32m        {{ form.as_p }}[m
[32m+[m[32m        <button type="submit">Upload</button>[m
[32m+[m[32m    </form>[m
[32m+[m[32m</body>[m
[32m+[m[32m</html>[m
[1mdiff --git a/ProjectDetails/Employee_project_management/tests.py b/ProjectDetails/Employee_project_management/tests.py[m
[1mnew file mode 100644[m
[1mindex 0000000..7ce503c[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/tests.py[m
[36m@@ -0,0 +1,3 @@[m
[32m+[m[32mfrom django.test import TestCase[m
[32m+[m
[32m+[m[32m# Create your tests here.[m
[1mdiff --git a/ProjectDetails/Employee_project_management/tests0.py b/ProjectDetails/Employee_project_management/tests0.py[m
[1mnew file mode 100644[m
[1mindex 0000000..7ce503c[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/tests0.py[m
[36m@@ -0,0 +1,3 @@[m
[32m+[m[32mfrom django.test import TestCase[m
[32m+[m
[32m+[m[32m# Create your tests here.[m
[1mdiff --git a/ProjectDetails/Employee_project_management/urls.py b/ProjectDetails/Employee_project_management/urls.py[m
[1mnew file mode 100644[m
[1mindex 0000000..c0f7ee1[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/urls.py[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m
[32m+[m[32mfrom django.urls import path[m
[32m+[m[32mfrom . import views[m
[32m+[m
[32m+[m[32murlpatterns = [[m
[32m+[m[32m    path('html/', views.emp_details, name='emp_details'),[m
[32m+[m
[32m+[m[32m    path('employee/<str:emp_id>/', views.employee_details, name='employee_details'),[m
[32m+[m[32m    path('calculate_days_remaining/<str:emp_id>/', views.calculate_remaining_days_view, name='calculate_days_remaining'),[m
[32m+[m[32m    path('upload/', views.upload_excel, name='upload_excel'),[m
[32m+[m[32m    path('trigger-emails/', views.trigger_email_notifications, name='trigger_emails'),[m
[32m+[m[32m    #path('test/', views.send_email_notification, name="test_email"),[m
[32m+[m[32m][m
[1mdiff --git a/ProjectDetails/Employee_project_management/views.py b/ProjectDetails/Employee_project_management/views.py[m
[1mnew file mode 100644[m
[1mindex 0000000..c9bc200[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/Employee_project_management/views.py[m
[36m@@ -0,0 +1,157 @@[m
[32m+[m[32mfrom django.shortcuts import render[m
[32m+[m[32mfrom django.http import HttpResponse[m
[32m+[m[32mfrom .models import EmployeeDetails[m
[32m+[m[32mfrom datetime import datetime, timedelta[m
[32m+[m[32mimport pandas as pd[m
[32m+[m[32mimport smtplib[m
[32m+[m[32mfrom email.mime.multipart import MIMEMultipart[m
[32m+[m[32mfrom email.mime.text import MIMEText[m
[32m+[m[32mfrom django.conf import settings[m
[32m+[m[32mfrom .forms import ExcelUploadForm[m
[32m+[m[32mfrom django.utils import timezone[m
[32m+[m[32mfrom django.conf import settings[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mdef calculate_remaining_days(last_working_date):[m
[32m+[m[32m    current_date = datetime.now().date()[m
[32m+[m[32m    difference = last_working_date - current_date[m
[32m+[m[32m    remaining_days = abs(difference.days)[m
[32m+[m[32m    is_45_days_remaining = remaining_days == 45[m
[32m+[m[32m    return remaining_days, is_45_days_remaining[m
[32m+[m[32m#check if the difference is exactly 45 is_45_days_remaining[m
[32m+[m[32m    if is_45_days_remaining:[m
[32m+[m[32m        return remaining_days, True[m
[32m+[m[32m    return remaining_days, False[m
[32m+[m[32mdef logEmail(sender_email, recipients, subject, message):[m
[32m+[m[32m    try:[m
[32m+[m[32m        print("Inside the LogEmail Method.")[m
[32m+[m[32m        with open("email.log", "a") as f:[m
[32m+[m[32m            _str = f'Sender : {sender_email}, recipients : {recipients} , Subject : {subject}, Message : {message}\n'[m
[32m+[m[32m            f.write(_str)[m
[32m+[m[32m            f.write("-----------------------------------------------\n")[m
[32m+[m[32m    except ex:[m
[32m+[m[32m        print(ex)[m
[32m+[m
[32m+[m[32mdef send_email_notification(employee):[m
[32m+[m[32m    sender_email = settings.EMAIL_HOST_USER[m
[32m+[m[32m    recipients = [employee.PMO_email, employee.Talent_central_contact_email][m
[32m+[m[32m    subject = f'{employee.Emp_id} - {employee.Emp_name}'[m
[32m+[m[32m    message = f'Hello,<br>\n\n'[m
[32m+[m[32m    message += f'Hello,<br>\n\nI hope this email finds you well.<br>\n\nThe following members have been released from the project since 45 days, I request you to please take some actions.\n\n<br><br>'[m
[32m+[m
[32m+[m[32m    message += f'<table border="1"><tr><th>Employee ID</th><th>Name</th><th>Project Name</th><th>Last Working Date</th><th>Reporting Manager ID</th><th>Reporting Manage Name</th><th>Project Released Feedback</th></tr>'[m
[32m+[m[32m    message += f'<tr><td>{employee.Emp_id}</td><td>{employee.Emp_name}</td><td>{employee.Project_name}</td><td>{employee.Last_working_date}</td><td>{employee.Reporting_manager_id}</td><td>{employee.Reporting_manager_name}</td><td>{employee.Project_released_feedback}</td></tr></table>'[m
[32m+[m[32m    message += '\n\nRegards,\nYour Company'[m
[32m+[m
[32m+[m
[32m+[m[32m    email = MIMEMultipart()[m
[32m+[m[32m    email['From'] = sender_email[m
[32m+[m[32m    email['To'] = ', '.join(recipients)[m
[32m+[m[32m    email['Subject'] = subject[m
[32m+[m[32m    email['Date'] = datetime.now().strftime('%a, %d %b %Y %H:%M:%S %z')[m
[32m+[m[32m    email.attach(MIMEText(message, 'html'))[m
[32m+[m[32m    with smtplib.SMTP(settings.EMAIL_HOST, settings.EMAIL_PORT) as smtp_server:[m
[32m+[m[32m            smtp_server.starttls()[m
[32m+[m[32m            smtp_server.login(sender_email, settings.EMAIL_HOST_PASSWORD)[m
[32m+[m[32m            smtp_server.send_message(email)[m
[32m+[m
[32m+[m
[32m+[m[32mdef employee_details(request, emp_id):[m
[32m+[m[32m    try:[m
[32m+[m[32m        employee = EmployeeDetails.objects.get(Emp_id=emp_id)[m
[32m+[m[32m        remaining_days, is_45_days_remaining = calculate_remaining_days(employee.Last_working_date)[m
[32m+[m[32m        if is_45_days_remaining:[m
[32m+[m[32m            send_email_notification(employee)[m
[32m+[m[32m        context = {'employee': employee, 'remaining_days': remaining_days}[m
[32m+[m[32m        return render(request, 'employee_details.html', context)[m
[32m+[m[32m    except EmployeeDetails.DoesNotExist:[m
[32m+[m[32m        return HttpResponse("Employee not found!")[m
[32m+[m
[32m+[m
[32m+[m[32mdef emp_details(request):[m
[32m+[m[32m    return render(request, 'employee_details.html')[m
[32m+[m
[32m+[m
[32m+[m[32mdef calculate_remaining_days_view(request, emp_id):[m
[32m+[m[32m    try:[m
[32m+[m[32m        employee = EmployeeDetails.objects.get(Emp_id=emp_id)[m
[32m+[m[32m        remaining_days = calculate_remaining_days(employee.Last_working_date)[m
[32m+[m[32m        return HttpResponse(f"Remaining days for employee {emp_id}: {remaining_days}")[m
[32m+[m[32m    except EmployeeDetails.DoesNotExist:[m
[32m+[m[32m        return HttpResponse("Employee not found!")[m
[32m+[m
[32m+[m
[32m+[m[32mdef validate_excel(view_func):[m
[32m+[m[32m    def wrapper(request, *args, **kwargs):[m
[32m+[m[32m        if request.method == 'POST':[m
[32m+[m[32m            form = ExcelUploadForm(request.POST, request.FILES)[m
[32m+[m[32m            if form.is_valid():[m
[32m+[m[32m                return view_func(request, *args, **kwargs)[m
[32m+[m[32m        else:[m
[32m+[m[32m            form = ExcelUploadForm()[m
[32m+[m[32m        return render(request, 'upload_excel.html', {'form': form})[m
[32m+[m[32m    return wrapper[m
[32m+[m
[32m+[m
[32m+[m[32m@validate_excel[m
[32m+[m[32mdef upload_excel(request):[m
[32m+[m[32m    if request.method == 'POST':[m
[32m+[m[32m        form = ExcelUploadForm(request.POST, request.FILES)[m
[32m+[m[32m        if form.is_valid():[m
[32m+[m[32m            excel_file = request.FILES['excel_file'][m
[32m+[m[32m            df = pd.read_excel(excel_file)[m
[32m+[m
[32m+[m[32m            for index, column in df.iterrows():[m
[32m+[m[32m                # Check if EmployeeDetails with same Emp_id exists[m
[32m+[m[32m                try:[m
[32m+[m[32m                    employee = EmployeeDetails.objects.get(Emp_id=column['Emp_id'])[m
[32m+[m
[32m+[m[32m                    # If EmployeeDetails with same Emp_id exists, update its details[m
[32m+[m[32m                    employee.Emp_name = column['Emp_name'][m
[32m+[m[32m                    employee.Project_name = column['Project_name'][m
[32m+[m[32m                    employee.Last_working_date = column['Last_working_date'][m
[32m+[m[32m                    employee.Reporting_manager_id = column['Reporting_manager_id'][m
[32m+[m[32m                    employee.Reporting_manager_name = column['Reporting_manager_name'][m
[32m+[m[32m                    employee.Project_released_feedback = column['Project_released_feedback'][m
[32m+[m[32m                    employee.PMO = column['PMO'][m
[32m+[m[32m                    employee.PMO_name = column['PMO_name'][m
[32m+[m[32m                    employee.PMO_email = column['PMO_email'][m
[32m+[m[32m                    employee.Talent_central_contact_name = column['Talent_central_contact_name'][m
[32m+[m[32m                    employee.Talent_central_contact_email = column['Talent_central_contact_email'][m
[32m+[m[32m                    employee.save()[m
[32m+[m
[32m+[m[32m                # If EmployeeDetails with same Emp_id doesn't exist, create a new one[m
[32m+[m[32m                except EmployeeDetails.DoesNotExist:[m
[32m+[m[32m                    EmployeeDetails.objects.create([m
[32m+[m[32m                        Emp_id=column['Emp_id'],[m
[32m+[m[32m                        Emp_name=column['Emp_name'],[m
[32m+[m[32m                        Project_name=column['Project_name'],[m
[32m+[m[32m                        Last_working_date=column['Last_working_date'],[m
[32m+[m[32m                        Reporting_manager_id=column['Reporting_manager_id'],[m
[32m+[m[32m                        Reporting_manager_name=column['Reporting_manager_name'],[m
[32m+[m[32m                        Project_released_feedback=column['Project_released_feedback'],[m
[32m+[m[32m                        PMO=column['PMO'],[m
[32m+[m[32m                        PMO_name=column['PMO_name'],[m
[32m+[m[32m                        PMO_email=column['PMO_email'],[m
[32m+[m[32m                        Talent_central_contact_name=column['Talent_central_contact_name'],[m
[32m+[m[32m                        Talent_central_contact_email=column['Talent_central_contact_email'][m
[32m+[m[32m                    )[m
[32m+[m
[32m+[m[32m            return render(request, 'success.html')[m
[32m+[m
[32m+[m[32m    else:[m
[32m+[m[32m        form = ExcelUploadForm()[m
[32m+[m
[32m+[m[32m    return render(request, 'upload_excel.html', {'form': form})[m
[32m+[m
[32m+[m
[32m+[m[32mdef trigger_email_notifications(request):[m
[32m+[m
[32m+[m[32m    forty_five_days_ago = timezone.now() - timedelta(days=45) # Calculate the date which is 45 days before the current date[m
[32m+[m[32m    employees = EmployeeDetails.objects.filter(Last_working_date=forty_five_days_ago)[m
[32m+[m[32m     #Fetch employees whose last working date is 45 days[m
[32m+[m[32m    for employee in employees: #Iterate only the filtered employees and send email notifications[m
[32m+[m[32m        send_email_notification(employee)[m
[32m+[m
[32m+[m[32m    return HttpResponse("Email notifications triggered successfully.")[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/__init__.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/__init__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..be0e3ed[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/__init__.py[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m[32mfrom typing import List, Optional[m
[32m+[m
[32m+[m[32m__version__ = "24.0"[m
[32m+[m
[32m+[m
[32m+[m[32mdef main(args: Optional[List[str]] = None) -> int:[m
[32m+[m[32m    """This is an internal API only meant for use by pip's own console scripts.[m
[32m+[m
[32m+[m[32m    For additional details, see https://github.com/pypa/pip/issues/7498.[m
[32m+[m[32m    """[m
[32m+[m[32m    from pip._internal.utils.entrypoints import _wrapper[m
[32m+[m
[32m+[m[32m    return _wrapper(args)[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/__main__.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/__main__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..5991326[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/__main__.py[m
[36m@@ -0,0 +1,24 @@[m
[32m+[m[32mimport os[m
[32m+[m[32mimport sys[m
[32m+[m
[32m+[m[32m# Remove '' and current working directory from the first entry[m
[32m+[m[32m# of sys.path, if present to avoid using current directory[m
[32m+[m[32m# in pip commands check, freeze, install, list and show,[m
[32m+[m[32m# when invoked as python -m pip <command>[m
[32m+[m[32mif sys.path[0] in ("", os.getcwd()):[m
[32m+[m[32m    sys.path.pop(0)[m
[32m+[m
[32m+[m[32m# If we are running from a wheel, add the wheel to sys.path[m
[32m+[m[32m# This allows the usage python pip-*.whl/pip install pip-*.whl[m
[32m+[m[32mif __package__ == "":[m
[32m+[m[32m    # __file__ is pip-*.whl/pip/__main__.py[m
[32m+[m[32m    # first dirname call strips of '/__main__.py', second strips off '/pip'[m
[32m+[m[32m    # Resulting path is the name of the wheel itself[m
[32m+[m[32m    # Add that to sys.path so we can import pip[m
[32m+[m[32m    path = os.path.dirname(os.path.dirname(__file__))[m
[32m+[m[32m    sys.path.insert(0, path)[m
[32m+[m
[32m+[m[32mif __name__ == "__main__":[m
[32m+[m[32m    from pip._internal.cli.main import main as _main[m
[32m+[m
[32m+[m[32m    sys.exit(_main())[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/__pip-runner__.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/__pip-runner__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..49a148a[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/__pip-runner__.py[m
[36m@@ -0,0 +1,50 @@[m
[32m+[m[32m"""Execute exactly this copy of pip, within a different environment.[m
[32m+[m
[32m+[m[32mThis file is named as it is, to ensure that this module can't be imported via[m
[32m+[m[32man import statement.[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32m# /!\ This version compatibility check section must be Python 2 compatible. /!\[m
[32m+[m
[32m+[m[32mimport sys[m
[32m+[m
[32m+[m[32m# Copied from setup.py[m
[32m+[m[32mPYTHON_REQUIRES = (3, 7)[m
[32m+[m
[32m+[m
[32m+[m[32mdef version_str(version):  # type: ignore[m
[32m+[m[32m    return ".".join(str(v) for v in version)[m
[32m+[m
[32m+[m
[32m+[m[32mif sys.version_info[:2] < PYTHON_REQUIRES:[m
[32m+[m[32m    raise SystemExit([m
[32m+[m[32m        "This version of pip does not support python {} (requires >={}).".format([m
[32m+[m[32m            version_str(sys.version_info[:2]), version_str(PYTHON_REQUIRES)[m
[32m+[m[32m        )[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m[32m# From here on, we can use Python 3 features, but the syntax must remain[m
[32m+[m[32m# Python 2 compatible.[m
[32m+[m
[32m+[m[32mimport runpy  # noqa: E402[m
[32m+[m[32mfrom importlib.machinery import PathFinder  # noqa: E402[m
[32m+[m[32mfrom os.path import dirname  # noqa: E402[m
[32m+[m
[32m+[m[32mPIP_SOURCES_ROOT = dirname(dirname(__file__))[m
[32m+[m
[32m+[m
[32m+[m[32mclass PipImportRedirectingFinder:[m
[32m+[m[32m    @classmethod[m
[32m+[m[32m    def find_spec(self, fullname, path=None, target=None):  # type: ignore[m
[32m+[m[32m        if fullname != "pip":[m
[32m+[m[32m            return None[m
[32m+[m
[32m+[m[32m        spec = PathFinder.find_spec(fullname, [PIP_SOURCES_ROOT], target)[m
[32m+[m[32m        assert spec, (PIP_SOURCES_ROOT, fullname)[m
[32m+[m[32m        return spec[m
[32m+[m
[32m+[m
[32m+[m[32msys.meta_path.insert(0, PipImportRedirectingFinder())[m
[32m+[m
[32m+[m[32massert __name__ == "__main__", "Cannot run __pip-runner__.py as a non-main module"[m
[32m+[m[32mrunpy.run_module("pip", run_name="__main__", alter_sys=True)[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/__init__.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/__init__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..96c6b88[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/__init__.py[m
[36m@@ -0,0 +1,18 @@[m
[32m+[m[32mfrom typing import List, Optional[m
[32m+[m
[32m+[m[32mfrom pip._internal.utils import _log[m
[32m+[m
[32m+[m[32m# init_logging() must be called before any call to logging.getLogger()[m
[32m+[m[32m# which happens at import of most modules.[m
[32m+[m[32m_log.init_logging()[m
[32m+[m
[32m+[m
[32m+[m[32mdef main(args: (Optional[List[str]]) = None) -> int:[m
[32m+[m[32m    """This is preserved for old console scripts that may still be referencing[m
[32m+[m[32m    it.[m
[32m+[m
[32m+[m[32m    For additional details, see https://github.com/pypa/pip/issues/7498.[m
[32m+[m[32m    """[m
[32m+[m[32m    from pip._internal.utils.entrypoints import _wrapper[m
[32m+[m
[32m+[m[32m    return _wrapper(args)[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/build_env.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/build_env.py[m
[1mnew file mode 100644[m
[1mindex 0000000..4f704a3[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/build_env.py[m
[36m@@ -0,0 +1,311 @@[m
[32m+[m[32m"""Build Environment used for isolation during sdist building[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport os[m
[32m+[m[32mimport pathlib[m
[32m+[m[32mimport site[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport textwrap[m
[32m+[m[32mfrom collections import OrderedDict[m
[32m+[m[32mfrom types import TracebackType[m
[32m+[m[32mfrom typing import TYPE_CHECKING, Iterable, List, Optional, Set, Tuple, Type, Union[m
[32m+[m
[32m+[m[32mfrom pip._vendor.certifi import where[m
[32m+[m[32mfrom pip._vendor.packaging.requirements import Requirement[m
[32m+[m[32mfrom pip._vendor.packaging.version import Version[m
[32m+[m
[32m+[m[32mfrom pip import __file__ as pip_location[m
[32m+[m[32mfrom pip._internal.cli.spinners import open_spinner[m
[32m+[m[32mfrom pip._internal.locations import get_platlib, get_purelib, get_scheme[m
[32m+[m[32mfrom pip._internal.metadata import get_default_environment, get_environment[m
[32m+[m[32mfrom pip._internal.utils.subprocess import call_subprocess[m
[32m+[m[32mfrom pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds[m
[32m+[m
[32m+[m[32mif TYPE_CHECKING:[m
[32m+[m[32m    from pip._internal.index.package_finder import PackageFinder[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mdef _dedup(a: str, b: str) -> Union[Tuple[str], Tuple[str, str]]:[m
[32m+[m[32m    return (a, b) if a != b else (a,)[m
[32m+[m
[32m+[m
[32m+[m[32mclass _Prefix:[m
[32m+[m[32m    def __init__(self, path: str) -> None:[m
[32m+[m[32m        self.path = path[m
[32m+[m[32m        self.setup = False[m
[32m+[m[32m        scheme = get_scheme("", prefix=path)[m
[32m+[m[32m        self.bin_dir = scheme.scripts[m
[32m+[m[32m        self.lib_dirs = _dedup(scheme.purelib, scheme.platlib)[m
[32m+[m
[32m+[m
[32m+[m[32mdef get_runnable_pip() -> str:[m
[32m+[m[32m    """Get a file to pass to a Python executable, to run the currently-running pip.[m
[32m+[m
[32m+[m[32m    This is used to run a pip subprocess, for installing requirements into the build[m
[32m+[m[32m    environment.[m
[32m+[m[32m    """[m
[32m+[m[32m    source = pathlib.Path(pip_location).resolve().parent[m
[32m+[m
[32m+[m[32m    if not source.is_dir():[m
[32m+[m[32m        # This would happen if someone is using pip from inside a zip file. In that[m
[32m+[m[32m        # case, we can use that directly.[m
[32m+[m[32m        return str(source)[m
[32m+[m
[32m+[m[32m    return os.fsdecode(source / "__pip-runner__.py")[m
[32m+[m
[32m+[m
[32m+[m[32mdef _get_system_sitepackages() -> Set[str]:[m
[32m+[m[32m    """Get system site packages[m
[32m+[m
[32m+[m[32m    Usually from site.getsitepackages,[m
[32m+[m[32m    but fallback on `get_purelib()/get_platlib()` if unavailable[m
[32m+[m[32m    (e.g. in a virtualenv created by virtualenv<20)[m
[32m+[m
[32m+[m[32m    Returns normalized set of strings.[m
[32m+[m[32m    """[m
[32m+[m[32m    if hasattr(site, "getsitepackages"):[m
[32m+[m[32m        system_sites = site.getsitepackages()[m
[32m+[m[32m    else:[m
[32m+[m[32m        # virtualenv < 20 overwrites site.py without getsitepackages[m
[32m+[m[32m        # fallback on get_purelib/get_platlib.[m
[32m+[m[32m        # this is known to miss things, but shouldn't in the cases[m
[32m+[m[32m        # where getsitepackages() has been removed (inside a virtualenv)[m
[32m+[m[32m        system_sites = [get_purelib(), get_platlib()][m
[32m+[m[32m    return {os.path.normcase(path) for path in system_sites}[m
[32m+[m
[32m+[m
[32m+[m[32mclass BuildEnvironment:[m
[32m+[m[32m    """Creates and manages an isolated environment to install build deps"""[m
[32m+[m
[32m+[m[32m    def __init__(self) -> None:[m
[32m+[m[32m        temp_dir = TempDirectory(kind=tempdir_kinds.BUILD_ENV, globally_managed=True)[m
[32m+[m
[32m+[m[32m        self._prefixes = OrderedDict([m
[32m+[m[32m            (name, _Prefix(os.path.join(temp_dir.path, name)))[m
[32m+[m[32m            for name in ("normal", "overlay")[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self._bin_dirs: List[str] = [][m
[32m+[m[32m        self._lib_dirs: List[str] = [][m
[32m+[m[32m        for prefix in reversed(list(self._prefixes.values())):[m
[32m+[m[32m            self._bin_dirs.append(prefix.bin_dir)[m
[32m+[m[32m            self._lib_dirs.extend(prefix.lib_dirs)[m
[32m+[m
[32m+[m[32m        # Customize site to:[m
[32m+[m[32m        # - ensure .pth files are honored[m
[32m+[m[32m        # - prevent access to system site packages[m
[32m+[m[32m        system_sites = _get_system_sitepackages()[m
[32m+[m
[32m+[m[32m        self._site_dir = os.path.join(temp_dir.path, "site")[m
[32m+[m[32m        if not os.path.exists(self._site_dir):[m
[32m+[m[32m            os.mkdir(self._site_dir)[m
[32m+[m[32m        with open([m
[32m+[m[32m            os.path.join(self._site_dir, "sitecustomize.py"), "w", encoding="utf-8"[m
[32m+[m[32m        ) as fp:[m
[32m+[m[32m            fp.write([m
[32m+[m[32m                textwrap.dedent([m
[32m+[m[32m                    """[m
[32m+[m[32m                import os, site, sys[m
[32m+[m
[32m+[m[32m                # First, drop system-sites related paths.[m
[32m+[m[32m                original_sys_path = sys.path[:][m
[32m+[m[32m                known_paths = set()[m
[32m+[m[32m                for path in {system_sites!r}:[m
[32m+[m[32m                    site.addsitedir(path, known_paths=known_paths)[m
[32m+[m[32m                system_paths = set([m
[32m+[m[32m                    os.path.normcase(path)[m
[32m+[m[32m                    for path in sys.path[len(original_sys_path):][m
[32m+[m[32m                )[m
[32m+[m[32m                original_sys_path = [[m
[32m+[m[32m                    path for path in original_sys_path[m
[32m+[m[32m                    if os.path.normcase(path) not in system_paths[m
[32m+[m[32m                ][m
[32m+[m[32m                sys.path = original_sys_path[m
[32m+[m
[32m+[m[32m                # Second, add lib directories.[m
[32m+[m[32m                # ensuring .pth file are processed.[m
[32m+[m[32m                for path in {lib_dirs!r}:[m
[32m+[m[32m                    assert not path in sys.path[m
[32m+[m[32m                    site.addsitedir(path)[m
[32m+[m[32m                """[m
[32m+[m[32m                ).format(system_sites=system_sites, lib_dirs=self._lib_dirs)[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m    def __enter__(self) -> None:[m
[32m+[m[32m        self._save_env = {[m
[32m+[m[32m            name: os.environ.get(name, None)[m
[32m+[m[32m            for name in ("PATH", "PYTHONNOUSERSITE", "PYTHONPATH")[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        path = self._bin_dirs[:][m
[32m+[m[32m        old_path = self._save_env["PATH"][m
[32m+[m[32m        if old_path:[m
[32m+[m[32m            path.extend(old_path.split(os.pathsep))[m
[32m+[m
[32m+[m[32m        pythonpath = [self._site_dir][m
[32m+[m
[32m+[m[32m        os.environ.update([m
[32m+[m[32m            {[m
[32m+[m[32m                "PATH": os.pathsep.join(path),[m
[32m+[m[32m                "PYTHONNOUSERSITE": "1",[m
[32m+[m[32m                "PYTHONPATH": os.pathsep.join(pythonpath),[m
[32m+[m[32m            }[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    def __exit__([m
[32m+[m[32m        self,[m
[32m+[m[32m        exc_type: Optional[Type[BaseException]],[m
[32m+[m[32m        exc_val: Optional[BaseException],[m
[32m+[m[32m        exc_tb: Optional[TracebackType],[m
[32m+[m[32m    ) -> None:[m
[32m+[m[32m        for varname, old_value in self._save_env.items():[m
[32m+[m[32m            if old_value is None:[m
[32m+[m[32m                os.environ.pop(varname, None)[m
[32m+[m[32m            else:[m
[32m+[m[32m                os.environ[varname] = old_value[m
[32m+[m
[32m+[m[32m    def check_requirements([m
[32m+[m[32m        self, reqs: Iterable[str][m
[32m+[m[32m    ) -> Tuple[Set[Tuple[str, str]], Set[str]]:[m
[32m+[m[32m        """Return 2 sets:[m
[32m+[m[32m        - conflicting requirements: set of (installed, wanted) reqs tuples[m
[32m+[m[32m        - missing requirements: set of reqs[m
[32m+[m[32m        """[m
[32m+[m[32m        missing = set()[m
[32m+[m[32m        conflicting = set()[m
[32m+[m[32m        if reqs:[m
[32m+[m[32m            env = ([m
[32m+[m[32m                get_environment(self._lib_dirs)[m
[32m+[m[32m                if hasattr(self, "_lib_dirs")[m
[32m+[m[32m                else get_default_environment()[m
[32m+[m[32m            )[m
[32m+[m[32m            for req_str in reqs:[m
[32m+[m[32m                req = Requirement(req_str)[m
[32m+[m[32m                # We're explicitly evaluating with an empty extra value, since build[m
[32m+[m[32m                # environments are not provided any mechanism to select specific extras.[m
[32m+[m[32m                if req.marker is not None and not req.marker.evaluate({"extra": ""}):[m
[32m+[m[32m                    continue[m
[32m+[m[32m                dist = env.get_distribution(req.name)[m
[32m+[m[32m                if not dist:[m
[32m+[m[32m                    missing.add(req_str)[m
[32m+[m[32m                    continue[m
[32m+[m[32m                if isinstance(dist.version, Version):[m
[32m+[m[32m                    installed_req_str = f"{req.name}=={dist.version}"[m
[32m+[m[32m                else:[m
[32m+[m[32m                    installed_req_str = f"{req.name}==={dist.version}"[m
[32m+[m[32m                if not req.specifier.contains(dist.version, prereleases=True):[m
[32m+[m[32m                    conflicting.add((installed_req_str, req_str))[m
[32m+[m[32m                # FIXME: Consider direct URL?[m
[32m+[m[32m        return conflicting, missing[m
[32m+[m
[32m+[m[32m    def install_requirements([m
[32m+[m[32m        self,[m
[32m+[m[32m        finder: "PackageFinder",[m
[32m+[m[32m        requirements: Iterable[str],[m
[32m+[m[32m        prefix_as_string: str,[m
[32m+[m[32m        *,[m
[32m+[m[32m        kind: str,[m
[32m+[m[32m    ) -> None:[m
[32m+[m[32m        prefix = self._prefixes[prefix_as_string][m
[32m+[m[32m        assert not prefix.setup[m
[32m+[m[32m        prefix.setup = True[m
[32m+[m[32m        if not requirements:[m
[32m+[m[32m            return[m
[32m+[m[32m        self._install_requirements([m
[32m+[m[32m            get_runnable_pip(),[m
[32m+[m[32m            finder,[m
[32m+[m[32m            requirements,[m
[32m+[m[32m            prefix,[m
[32m+[m[32m            kind=kind,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    @staticmethod[m
[32m+[m[32m    def _install_requirements([m
[32m+[m[32m        pip_runnable: str,[m
[32m+[m[32m        finder: "PackageFinder",[m
[32m+[m[32m        requirements: Iterable[str],[m
[32m+[m[32m        prefix: _Prefix,[m
[32m+[m[32m        *,[m
[32m+[m[32m        kind: str,[m
[32m+[m[32m    ) -> None:[m
[32m+[m[32m        args: List[str] = [[m
[32m+[m[32m            sys.executable,[m
[32m+[m[32m            pip_runnable,[m
[32m+[m[32m            "install",[m
[32m+[m[32m            "--ignore-installed",[m
[32m+[m[32m            "--no-user",[m
[32m+[m[32m            "--prefix",[m
[32m+[m[32m            prefix.path,[m
[32m+[m[32m            "--no-warn-script-location",[m
[32m+[m[32m        ][m
[32m+[m[32m        if logger.getEffectiveLevel() <= logging.DEBUG:[m
[32m+[m[32m            args.append("-v")[m
[32m+[m[32m        for format_control in ("no_binary", "only_binary"):[m
[32m+[m[32m            formats = getattr(finder.format_control, format_control)[m
[32m+[m[32m            args.extend([m
[32m+[m[32m                ([m
[32m+[m[32m                    "--" + format_control.replace("_", "-"),[m
[32m+[m[32m                    ",".join(sorted(formats or {":none:"})),[m
[32m+[m[32m                )[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        index_urls = finder.index_urls[m
[32m+[m[32m        if index_urls:[m
[32m+[m[32m            args.extend(["-i", index_urls[0]])[m
[32m+[m[32m            for extra_index in index_urls[1:]:[m
[32m+[m[32m                args.extend(["--extra-index-url", extra_index])[m
[32m+[m[32m        else:[m
[32m+[m[32m            args.append("--no-index")[m
[32m+[m[32m        for link in finder.find_links:[m
[32m+[m[32m            args.extend(["--find-links", link])[m
[32m+[m
[32m+[m[32m        for host in finder.trusted_hosts:[m
[32m+[m[32m            args.extend(["--trusted-host", host])[m
[32m+[m[32m        if finder.allow_all_prereleases:[m
[32m+[m[32m            args.append("--pre")[m
[32m+[m[32m        if finder.prefer_binary:[m
[32m+[m[32m            args.append("--prefer-binary")[m
[32m+[m[32m        args.append("--")[m
[32m+[m[32m        args.extend(requirements)[m
[32m+[m[32m        extra_environ = {"_PIP_STANDALONE_CERT": where()}[m
[32m+[m[32m        with open_spinner(f"Installing {kind}") as spinner:[m
[32m+[m[32m            call_subprocess([m
[32m+[m[32m                args,[m
[32m+[m[32m                command_desc=f"pip subprocess to install {kind}",[m
[32m+[m[32m                spinner=spinner,[m
[32m+[m[32m                extra_environ=extra_environ,[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m
[32m+[m[32mclass NoOpBuildEnvironment(BuildEnvironment):[m
[32m+[m[32m    """A no-op drop-in replacement for BuildEnvironment"""[m
[32m+[m
[32m+[m[32m    def __init__(self) -> None:[m
[32m+[m[32m        pass[m
[32m+[m
[32m+[m[32m    def __enter__(self) -> None:[m
[32m+[m[32m        pass[m
[32m+[m
[32m+[m[32m    def __exit__([m
[32m+[m[32m        self,[m
[32m+[m[32m        exc_type: Optional[Type[BaseException]],[m
[32m+[m[32m        exc_val: Optional[BaseException],[m
[32m+[m[32m        exc_tb: Optional[TracebackType],[m
[32m+[m[32m    ) -> None:[m
[32m+[m[32m        pass[m
[32m+[m
[32m+[m[32m    def cleanup(self) -> None:[m
[32m+[m[32m        pass[m
[32m+[m
[32m+[m[32m    def install_requirements([m
[32m+[m[32m        self,[m
[32m+[m[32m        finder: "PackageFinder",[m
[32m+[m[32m        requirements: Iterable[str],[m
[32m+[m[32m        prefix_as_string: str,[m
[32m+[m[32m        *,[m
[32m+[m[32m        kind: str,[m
[32m+[m[32m    ) -> None:[m
[32m+[m[32m        raise NotImplementedError()[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cache.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cache.py[m
[1mnew file mode 100644[m
[1mindex 0000000..f45ac23[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cache.py[m
[36m@@ -0,0 +1,290 @@[m
[32m+[m[32m"""Cache Management[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mimport hashlib[m
[32m+[m[32mimport json[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport os[m
[32m+[m[32mfrom pathlib import Path[m
[32m+[m[32mfrom typing import Any, Dict, List, Optional[m
[32m+[m
[32m+[m[32mfrom pip._vendor.packaging.tags import Tag, interpreter_name, interpreter_version[m
[32m+[m[32mfrom pip._vendor.packaging.utils import canonicalize_name[m
[32m+[m
[32m+[m[32mfrom pip._internal.exceptions import InvalidWheelFilename[m
[32m+[m[32mfrom pip._internal.models.direct_url import DirectUrl[m
[32m+[m[32mfrom pip._internal.models.link import Link[m
[32m+[m[32mfrom pip._internal.models.wheel import Wheel[m
[32m+[m[32mfrom pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds[m
[32m+[m[32mfrom pip._internal.utils.urls import path_to_url[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m[32mORIGIN_JSON_NAME = "origin.json"[m
[32m+[m
[32m+[m
[32m+[m[32mdef _hash_dict(d: Dict[str, str]) -> str:[m
[32m+[m[32m    """Return a stable sha224 of a dictionary."""[m
[32m+[m[32m    s = json.dumps(d, sort_keys=True, separators=(",", ":"), ensure_ascii=True)[m
[32m+[m[32m    return hashlib.sha224(s.encode("ascii")).hexdigest()[m
[32m+[m
[32m+[m
[32m+[m[32mclass Cache:[m
[32m+[m[32m    """An abstract class - provides cache directories for data from links[m
[32m+[m
[32m+[m[32m    :param cache_dir: The root of the cache.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__(self, cache_dir: str) -> None:[m
[32m+[m[32m        super().__init__()[m
[32m+[m[32m        assert not cache_dir or os.path.isabs(cache_dir)[m
[32m+[m[32m        self.cache_dir = cache_dir or None[m
[32m+[m
[32m+[m[32m    def _get_cache_path_parts(self, link: Link) -> List[str]:[m
[32m+[m[32m        """Get parts of part that must be os.path.joined with cache_dir"""[m
[32m+[m
[32m+[m[32m        # We want to generate an url to use as our cache key, we don't want to[m
[32m+[m[32m        # just re-use the URL because it might have other items in the fragment[m
[32m+[m[32m        # and we don't care about those.[m
[32m+[m[32m        key_parts = {"url": link.url_without_fragment}[m
[32m+[m[32m        if link.hash_name is not None and link.hash is not None:[m
[32m+[m[32m            key_parts[link.hash_name] = link.hash[m
[32m+[m[32m        if link.subdirectory_fragment:[m
[32m+[m[32m            key_parts["subdirectory"] = link.subdirectory_fragment[m
[32m+[m
[32m+[m[32m        # Include interpreter name, major and minor version in cache key[m
[32m+[m[32m        # to cope with ill-behaved sdists that build a different wheel[m
[32m+[m[32m        # depending on the python version their setup.py is being run on,[m
[32m+[m[32m        # and don't encode the difference in compatibility tags.[m
[32m+[m[32m        # https://github.com/pypa/pip/issues/7296[m
[32m+[m[32m        key_parts["interpreter_name"] = interpreter_name()[m
[32m+[m[32m        key_parts["interpreter_version"] = interpreter_version()[m
[32m+[m
[32m+[m[32m        # Encode our key url with sha224, we'll use this because it has similar[m
[32m+[m[32m        # security properties to sha256, but with a shorter total output (and[m
[32m+[m[32m        # thus less secure). However the differences don't make a lot of[m
[32m+[m[32m        # difference for our use case here.[m
[32m+[m[32m        hashed = _hash_dict(key_parts)[m
[32m+[m
[32m+[m[32m        # We want to nest the directories some to prevent having a ton of top[m
[32m+[m[32m        # level directories where we might run out of sub directories on some[m
[32m+[m[32m        # FS.[m
[32m+[m[32m        parts = [hashed[:2], hashed[2:4], hashed[4:6], hashed[6:]][m
[32m+[m
[32m+[m[32m        return parts[m
[32m+[m
[32m+[m[32m    def _get_candidates(self, link: Link, canonical_package_name: str) -> List[Any]:[m
[32m+[m[32m        can_not_cache = not self.cache_dir or not canonical_package_name or not link[m
[32m+[m[32m        if can_not_cache:[m
[32m+[m[32m            return [][m
[32m+[m
[32m+[m[32m        path = self.get_path_for_link(link)[m
[32m+[m[32m        if os.path.isdir(path):[m
[32m+[m[32m            return [(candidate, path) for candidate in os.listdir(path)][m
[32m+[m[32m        return [][m
[32m+[m
[32m+[m[32m    def get_path_for_link(self, link: Link) -> str:[m
[32m+[m[32m        """Return a directory to store cached items in for link."""[m
[32m+[m[32m        raise NotImplementedError()[m
[32m+[m
[32m+[m[32m    def get([m
[32m+[m[32m        self,[m
[32m+[m[32m        link: Link,[m
[32m+[m[32m        package_name: Optional[str],[m
[32m+[m[32m        supported_tags: List[Tag],[m
[32m+[m[32m    ) -> Link:[m
[32m+[m[32m        """Returns a link to a cached item if it exists, otherwise returns the[m
[32m+[m[32m        passed link.[m
[32m+[m[32m        """[m
[32m+[m[32m        raise NotImplementedError()[m
[32m+[m
[32m+[m
[32m+[m[32mclass SimpleWheelCache(Cache):[m
[32m+[m[32m    """A cache of wheels for future installs."""[m
[32m+[m
[32m+[m[32m    def __init__(self, cache_dir: str) -> None:[m
[32m+[m[32m        super().__init__(cache_dir)[m
[32m+[m
[32m+[m[32m    def get_path_for_link(self, link: Link) -> str:[m
[32m+[m[32m        """Return a directory to store cached wheels for link[m
[32m+[m
[32m+[m[32m        Because there are M wheels for any one sdist, we provide a directory[m
[32m+[m[32m        to cache them in, and then consult that directory when looking up[m
[32m+[m[32m        cache hits.[m
[32m+[m
[32m+[m[32m        We only insert things into the cache if they have plausible version[m
[32m+[m[32m        numbers, so that we don't contaminate the cache with things that were[m
[32m+[m[32m        not unique. E.g. ./package might have dozens of installs done for it[m
[32m+[m[32m        and build a version of 0.0...and if we built and cached a wheel, we'd[m
[32m+[m[32m        end up using the same wheel even if the source has been edited.[m
[32m+[m
[32m+[m[32m        :param link: The link of the sdist for which this will cache wheels.[m
[32m+[m[32m        """[m
[32m+[m[32m        parts = self._get_cache_path_parts(link)[m
[32m+[m[32m        assert self.cache_dir[m
[32m+[m[32m        # Store wheels within the root cache_dir[m
[32m+[m[32m        return os.path.join(self.cache_dir, "wheels", *parts)[m
[32m+[m
[32m+[m[32m    def get([m
[32m+[m[32m        self,[m
[32m+[m[32m        link: Link,[m
[32m+[m[32m        package_name: Optional[str],[m
[32m+[m[32m        supported_tags: List[Tag],[m
[32m+[m[32m    ) -> Link:[m
[32m+[m[32m        candidates = [][m
[32m+[m
[32m+[m[32m        if not package_name:[m
[32m+[m[32m            return link[m
[32m+[m
[32m+[m[32m        canonical_package_name = canonicalize_name(package_name)[m
[32m+[m[32m        for wheel_name, wheel_dir in self._get_candidates(link, canonical_package_name):[m
[32m+[m[32m            try:[m
[32m+[m[32m                wheel = Wheel(wheel_name)[m
[32m+[m[32m            except InvalidWheelFilename:[m
[32m+[m[32m                continue[m
[32m+[m[32m            if canonicalize_name(wheel.name) != canonical_package_name:[m
[32m+[m[32m                logger.debug([m
[32m+[m[32m                    "Ignoring cached wheel %s for %s as it "[m
[32m+[m[32m                    "does not match the expected distribution name %s.",[m
[32m+[m[32m                    wheel_name,[m
[32m+[m[32m                    link,[m
[32m+[m[32m                    package_name,[m
[32m+[m[32m                )[m
[32m+[m[32m                continue[m
[32m+[m[32m            if not wheel.supported(supported_tags):[m
[32m+[m[32m                # Built for a different python/arch/etc[m
[32m+[m[32m                continue[m
[32m+[m[32m            candidates.append([m
[32m+[m[32m                ([m
[32m+[m[32m                    wheel.support_index_min(supported_tags),[m
[32m+[m[32m                    wheel_name,[m
[32m+[m[32m                    wheel_dir,[m
[32m+[m[32m                )[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        if not candidates:[m
[32m+[m[32m            return link[m
[32m+[m
[32m+[m[32m        _, wheel_name, wheel_dir = min(candidates)[m
[32m+[m[32m        return Link(path_to_url(os.path.join(wheel_dir, wheel_name)))[m
[32m+[m
[32m+[m
[32m+[m[32mclass EphemWheelCache(SimpleWheelCache):[m
[32m+[m[32m    """A SimpleWheelCache that creates it's own temporary cache directory"""[m
[32m+[m
[32m+[m[32m    def __init__(self) -> None:[m
[32m+[m[32m        self._temp_dir = TempDirectory([m
[32m+[m[32m            kind=tempdir_kinds.EPHEM_WHEEL_CACHE,[m
[32m+[m[32m            globally_managed=True,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        super().__init__(self._temp_dir.path)[m
[32m+[m
[32m+[m
[32m+[m[32mclass CacheEntry:[m
[32m+[m[32m    def __init__([m
[32m+[m[32m        self,[m
[32m+[m[32m        link: Link,[m
[32m+[m[32m        persistent: bool,[m
[32m+[m[32m    ):[m
[32m+[m[32m        self.link = link[m
[32m+[m[32m        self.persistent = persistent[m
[32m+[m[32m        self.origin: Optional[DirectUrl] = None[m
[32m+[m[32m        origin_direct_url_path = Path(self.link.file_path).parent / ORIGIN_JSON_NAME[m
[32m+[m[32m        if origin_direct_url_path.exists():[m
[32m+[m[32m            try:[m
[32m+[m[32m                self.origin = DirectUrl.from_json([m
[32m+[m[32m                    origin_direct_url_path.read_text(encoding="utf-8")[m
[32m+[m[32m                )[m
[32m+[m[32m            except Exception as e:[m
[32m+[m[32m                logger.warning([m
[32m+[m[32m                    "Ignoring invalid cache entry origin file %s for %s (%s)",[m
[32m+[m[32m                    origin_direct_url_path,[m
[32m+[m[32m                    link.filename,[m
[32m+[m[32m                    e,[m
[32m+[m[32m                )[m
[32m+[m
[32m+[m
[32m+[m[32mclass WheelCache(Cache):[m
[32m+[m[32m    """Wraps EphemWheelCache and SimpleWheelCache into a single Cache[m
[32m+[m
[32m+[m[32m    This Cache allows for gracefully degradation, using the ephem wheel cache[m
[32m+[m[32m    when a certain link is not found in the simple wheel cache first.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__(self, cache_dir: str) -> None:[m
[32m+[m[32m        super().__init__(cache_dir)[m
[32m+[m[32m        self._wheel_cache = SimpleWheelCache(cache_dir)[m
[32m+[m[32m        self._ephem_cache = EphemWheelCache()[m
[32m+[m
[32m+[m[32m    def get_path_for_link(self, link: Link) -> str:[m
[32m+[m[32m        return self._wheel_cache.get_path_for_link(link)[m
[32m+[m
[32m+[m[32m    def get_ephem_path_for_link(self, link: Link) -> str:[m
[32m+[m[32m        return self._ephem_cache.get_path_for_link(link)[m
[32m+[m
[32m+[m[32m    def get([m
[32m+[m[32m        self,[m
[32m+[m[32m        link: Link,[m
[32m+[m[32m        package_name: Optional[str],[m
[32m+[m[32m        supported_tags: List[Tag],[m
[32m+[m[32m    ) -> Link:[m
[32m+[m[32m        cache_entry = self.get_cache_entry(link, package_name, supported_tags)[m
[32m+[m[32m        if cache_entry is None:[m
[32m+[m[32m            return link[m
[32m+[m[32m        return cache_entry.link[m
[32m+[m
[32m+[m[32m    def get_cache_entry([m
[32m+[m[32m        self,[m
[32m+[m[32m        link: Link,[m
[32m+[m[32m        package_name: Optional[str],[m
[32m+[m[32m        supported_tags: List[Tag],[m
[32m+[m[32m    ) -> Optional[CacheEntry]:[m
[32m+[m[32m        """Returns a CacheEntry with a link to a cached item if it exists or[m
[32m+[m[32m        None. The cache entry indicates if the item was found in the persistent[m
[32m+[m[32m        or ephemeral cache.[m
[32m+[m[32m        """[m
[32m+[m[32m        retval = self._wheel_cache.get([m
[32m+[m[32m            link=link,[m
[32m+[m[32m            package_name=package_name,[m
[32m+[m[32m            supported_tags=supported_tags,[m
[32m+[m[32m        )[m
[32m+[m[32m        if retval is not link:[m
[32m+[m[32m            return CacheEntry(retval, persistent=True)[m
[32m+[m
[32m+[m[32m        retval = self._ephem_cache.get([m
[32m+[m[32m            link=link,[m
[32m+[m[32m            package_name=package_name,[m
[32m+[m[32m            supported_tags=supported_tags,[m
[32m+[m[32m        )[m
[32m+[m[32m        if retval is not link:[m
[32m+[m[32m            return CacheEntry(retval, persistent=False)[m
[32m+[m
[32m+[m[32m        return None[m
[32m+[m
[32m+[m[32m    @staticmethod[m
[32m+[m[32m    def record_download_origin(cache_dir: str, download_info: DirectUrl) -> None:[m
[32m+[m[32m        origin_path = Path(cache_dir) / ORIGIN_JSON_NAME[m
[32m+[m[32m        if origin_path.exists():[m
[32m+[m[32m            try:[m
[32m+[m[32m                origin = DirectUrl.from_json(origin_path.read_text(encoding="utf-8"))[m
[32m+[m[32m            except Exception as e:[m
[32m+[m[32m                logger.warning([m
[32m+[m[32m                    "Could not read origin file %s in cache entry (%s). "[m
[32m+[m[32m                    "Will attempt to overwrite it.",[m
[32m+[m[32m                    origin_path,[m
[32m+[m[32m                    e,[m
[32m+[m[32m                )[m
[32m+[m[32m            else:[m
[32m+[m[32m                # TODO: use DirectUrl.equivalent when[m
[32m+[m[32m                # https://github.com/pypa/pip/pull/10564 is merged.[m
[32m+[m[32m                if origin.url != download_info.url:[m
[32m+[m[32m                    logger.warning([m
[32m+[m[32m                        "Origin URL %s in cache entry %s does not match download URL "[m
[32m+[m[32m                        "%s. This is likely a pip bug or a cache corruption issue. "[m
[32m+[m[32m                        "Will overwrite it with the new value.",[m
[32m+[m[32m                        origin.url,[m
[32m+[m[32m                        cache_dir,[m
[32m+[m[32m                        download_info.url,[m
[32m+[m[32m                    )[m
[32m+[m[32m        origin_path.write_text(download_info.to_json(), encoding="utf-8")[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/__init__.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/__init__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..e589bb9[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/__init__.py[m
[36m@@ -0,0 +1,4 @@[m
[32m+[m[32m"""Subpackage containing all of pip's command line interface related code[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32m# This file intentionally does not import submodules[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/autocompletion.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/autocompletion.py[m
[1mnew file mode 100644[m
[1mindex 0000000..e5950b9[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/autocompletion.py[m
[36m@@ -0,0 +1,172 @@[m
[32m+[m[32m"""Logic that powers autocompletion installed by ``pip completion``.[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mimport optparse[m
[32m+[m[32mimport os[m
[32m+[m[32mimport sys[m
[32m+[m[32mfrom itertools import chain[m
[32m+[m[32mfrom typing import Any, Iterable, List, Optional[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli.main_parser import create_main_parser[m
[32m+[m[32mfrom pip._internal.commands import commands_dict, create_command[m
[32m+[m[32mfrom pip._internal.metadata import get_default_environment[m
[32m+[m
[32m+[m
[32m+[m[32mdef autocomplete() -> None:[m
[32m+[m[32m    """Entry Point for completion of main and subcommand options."""[m
[32m+[m[32m    # Don't complete if user hasn't sourced bash_completion file.[m
[32m+[m[32m    if "PIP_AUTO_COMPLETE" not in os.environ:[m
[32m+[m[32m        return[m
[32m+[m[32m    cwords = os.environ["COMP_WORDS"].split()[1:][m
[32m+[m[32m    cword = int(os.environ["COMP_CWORD"])[m
[32m+[m[32m    try:[m
[32m+[m[32m        current = cwords[cword - 1][m
[32m+[m[32m    except IndexError:[m
[32m+[m[32m        current = ""[m
[32m+[m
[32m+[m[32m    parser = create_main_parser()[m
[32m+[m[32m    subcommands = list(commands_dict)[m
[32m+[m[32m    options = [][m
[32m+[m
[32m+[m[32m    # subcommand[m
[32m+[m[32m    subcommand_name: Optional[str] = None[m
[32m+[m[32m    for word in cwords:[m
[32m+[m[32m        if word in subcommands:[m
[32m+[m[32m            subcommand_name = word[m
[32m+[m[32m            break[m
[32m+[m[32m    # subcommand options[m
[32m+[m[32m    if subcommand_name is not None:[m
[32m+[m[32m        # special case: 'help' subcommand has no options[m
[32m+[m[32m        if subcommand_name == "help":[m
[32m+[m[32m            sys.exit(1)[m
[32m+[m[32m        # special case: list locally installed dists for show and uninstall[m
[32m+[m[32m        should_list_installed = not current.startswith("-") and subcommand_name in [[m
[32m+[m[32m            "show",[m
[32m+[m[32m            "uninstall",[m
[32m+[m[32m        ][m
[32m+[m[32m        if should_list_installed:[m
[32m+[m[32m            env = get_default_environment()[m
[32m+[m[32m            lc = current.lower()[m
[32m+[m[32m            installed = [[m
[32m+[m[32m                dist.canonical_name[m
[32m+[m[32m                for dist in env.iter_installed_distributions(local_only=True)[m
[32m+[m[32m                if dist.canonical_name.startswith(lc)[m
[32m+[m[32m                and dist.canonical_name not in cwords[1:][m
[32m+[m[32m            ][m
[32m+[m[32m            # if there are no dists installed, fall back to option completion[m
[32m+[m[32m            if installed:[m
[32m+[m[32m                for dist in installed:[m
[32m+[m[32m                    print(dist)[m
[32m+[m[32m                sys.exit(1)[m
[32m+[m
[32m+[m[32m        should_list_installables = ([m
[32m+[m[32m            not current.startswith("-") and subcommand_name == "install"[m
[32m+[m[32m        )[m
[32m+[m[32m        if should_list_installables:[m
[32m+[m[32m            for path in auto_complete_paths(current, "path"):[m
[32m+[m[32m                print(path)[m
[32m+[m[32m            sys.exit(1)[m
[32m+[m
[32m+[m[32m        subcommand = create_command(subcommand_name)[m
[32m+[m
[32m+[m[32m        for opt in subcommand.parser.option_list_all:[m
[32m+[m[32m            if opt.help != optparse.SUPPRESS_HELP:[m
[32m+[m[32m                options += [[m
[32m+[m[32m                    (opt_str, opt.nargs) for opt_str in opt._long_opts + opt._short_opts[m
[32m+[m[32m                ][m
[32m+[m
[32m+[m[32m        # filter out previously specified options from available options[m
[32m+[m[32m        prev_opts = [x.split("=")[0] for x in cwords[1 : cword - 1]][m
[32m+[m[32m        options = [(x, v) for (x, v) in options if x not in prev_opts][m
[32m+[m[32m        # filter options by current input[m
[32m+[m[32m        options = [(k, v) for k, v in options if k.startswith(current)][m
[32m+[m[32m        # get completion type given cwords and available subcommand options[m
[32m+[m[32m        completion_type = get_path_completion_type([m
[32m+[m[32m            cwords,[m
[32m+[m[32m            cword,[m
[32m+[m[32m            subcommand.parser.option_list_all,[m
[32m+[m[32m        )[m
[32m+[m[32m        # get completion files and directories if ``completion_type`` is[m
[32m+[m[32m        # ``<file>``, ``<dir>`` or ``<path>``[m
[32m+[m[32m        if completion_type:[m
[32m+[m[32m            paths = auto_complete_paths(current, completion_type)[m
[32m+[m[32m            options = [(path, 0) for path in paths][m
[32m+[m[32m        for option in options:[m
[32m+[m[32m            opt_label = option[0][m
[32m+[m[32m            # append '=' to options which require args[m
[32m+[m[32m            if option[1] and option[0][:2] == "--":[m
[32m+[m[32m                opt_label += "="[m
[32m+[m[32m            print(opt_label)[m
[32m+[m[32m    else:[m
[32m+[m[32m        # show main parser options only when necessary[m
[32m+[m
[32m+[m[32m        opts = [i.option_list for i in parser.option_groups][m
[32m+[m[32m        opts.append(parser.option_list)[m
[32m+[m[32m        flattened_opts = chain.from_iterable(opts)[m
[32m+[m[32m        if current.startswith("-"):[m
[32m+[m[32m            for opt in flattened_opts:[m
[32m+[m[32m                if opt.help != optparse.SUPPRESS_HELP:[m
[32m+[m[32m                    subcommands += opt._long_opts + opt._short_opts[m
[32m+[m[32m        else:[m
[32m+[m[32m            # get completion type given cwords and all available options[m
[32m+[m[32m            completion_type = get_path_completion_type(cwords, cword, flattened_opts)[m
[32m+[m[32m            if completion_type:[m
[32m+[m[32m                subcommands = list(auto_complete_paths(current, completion_type))[m
[32m+[m
[32m+[m[32m        print(" ".join([x for x in subcommands if x.startswith(current)]))[m
[32m+[m[32m    sys.exit(1)[m
[32m+[m
[32m+[m
[32m+[m[32mdef get_path_completion_type([m
[32m+[m[32m    cwords: List[str], cword: int, opts: Iterable[Any][m
[32m+[m[32m) -> Optional[str]:[m
[32m+[m[32m    """Get the type of path completion (``file``, ``dir``, ``path`` or None)[m
[32m+[m
[32m+[m[32m    :param cwords: same as the environmental variable ``COMP_WORDS``[m
[32m+[m[32m    :param cword: same as the environmental variable ``COMP_CWORD``[m
[32m+[m[32m    :param opts: The available options to check[m
[32m+[m[32m    :return: path completion type (``file``, ``dir``, ``path`` or None)[m
[32m+[m[32m    """[m
[32m+[m[32m    if cword < 2 or not cwords[cword - 2].startswith("-"):[m
[32m+[m[32m        return None[m
[32m+[m[32m    for opt in opts:[m
[32m+[m[32m        if opt.help == optparse.SUPPRESS_HELP:[m
[32m+[m[32m            continue[m
[32m+[m[32m        for o in str(opt).split("/"):[m
[32m+[m[32m            if cwords[cword - 2].split("=")[0] == o:[m
[32m+[m[32m                if not opt.metavar or any([m
[32m+[m[32m                    x in ("path", "file", "dir") for x in opt.metavar.split("/")[m
[32m+[m[32m                ):[m
[32m+[m[32m                    return opt.metavar[m
[32m+[m[32m    return None[m
[32m+[m
[32m+[m
[32m+[m[32mdef auto_complete_paths(current: str, completion_type: str) -> Iterable[str]:[m
[32m+[m[32m    """If ``completion_type`` is ``file`` or ``path``, list all regular files[m
[32m+[m[32m    and directories starting with ``current``; otherwise only list directories[m
[32m+[m[32m    starting with ``current``.[m
[32m+[m
[32m+[m[32m    :param current: The word to be completed[m
[32m+[m[32m    :param completion_type: path completion type(``file``, ``path`` or ``dir``)[m
[32m+[m[32m    :return: A generator of regular files and/or directories[m
[32m+[m[32m    """[m
[32m+[m[32m    directory, filename = os.path.split(current)[m
[32m+[m[32m    current_path = os.path.abspath(directory)[m
[32m+[m[32m    # Don't complete paths if they can't be accessed[m
[32m+[m[32m    if not os.access(current_path, os.R_OK):[m
[32m+[m[32m        return[m
[32m+[m[32m    filename = os.path.normcase(filename)[m
[32m+[m[32m    # list all files that start with ``filename``[m
[32m+[m[32m    file_list = ([m
[32m+[m[32m        x for x in os.listdir(current_path) if os.path.normcase(x).startswith(filename)[m
[32m+[m[32m    )[m
[32m+[m[32m    for f in file_list:[m
[32m+[m[32m        opt = os.path.join(current_path, f)[m
[32m+[m[32m        comp_file = os.path.normcase(os.path.join(directory, f))[m
[32m+[m[32m        # complete regular files when there is not ``<dir>`` after option[m
[32m+[m[32m        # complete directories when there is ``<file>``, ``<path>`` or[m
[32m+[m[32m        # ``<dir>``after option[m
[32m+[m[32m        if completion_type != "dir" and os.path.isfile(opt):[m
[32m+[m[32m            yield comp_file[m
[32m+[m[32m        elif os.path.isdir(opt):[m
[32m+[m[32m            yield os.path.join(comp_file, "")[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/base_command.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/base_command.py[m
[1mnew file mode 100644[m
[1mindex 0000000..db9d5cc[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/base_command.py[m
[36m@@ -0,0 +1,236 @@[m
[32m+[m[32m"""Base Command class, and related routines"""[m
[32m+[m
[32m+[m[32mimport functools[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport logging.config[m
[32m+[m[32mimport optparse[m
[32m+[m[32mimport os[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport traceback[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom typing import Any, Callable, List, Optional, Tuple[m
[32m+[m
[32m+[m[32mfrom pip._vendor.rich import traceback as rich_traceback[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli import cmdoptions[m
[32m+[m[32mfrom pip._internal.cli.command_context import CommandContextMixIn[m
[32m+[m[32mfrom pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter[m
[32m+[m[32mfrom pip._internal.cli.status_codes import ([m
[32m+[m[32m    ERROR,[m
[32m+[m[32m    PREVIOUS_BUILD_DIR_ERROR,[m
[32m+[m[32m    UNKNOWN_ERROR,[m
[32m+[m[32m    VIRTUALENV_NOT_FOUND,[m
[32m+[m[32m)[m
[32m+[m[32mfrom pip._internal.exceptions import ([m
[32m+[m[32m    BadCommand,[m
[32m+[m[32m    CommandError,[m
[32m+[m[32m    DiagnosticPipError,[m
[32m+[m[32m    InstallationError,[m
[32m+[m[32m    NetworkConnectionError,[m
[32m+[m[32m    PreviousBuildDirError,[m
[32m+[m[32m    UninstallationError,[m
[32m+[m[32m)[m
[32m+[m[32mfrom pip._internal.utils.filesystem import check_path_owner[m
[32m+[m[32mfrom pip._internal.utils.logging import BrokenStdoutLoggingError, setup_logging[m
[32m+[m[32mfrom pip._internal.utils.misc import get_prog, normalize_path[m
[32m+[m[32mfrom pip._internal.utils.temp_dir import TempDirectoryTypeRegistry as TempDirRegistry[m
[32m+[m[32mfrom pip._internal.utils.temp_dir import global_tempdir_manager, tempdir_registry[m
[32m+[m[32mfrom pip._internal.utils.virtualenv import running_under_virtualenv[m
[32m+[m
[32m+[m[32m__all__ = ["Command"][m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass Command(CommandContextMixIn):[m
[32m+[m[32m    usage: str = ""[m
[32m+[m[32m    ignore_require_venv: bool = False[m
[32m+[m
[32m+[m[32m    def __init__(self, name: str, summary: str, isolated: bool = False) -> None:[m
[32m+[m[32m        super().__init__()[m
[32m+[m
[32m+[m[32m        self.name = name[m
[32m+[m[32m        self.summary = summary[m
[32m+[m[32m        self.parser = ConfigOptionParser([m
[32m+[m[32m            usage=self.usage,[m
[32m+[m[32m            prog=f"{get_prog()} {name}",[m
[32m+[m[32m            formatter=UpdatingDefaultsHelpFormatter(),[m
[32m+[m[32m            add_help_option=False,[m
[32m+[m[32m            name=name,[m
[32m+[m[32m            description=self.__doc__,[m
[32m+[m[32m            isolated=isolated,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.tempdir_registry: Optional[TempDirRegistry] = None[m
[32m+[m
[32m+[m[32m        # Commands should add options to this option group[m
[32m+[m[32m        optgroup_name = f"{self.name.capitalize()} Options"[m
[32m+[m[32m        self.cmd_opts = optparse.OptionGroup(self.parser, optgroup_name)[m
[32m+[m
[32m+[m[32m        # Add the general options[m
[32m+[m[32m        gen_opts = cmdoptions.make_option_group([m
[32m+[m[32m            cmdoptions.general_group,[m
[32m+[m[32m            self.parser,[m
[32m+[m[32m        )[m
[32m+[m[32m        self.parser.add_option_group(gen_opts)[m
[32m+[m
[32m+[m[32m        self.add_options()[m
[32m+[m
[32m+[m[32m    def add_options(self) -> None:[m
[32m+[m[32m        pass[m
[32m+[m
[32m+[m[32m    def handle_pip_version_check(self, options: Values) -> None:[m
[32m+[m[32m        """[m
[32m+[m[32m        This is a no-op so that commands by default do not do the pip version[m
[32m+[m[32m        check.[m
[32m+[m[32m        """[m
[32m+[m[32m        # Make sure we do the pip version check if the index_group options[m
[32m+[m[32m        # are present.[m
[32m+[m[32m        assert not hasattr(options, "no_index")[m
[32m+[m
[32m+[m[32m    def run(self, options: Values, args: List[str]) -> int:[m
[32m+[m[32m        raise NotImplementedError[m
[32m+[m
[32m+[m[32m    def parse_args(self, args: List[str]) -> Tuple[Values, List[str]]:[m
[32m+[m[32m        # factored out for testability[m
[32m+[m[32m        return self.parser.parse_args(args)[m
[32m+[m
[32m+[m[32m    def main(self, args: List[str]) -> int:[m
[32m+[m[32m        try:[m
[32m+[m[32m            with self.main_context():[m
[32m+[m[32m                return self._main(args)[m
[32m+[m[32m        finally:[m
[32m+[m[32m            logging.shutdown()[m
[32m+[m
[32m+[m[32m    def _main(self, args: List[str]) -> int:[m
[32m+[m[32m        # We must initialize this before the tempdir manager, otherwise the[m
[32m+[m[32m        # configuration would not be accessible by the time we clean up the[m
[32m+[m[32m        # tempdir manager.[m
[32m+[m[32m        self.tempdir_registry = self.enter_context(tempdir_registry())[m
[32m+[m[32m        # Intentionally set as early as possible so globally-managed temporary[m
[32m+[m[32m        # directories are available to the rest of the code.[m
[32m+[m[32m        self.enter_context(global_tempdir_manager())[m
[32m+[m
[32m+[m[32m        options, args = self.parse_args(args)[m
[32m+[m
[32m+[m[32m        # Set verbosity so that it can be used elsewhere.[m
[32m+[m[32m        self.verbosity = options.verbose - options.quiet[m
[32m+[m
[32m+[m[32m        level_number = setup_logging([m
[32m+[m[32m            verbosity=self.verbosity,[m
[32m+[m[32m            no_color=options.no_color,[m
[32m+[m[32m            user_log_file=options.log,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        always_enabled_features = set(options.features_enabled) & set([m
[32m+[m[32m            cmdoptions.ALWAYS_ENABLED_FEATURES[m
[32m+[m[32m        )[m
[32m+[m[32m        if always_enabled_features:[m
[32m+[m[32m            logger.warning([m
[32m+[m[32m                "The following features are always enabled: %s. ",[m
[32m+[m[32m                ", ".join(sorted(always_enabled_features)),[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        # Make sure that the --python argument isn't specified after the[m
[32m+[m[32m        # subcommand. We can tell, because if --python was specified,[m
[32m+[m[32m        # we should only reach this point if we're running in the created[m
[32m+[m[32m        # subprocess, which has the _PIP_RUNNING_IN_SUBPROCESS environment[m
[32m+[m[32m        # variable set.[m
[32m+[m[32m        if options.python and "_PIP_RUNNING_IN_SUBPROCESS" not in os.environ:[m
[32m+[m[32m            logger.critical([m
[32m+[m[32m                "The --python option must be placed before the pip subcommand name"[m
[32m+[m[32m            )[m
[32m+[m[32m            sys.exit(ERROR)[m
[32m+[m
[32m+[m[32m        # TODO: Try to get these passing down from the command?[m
[32m+[m[32m        #       without resorting to os.environ to hold these.[m
[32m+[m[32m        #       This also affects isolated builds and it should.[m
[32m+[m
[32m+[m[32m        if options.no_input:[m
[32m+[m[32m            os.environ["PIP_NO_INPUT"] = "1"[m
[32m+[m
[32m+[m[32m        if options.exists_action:[m
[32m+[m[32m            os.environ["PIP_EXISTS_ACTION"] = " ".join(options.exists_action)[m
[32m+[m
[32m+[m[32m        if options.require_venv and not self.ignore_require_venv:[m
[32m+[m[32m            # If a venv is required check if it can really be found[m
[32m+[m[32m            if not running_under_virtualenv():[m
[32m+[m[32m                logger.critical("Could not find an activated virtualenv (required).")[m
[32m+[m[32m                sys.exit(VIRTUALENV_NOT_FOUND)[m
[32m+[m
[32m+[m[32m        if options.cache_dir:[m
[32m+[m[32m            options.cache_dir = normalize_path(options.cache_dir)[m
[32m+[m[32m            if not check_path_owner(options.cache_dir):[m
[32m+[m[32m                logger.warning([m
[32m+[m[32m                    "The directory '%s' or its parent directory is not owned "[m
[32m+[m[32m                    "or is not writable by the current user. The cache "[m
[32m+[m[32m                    "has been disabled. Check the permissions and owner of "[m
[32m+[m[32m                    "that directory. If executing pip with sudo, you should "[m
[32m+[m[32m                    "use sudo's -H flag.",[m
[32m+[m[32m                    options.cache_dir,[m
[32m+[m[32m                )[m
[32m+[m[32m                options.cache_dir = None[m
[32m+[m
[32m+[m[32m        def intercepts_unhandled_exc([m
[32m+[m[32m            run_func: Callable[..., int][m
[32m+[m[32m        ) -> Callable[..., int]:[m
[32m+[m[32m            @functools.wraps(run_func)[m
[32m+[m[32m            def exc_logging_wrapper(*args: Any) -> int:[m
[32m+[m[32m                try:[m
[32m+[m[32m                    status = run_func(*args)[m
[32m+[m[32m                    assert isinstance(status, int)[m
[32m+[m[32m                    return status[m
[32m+[m[32m                except DiagnosticPipError as exc:[m
[32m+[m[32m                    logger.error("%s", exc, extra={"rich": True})[m
[32m+[m[32m                    logger.debug("Exception information:", exc_info=True)[m
[32m+[m
[32m+[m[32m                    return ERROR[m
[32m+[m[32m                except PreviousBuildDirError as exc:[m
[32m+[m[32m                    logger.critical(str(exc))[m
[32m+[m[32m                    logger.debug("Exception information:", exc_info=True)[m
[32m+[m
[32m+[m[32m                    return PREVIOUS_BUILD_DIR_ERROR[m
[32m+[m[32m                except ([m
[32m+[m[32m                    InstallationError,[m
[32m+[m[32m                    UninstallationError,[m
[32m+[m[32m                    BadCommand,[m
[32m+[m[32m                    NetworkConnectionError,[m
[32m+[m[32m                ) as exc:[m
[32m+[m[32m                    logger.critical(str(exc))[m
[32m+[m[32m                    logger.debug("Exception information:", exc_info=True)[m
[32m+[m
[32m+[m[32m                    return ERROR[m
[32m+[m[32m                except CommandError as exc:[m
[32m+[m[32m                    logger.critical("%s", exc)[m
[32m+[m[32m                    logger.debug("Exception information:", exc_info=True)[m
[32m+[m
[32m+[m[32m                    return ERROR[m
[32m+[m[32m                except BrokenStdoutLoggingError:[m
[32m+[m[32m                    # Bypass our logger and write any remaining messages to[m
[32m+[m[32m                    # stderr because stdout no longer works.[m
[32m+[m[32m                    print("ERROR: Pipe to stdout was broken", file=sys.stderr)[m
[32m+[m[32m                    if level_number <= logging.DEBUG:[m
[32m+[m[32m                        traceback.print_exc(file=sys.stderr)[m
[32m+[m
[32m+[m[32m                    return ERROR[m
[32m+[m[32m                except KeyboardInterrupt:[m
[32m+[m[32m                    logger.critical("Operation cancelled by user")[m
[32m+[m[32m                    logger.debug("Exception information:", exc_info=True)[m
[32m+[m
[32m+[m[32m                    return ERROR[m
[32m+[m[32m                except BaseException:[m
[32m+[m[32m                    logger.critical("Exception:", exc_info=True)[m
[32m+[m
[32m+[m[32m                    return UNKNOWN_ERROR[m
[32m+[m
[32m+[m[32m            return exc_logging_wrapper[m
[32m+[m
[32m+[m[32m        try:[m
[32m+[m[32m            if not options.debug_mode:[m
[32m+[m[32m                run = intercepts_unhandled_exc(self.run)[m
[32m+[m[32m            else:[m
[32m+[m[32m                run = self.run[m
[32m+[m[32m                rich_traceback.install(show_locals=True)[m
[32m+[m[32m            return run(options, args)[m
[32m+[m[32m        finally:[m
[32m+[m[32m            self.handle_pip_version_check(options)[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/cmdoptions.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/cmdoptions.py[m
[1mnew file mode 100644[m
[1mindex 0000000..d05e502[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/cmdoptions.py[m
[36m@@ -0,0 +1,1074 @@[m
[32m+[m[32m"""[m
[32m+[m[32mshared options and groups[m
[32m+[m
[32m+[m[32mThe principle here is to define options once, but *not* instantiate them[m
[32m+[m[32mglobally. One reason being that options with action='append' can carry state[m
[32m+[m[32mbetween parses. pip parses general options twice internally, and shouldn't[m
[32m+[m[32mpass on state. To be consistent, all options will follow this design.[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32m# The following comment should be removed at some point in the future.[m
[32m+[m[32m# mypy: strict-optional=False[m
[32m+[m
[32m+[m[32mimport importlib.util[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport os[m
[32m+[m[32mimport textwrap[m
[32m+[m[32mfrom functools import partial[m
[32m+[m[32mfrom optparse import SUPPRESS_HELP, Option, OptionGroup, OptionParser, Values[m
[32m+[m[32mfrom textwrap import dedent[m
[32m+[m[32mfrom typing import Any, Callable, Dict, Optional, Tuple[m
[32m+[m
[32m+[m[32mfrom pip._vendor.packaging.utils import canonicalize_name[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli.parser import ConfigOptionParser[m
[32m+[m[32mfrom pip._internal.exceptions import CommandError[m
[32m+[m[32mfrom pip._internal.locations import USER_CACHE_DIR, get_src_prefix[m
[32m+[m[32mfrom pip._internal.models.format_control import FormatControl[m
[32m+[m[32mfrom pip._internal.models.index import PyPI[m
[32m+[m[32mfrom pip._internal.models.target_python import TargetPython[m
[32m+[m[32mfrom pip._internal.utils.hashes import STRONG_HASHES[m
[32m+[m[32mfrom pip._internal.utils.misc import strtobool[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mdef raise_option_error(parser: OptionParser, option: Option, msg: str) -> None:[m
[32m+[m[32m    """[m
[32m+[m[32m    Raise an option parsing error using parser.error().[m
[32m+[m
[32m+[m[32m    Args:[m
[32m+[m[32m      parser: an OptionParser instance.[m
[32m+[m[32m      option: an Option instance.[m
[32m+[m[32m      msg: the error text.[m
[32m+[m[32m    """[m
[32m+[m[32m    msg = f"{option} error: {msg}"[m
[32m+[m[32m    msg = textwrap.fill(" ".join(msg.split()))[m
[32m+[m[32m    parser.error(msg)[m
[32m+[m
[32m+[m
[32m+[m[32mdef make_option_group(group: Dict[str, Any], parser: ConfigOptionParser) -> OptionGroup:[m
[32m+[m[32m    """[m
[32m+[m[32m    Return an OptionGroup object[m
[32m+[m[32m    group  -- assumed to be dict with 'name' and 'options' keys[m
[32m+[m[32m    parser -- an optparse Parser[m
[32m+[m[32m    """[m
[32m+[m[32m    option_group = OptionGroup(parser, group["name"])[m
[32m+[m[32m    for option in group["options"]:[m
[32m+[m[32m        option_group.add_option(option())[m
[32m+[m[32m    return option_group[m
[32m+[m
[32m+[m
[32m+[m[32mdef check_dist_restriction(options: Values, check_target: bool = False) -> None:[m
[32m+[m[32m    """Function for determining if custom platform options are allowed.[m
[32m+[m
[32m+[m[32m    :param options: The OptionParser options.[m
[32m+[m[32m    :param check_target: Whether or not to check if --target is being used.[m
[32m+[m[32m    """[m
[32m+[m[32m    dist_restriction_set = any([m
[32m+[m[32m        [[m
[32m+[m[32m            options.python_version,[m
[32m+[m[32m            options.platforms,[m
[32m+[m[32m            options.abis,[m
[32m+[m[32m            options.implementation,[m
[32m+[m[32m        ][m
[32m+[m[32m    )[m
[32m+[m
[32m+[m[32m    binary_only = FormatControl(set(), {":all:"})[m
[32m+[m[32m    sdist_dependencies_allowed = ([m
[32m+[m[32m        options.format_control != binary_only and not options.ignore_dependencies[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m[32m    # Installations or downloads using dist restrictions must not combine[m
[32m+[m[32m    # source distributions and dist-specific wheels, as they are not[m
[32m+[m[32m    # guaranteed to be locally compatible.[m
[32m+[m[32m    if dist_restriction_set and sdist_dependencies_allowed:[m
[32m+[m[32m        raise CommandError([m
[32m+[m[32m            "When restricting platform and interpreter constraints using "[m
[32m+[m[32m            "--python-version, --platform, --abi, or --implementation, "[m
[32m+[m[32m            "either --no-deps must be set, or --only-binary=:all: must be "[m
[32m+[m[32m            "set and --no-binary must not be set (or must be set to "[m
[32m+[m[32m            ":none:)."[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    if check_target:[m
[32m+[m[32m        if not options.dry_run and dist_restriction_set and not options.target_dir:[m
[32m+[m[32m            raise CommandError([m
[32m+[m[32m                "Can not use any platform or abi specific options unless "[m
[32m+[m[32m                "installing via '--target' or using '--dry-run'"[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m
[32m+[m[32mdef _path_option_check(option: Option, opt: str, value: str) -> str:[m
[32m+[m[32m    return os.path.expanduser(value)[m
[32m+[m
[32m+[m
[32m+[m[32mdef _package_name_option_check(option: Option, opt: str, value: str) -> str:[m
[32m+[m[32m    return canonicalize_name(value)[m
[32m+[m
[32m+[m
[32m+[m[32mclass PipOption(Option):[m
[32m+[m[32m    TYPES = Option.TYPES + ("path", "package_name")[m
[32m+[m[32m    TYPE_CHECKER = Option.TYPE_CHECKER.copy()[m
[32m+[m[32m    TYPE_CHECKER["package_name"] = _package_name_option_check[m
[32m+[m[32m    TYPE_CHECKER["path"] = _path_option_check[m
[32m+[m
[32m+[m
[32m+[m[32m###########[m
[32m+[m[32m# options #[m
[32m+[m[32m###########[m
[32m+[m
[32m+[m[32mhelp_: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "-h",[m
[32m+[m[32m    "--help",[m
[32m+[m[32m    dest="help",[m
[32m+[m[32m    action="help",[m
[32m+[m[32m    help="Show help.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mdebug_mode: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--debug",[m
[32m+[m[32m    dest="debug_mode",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help=([m
[32m+[m[32m        "Let unhandled exceptions propagate outside the main subroutine, "[m
[32m+[m[32m        "instead of logging them to stderr."[m
[32m+[m[32m    ),[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32misolated_mode: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--isolated",[m
[32m+[m[32m    dest="isolated_mode",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help=([m
[32m+[m[32m        "Run pip in an isolated mode, ignoring environment variables and user "[m
[32m+[m[32m        "configuration."[m
[32m+[m[32m    ),[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mrequire_virtualenv: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--require-virtualenv",[m
[32m+[m[32m    "--require-venv",[m
[32m+[m[32m    dest="require_venv",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help=([m
[32m+[m[32m        "Allow pip to only run in a virtual environment; "[m
[32m+[m[32m        "exit with an error otherwise."[m
[32m+[m[32m    ),[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32moverride_externally_managed: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--break-system-packages",[m
[32m+[m[32m    dest="override_externally_managed",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    help="Allow pip to modify an EXTERNALLY-MANAGED Python installation",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mpython: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--python",[m
[32m+[m[32m    dest="python",[m
[32m+[m[32m    help="Run pip with the specified Python interpreter.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mverbose: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "-v",[m
[32m+[m[32m    "--verbose",[m
[32m+[m[32m    dest="verbose",[m
[32m+[m[32m    action="count",[m
[32m+[m[32m    default=0,[m
[32m+[m[32m    help="Give more output. Option is additive, and can be used up to 3 times.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mno_color: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--no-color",[m
[32m+[m[32m    dest="no_color",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Suppress colored output.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mversion: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "-V",[m
[32m+[m[32m    "--version",[m
[32m+[m[32m    dest="version",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    help="Show version and exit.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mquiet: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "-q",[m
[32m+[m[32m    "--quiet",[m
[32m+[m[32m    dest="quiet",[m
[32m+[m[32m    action="count",[m
[32m+[m[32m    default=0,[m
[32m+[m[32m    help=([m
[32m+[m[32m        "Give less output. Option is additive, and can be used up to 3"[m
[32m+[m[32m        " times (corresponding to WARNING, ERROR, and CRITICAL logging"[m
[32m+[m[32m        " levels)."[m
[32m+[m[32m    ),[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mprogress_bar: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--progress-bar",[m
[32m+[m[32m    dest="progress_bar",[m
[32m+[m[32m    type="choice",[m
[32m+[m[32m    choices=["on", "off"],[m
[32m+[m[32m    default="on",[m
[32m+[m[32m    help="Specify whether the progress bar should be used [on, off] (default: on)",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mlog: Callable[..., Option] = partial([m
[32m+[m[32m    PipOption,[m
[32m+[m[32m    "--log",[m
[32m+[m[32m    "--log-file",[m
[32m+[m[32m    "--local-log",[m
[32m+[m[32m    dest="log",[m
[32m+[m[32m    metavar="path",[m
[32m+[m[32m    type="path",[m
[32m+[m[32m    help="Path to a verbose appending log.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mno_input: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    # Don't ask for input[m
[32m+[m[32m    "--no-input",[m
[32m+[m[32m    dest="no_input",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Disable prompting for input.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mkeyring_provider: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--keyring-provider",[m
[32m+[m[32m    dest="keyring_provider",[m
[32m+[m[32m    choices=["auto", "disabled", "import", "subprocess"],[m
[32m+[m[32m    default="auto",[m
[32m+[m[32m    help=([m
[32m+[m[32m        "Enable the credential lookup via the keyring library if user input is allowed."[m
[32m+[m[32m        " Specify which mechanism to use [disabled, import, subprocess]."[m
[32m+[m[32m        " (default: disabled)"[m
[32m+[m[32m    ),[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mproxy: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--proxy",[m
[32m+[m[32m    dest="proxy",[m
[32m+[m[32m    type="str",[m
[32m+[m[32m    default="",[m
[32m+[m[32m    help="Specify a proxy in the form scheme://[user:passwd@]proxy.server:port.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mretries: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--retries",[m
[32m+[m[32m    dest="retries",[m
[32m+[m[32m    type="int",[m
[32m+[m[32m    default=5,[m
[32m+[m[32m    help="Maximum number of retries each connection should attempt "[m
[32m+[m[32m    "(default %default times).",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mtimeout: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--timeout",[m
[32m+[m[32m    "--default-timeout",[m
[32m+[m[32m    metavar="sec",[m
[32m+[m[32m    dest="timeout",[m
[32m+[m[32m    type="float",[m
[32m+[m[32m    default=15,[m
[32m+[m[32m    help="Set the socket timeout (default %default seconds).",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mdef exists_action() -> Option:[m
[32m+[m[32m    return Option([m
[32m+[m[32m        # Option when path already exist[m
[32m+[m[32m        "--exists-action",[m
[32m+[m[32m        dest="exists_action",[m
[32m+[m[32m        type="choice",[m
[32m+[m[32m        choices=["s", "i", "w", "b", "a"],[m
[32m+[m[32m        default=[],[m
[32m+[m[32m        action="append",[m
[32m+[m[32m        metavar="action",[m
[32m+[m[32m        help="Default action when a path already exists: "[m
[32m+[m[32m        "(s)witch, (i)gnore, (w)ipe, (b)ackup, (a)bort.",[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mcert: Callable[..., Option] = partial([m
[32m+[m[32m    PipOption,[m
[32m+[m[32m    "--cert",[m
[32m+[m[32m    dest="cert",[m
[32m+[m[32m    type="path",[m
[32m+[m[32m    metavar="path",[m
[32m+[m[32m    help=([m
[32m+[m[32m        "Path to PEM-encoded CA certificate bundle. "[m
[32m+[m[32m        "If provided, overrides the default. "[m
[32m+[m[32m        "See 'SSL Certificate Verification' in pip documentation "[m
[32m+[m[32m        "for more information."[m
[32m+[m[32m    ),[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mclient_cert: Callable[..., Option] = partial([m
[32m+[m[32m    PipOption,[m
[32m+[m[32m    "--client-cert",[m
[32m+[m[32m    dest="client_cert",[m
[32m+[m[32m    type="path",[m
[32m+[m[32m    default=None,[m
[32m+[m[32m    metavar="path",[m
[32m+[m[32m    help="Path to SSL client certificate, a single file containing the "[m
[32m+[m[32m    "private key and the certificate in PEM format.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mindex_url: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "-i",[m
[32m+[m[32m    "--index-url",[m
[32m+[m[32m    "--pypi-url",[m
[32m+[m[32m    dest="index_url",[m
[32m+[m[32m    metavar="URL",[m
[32m+[m[32m    default=PyPI.simple_url,[m
[32m+[m[32m    help="Base URL of the Python Package Index (default %default). "[m
[32m+[m[32m    "This should point to a repository compliant with PEP 503 "[m
[32m+[m[32m    "(the simple repository API) or a local directory laid out "[m
[32m+[m[32m    "in the same format.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mdef extra_index_url() -> Option:[m
[32m+[m[32m    return Option([m
[32m+[m[32m        "--extra-index-url",[m
[32m+[m[32m        dest="extra_index_urls",[m
[32m+[m[32m        metavar="URL",[m
[32m+[m[32m        action="append",[m
[32m+[m[32m        default=[],[m
[32m+[m[32m        help="Extra URLs of package indexes to use in addition to "[m
[32m+[m[32m        "--index-url. Should follow the same rules as "[m
[32m+[m[32m        "--index-url.",[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mno_index: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--no-index",[m
[32m+[m[32m    dest="no_index",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Ignore package index (only looking at --find-links URLs instead).",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mdef find_links() -> Option:[m
[32m+[m[32m    return Option([m
[32m+[m[32m        "-f",[m
[32m+[m[32m        "--find-links",[m
[32m+[m[32m        dest="find_links",[m
[32m+[m[32m        action="append",[m
[32m+[m[32m        default=[],[m
[32m+[m[32m        metavar="url",[m
[32m+[m[32m        help="If a URL or path to an html file, then parse for links to "[m
[32m+[m[32m        "archives such as sdist (.tar.gz) or wheel (.whl) files. "[m
[32m+[m[32m        "If a local path or file:// URL that's a directory, "[m
[32m+[m[32m        "then look for archives in the directory listing. "[m
[32m+[m[32m        "Links to VCS project URLs are not supported.",[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mdef trusted_host() -> Option:[m
[32m+[m[32m    return Option([m
[32m+[m[32m        "--trusted-host",[m
[32m+[m[32m        dest="trusted_hosts",[m
[32m+[m[32m        action="append",[m
[32m+[m[32m        metavar="HOSTNAME",[m
[32m+[m[32m        default=[],[m
[32m+[m[32m        help="Mark this host or host:port pair as trusted, even though it "[m
[32m+[m[32m        "does not have valid or any HTTPS.",[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mdef constraints() -> Option:[m
[32m+[m[32m    return Option([m
[32m+[m[32m        "-c",[m
[32m+[m[32m        "--constraint",[m
[32m+[m[32m        dest="constraints",[m
[32m+[m[32m        action="append",[m
[32m+[m[32m        default=[],[m
[32m+[m[32m        metavar="file",[m
[32m+[m[32m        help="Constrain versions using the given constraints file. "[m
[32m+[m[32m        "This option can be used multiple times.",[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mdef requirements() -> Option:[m
[32m+[m[32m    return Option([m
[32m+[m[32m        "-r",[m
[32m+[m[32m        "--requirement",[m
[32m+[m[32m        dest="requirements",[m
[32m+[m[32m        action="append",[m
[32m+[m[32m        default=[],[m
[32m+[m[32m        metavar="file",[m
[32m+[m[32m        help="Install from the given requirements file. "[m
[32m+[m[32m        "This option can be used multiple times.",[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mdef editable() -> Option:[m
[32m+[m[32m    return Option([m
[32m+[m[32m        "-e",[m
[32m+[m[32m        "--editable",[m
[32m+[m[32m        dest="editables",[m
[32m+[m[32m        action="append",[m
[32m+[m[32m        default=[],[m
[32m+[m[32m        metavar="path/url",[m
[32m+[m[32m        help=([m
[32m+[m[32m            "Install a project in editable mode (i.e. setuptools "[m
[32m+[m[32m            '"develop mode") from a local project path or a VCS url.'[m
[32m+[m[32m        ),[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mdef _handle_src(option: Option, opt_str: str, value: str, parser: OptionParser) -> None:[m
[32m+[m[32m    value = os.path.abspath(value)[m
[32m+[m[32m    setattr(parser.values, option.dest, value)[m
[32m+[m
[32m+[m
[32m+[m[32msrc: Callable[..., Option] = partial([m
[32m+[m[32m    PipOption,[m
[32m+[m[32m    "--src",[m
[32m+[m[32m    "--source",[m
[32m+[m[32m    "--source-dir",[m
[32m+[m[32m    "--source-directory",[m
[32m+[m[32m    dest="src_dir",[m
[32m+[m[32m    type="path",[m
[32m+[m[32m    metavar="dir",[m
[32m+[m[32m    default=get_src_prefix(),[m
[32m+[m[32m    action="callback",[m
[32m+[m[32m    callback=_handle_src,[m
[32m+[m[32m    help="Directory to check out editable projects into. "[m
[32m+[m[32m    'The default in a virtualenv is "<venv path>/src". '[m
[32m+[m[32m    'The default for global installs is "<current dir>/src".',[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mdef _get_format_control(values: Values, option: Option) -> Any:[m
[32m+[m[32m    """Get a format_control object."""[m
[32m+[m[32m    return getattr(values, option.dest)[m
[32m+[m
[32m+[m
[32m+[m[32mdef _handle_no_binary([m
[32m+[m[32m    option: Option, opt_str: str, value: str, parser: OptionParser[m
[32m+[m[32m) -> None:[m
[32m+[m[32m    existing = _get_format_control(parser.values, option)[m
[32m+[m[32m    FormatControl.handle_mutual_excludes([m
[32m+[m[32m        value,[m
[32m+[m[32m        existing.no_binary,[m
[32m+[m[32m        existing.only_binary,[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mdef _handle_only_binary([m
[32m+[m[32m    option: Option, opt_str: str, value: str, parser: OptionParser[m
[32m+[m[32m) -> None:[m
[32m+[m[32m    existing = _get_format_control(parser.values, option)[m
[32m+[m[32m    FormatControl.handle_mutual_excludes([m
[32m+[m[32m        value,[m
[32m+[m[32m        existing.only_binary,[m
[32m+[m[32m        existing.no_binary,[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mdef no_binary() -> Option:[m
[32m+[m[32m    format_control = FormatControl(set(), set())[m
[32m+[m[32m    return Option([m
[32m+[m[32m        "--no-binary",[m
[32m+[m[32m        dest="format_control",[m
[32m+[m[32m        action="callback",[m
[32m+[m[32m        callback=_handle_no_binary,[m
[32m+[m[32m        type="str",[m
[32m+[m[32m        default=format_control,[m
[32m+[m[32m        help="Do not use binary packages. Can be supplied multiple times, and "[m
[32m+[m[32m        'each time adds to the existing value. Accepts either ":all:" to '[m
[32m+[m[32m        'disable all binary packages, ":none:" to empty the set (notice '[m
[32m+[m[32m        "the colons), or one or more package names with commas between "[m
[32m+[m[32m        "them (no colons). Note that some packages are tricky to compile "[m
[32m+[m[32m        "and may fail to install when this option is used on them.",[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mdef only_binary() -> Option:[m
[32m+[m[32m    format_control = FormatControl(set(), set())[m
[32m+[m[32m    return Option([m
[32m+[m[32m        "--only-binary",[m
[32m+[m[32m        dest="format_control",[m
[32m+[m[32m        action="callback",[m
[32m+[m[32m        callback=_handle_only_binary,[m
[32m+[m[32m        type="str",[m
[32m+[m[32m        default=format_control,[m
[32m+[m[32m        help="Do not use source packages. Can be supplied multiple times, and "[m
[32m+[m[32m        'each time adds to the existing value. Accepts either ":all:" to '[m
[32m+[m[32m        'disable all source packages, ":none:" to empty the set, or one '[m
[32m+[m[32m        "or more package names with commas between them. Packages "[m
[32m+[m[32m        "without binary distributions will fail to install when this "[m
[32m+[m[32m        "option is used on them.",[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mplatforms: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--platform",[m
[32m+[m[32m    dest="platforms",[m
[32m+[m[32m    metavar="platform",[m
[32m+[m[32m    action="append",[m
[32m+[m[32m    default=None,[m
[32m+[m[32m    help=([m
[32m+[m[32m        "Only use wheels compatible with <platform>. Defaults to the "[m
[32m+[m[32m        "platform of the running system. Use this option multiple times to "[m
[32m+[m[32m        "specify multiple platforms supported by the target interpreter."[m
[32m+[m[32m    ),[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32m# This was made a separate function for unit-testing purposes.[m
[32m+[m[32mdef _convert_python_version(value: str) -> Tuple[Tuple[int, ...], Optional[str]]:[m
[32m+[m[32m    """[m
[32m+[m[32m    Convert a version string like "3", "37", or "3.7.3" into a tuple of ints.[m
[32m+[m
[32m+[m[32m    :return: A 2-tuple (version_info, error_msg), where `error_msg` is[m
[32m+[m[32m        non-None if and only if there was a parsing error.[m
[32m+[m[32m    """[m
[32m+[m[32m    if not value:[m
[32m+[m[32m        # The empty string is the same as not providing a value.[m
[32m+[m[32m        return (None, None)[m
[32m+[m
[32m+[m[32m    parts = value.split(".")[m
[32m+[m[32m    if len(parts) > 3:[m
[32m+[m[32m        return ((), "at most three version parts are allowed")[m
[32m+[m
[32m+[m[32m    if len(parts) == 1:[m
[32m+[m[32m        # Then we are in the case of "3" or "37".[m
[32m+[m[32m        value = parts[0][m
[32m+[m[32m        if len(value) > 1:[m
[32m+[m[32m            parts = [value[0], value[1:]][m
[32m+[m
[32m+[m[32m    try:[m
[32m+[m[32m        version_info = tuple(int(part) for part in parts)[m
[32m+[m[32m    except ValueError:[m
[32m+[m[32m        return ((), "each version part must be an integer")[m
[32m+[m
[32m+[m[32m    return (version_info, None)[m
[32m+[m
[32m+[m
[32m+[m[32mdef _handle_python_version([m
[32m+[m[32m    option: Option, opt_str: str, value: str, parser: OptionParser[m
[32m+[m[32m) -> None:[m
[32m+[m[32m    """[m
[32m+[m[32m    Handle a provided --python-version value.[m
[32m+[m[32m    """[m
[32m+[m[32m    version_info, error_msg = _convert_python_version(value)[m
[32m+[m[32m    if error_msg is not None:[m
[32m+[m[32m        msg = f"invalid --python-version value: {value!r}: {error_msg}"[m
[32m+[m[32m        raise_option_error(parser, option=option, msg=msg)[m
[32m+[m
[32m+[m[32m    parser.values.python_version = version_info[m
[32m+[m
[32m+[m
[32m+[m[32mpython_version: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--python-version",[m
[32m+[m[32m    dest="python_version",[m
[32m+[m[32m    metavar="python_version",[m
[32m+[m[32m    action="callback",[m
[32m+[m[32m    callback=_handle_python_version,[m
[32m+[m[32m    type="str",[m
[32m+[m[32m    default=None,[m
[32m+[m[32m    help=dedent([m
[32m+[m[32m        """\[m
[32m+[m[32m    The Python interpreter version to use for wheel and "Requires-Python"[m
[32m+[m[32m    compatibility checks. Defaults to a version derived from the running[m
[32m+[m[32m    interpreter. The version can be specified using up to three dot-separated[m
[32m+[m[32m    integers (e.g. "3" for 3.0.0, "3.7" for 3.7.0, or "3.7.3"). A major-minor[m
[32m+[m[32m    version can also be given as a string without dots (e.g. "37" for 3.7.0).[m
[32m+[m[32m    """[m
[32m+[m[32m    ),[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mimplementation: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--implementation",[m
[32m+[m[32m    dest="implementation",[m
[32m+[m[32m    metavar="implementation",[m
[32m+[m[32m    default=None,[m
[32m+[m[32m    help=([m
[32m+[m[32m        "Only use wheels compatible with Python "[m
[32m+[m[32m        "implementation <implementation>, e.g. 'pp', 'jy', 'cp', "[m
[32m+[m[32m        " or 'ip'. If not specified, then the current "[m
[32m+[m[32m        "interpreter implementation is used.  Use 'py' to force "[m
[32m+[m[32m        "implementation-agnostic wheels."[m
[32m+[m[32m    ),[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mabis: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--abi",[m
[32m+[m[32m    dest="abis",[m
[32m+[m[32m    metavar="abi",[m
[32m+[m[32m    action="append",[m
[32m+[m[32m    default=None,[m
[32m+[m[32m    help=([m
[32m+[m[32m        "Only use wheels compatible with Python abi <abi>, e.g. 'pypy_41'. "[m
[32m+[m[32m        "If not specified, then the current interpreter abi tag is used. "[m
[32m+[m[32m        "Use this option multiple times to specify multiple abis supported "[m
[32m+[m[32m        "by the target interpreter. Generally you will need to specify "[m
[32m+[m[32m        "--implementation, --platform, and --python-version when using this "[m
[32m+[m[32m        "option."[m
[32m+[m[32m    ),[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mdef add_target_python_options(cmd_opts: OptionGroup) -> None:[m
[32m+[m[32m    cmd_opts.add_option(platforms())[m
[32m+[m[32m    cmd_opts.add_option(python_version())[m
[32m+[m[32m    cmd_opts.add_option(implementation())[m
[32m+[m[32m    cmd_opts.add_option(abis())[m
[32m+[m
[32m+[m
[32m+[m[32mdef make_target_python(options: Values) -> TargetPython:[m
[32m+[m[32m    target_python = TargetPython([m
[32m+[m[32m        platforms=options.platforms,[m
[32m+[m[32m        py_version_info=options.python_version,[m
[32m+[m[32m        abis=options.abis,[m
[32m+[m[32m        implementation=options.implementation,[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m[32m    return target_python[m
[32m+[m
[32m+[m
[32m+[m[32mdef prefer_binary() -> Option:[m
[32m+[m[32m    return Option([m
[32m+[m[32m        "--prefer-binary",[m
[32m+[m[32m        dest="prefer_binary",[m
[32m+[m[32m        action="store_true",[m
[32m+[m[32m        default=False,[m
[32m+[m[32m        help=([m
[32m+[m[32m            "Prefer binary packages over source packages, even if the "[m
[32m+[m[32m            "source packages are newer."[m
[32m+[m[32m        ),[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mcache_dir: Callable[..., Option] = partial([m
[32m+[m[32m    PipOption,[m
[32m+[m[32m    "--cache-dir",[m
[32m+[m[32m    dest="cache_dir",[m
[32m+[m[32m    default=USER_CACHE_DIR,[m
[32m+[m[32m    metavar="dir",[m
[32m+[m[32m    type="path",[m
[32m+[m[32m    help="Store the cache data in <dir>.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mdef _handle_no_cache_dir([m
[32m+[m[32m    option: Option, opt: str, value: str, parser: OptionParser[m
[32m+[m[32m) -> None:[m
[32m+[m[32m    """[m
[32m+[m[32m    Process a value provided for the --no-cache-dir option.[m
[32m+[m
[32m+[m[32m    This is an optparse.Option callback for the --no-cache-dir option.[m
[32m+[m[32m    """[m
[32m+[m[32m    # The value argument will be None if --no-cache-dir is passed via the[m
[32m+[m[32m    # command-line, since the option doesn't accept arguments.  However,[m
[32m+[m[32m    # the value can be non-None if the option is triggered e.g. by an[m
[32m+[m[32m    # environment variable, like PIP_NO_CACHE_DIR=true.[m
[32m+[m[32m    if value is not None:[m
[32m+[m[32m        # Then parse the string value to get argument error-checking.[m
[32m+[m[32m        try:[m
[32m+[m[32m            strtobool(value)[m
[32m+[m[32m        except ValueError as exc:[m
[32m+[m[32m            raise_option_error(parser, option=option, msg=str(exc))[m
[32m+[m
[32m+[m[32m    # Originally, setting PIP_NO_CACHE_DIR to a value that strtobool()[m
[32m+[m[32m    # converted to 0 (like "false" or "no") caused cache_dir to be disabled[m
[32m+[m[32m    # rather than enabled (logic would say the latter).  Thus, we disable[m
[32m+[m[32m    # the cache directory not just on values that parse to True, but (for[m
[32m+[m[32m    # backwards compatibility reasons) also on values that parse to False.[m
[32m+[m[32m    # In other words, always set it to False if the option is provided in[m
[32m+[m[32m    # some (valid) form.[m
[32m+[m[32m    parser.values.cache_dir = False[m
[32m+[m
[32m+[m
[32m+[m[32mno_cache: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--no-cache-dir",[m
[32m+[m[32m    dest="cache_dir",[m
[32m+[m[32m    action="callback",[m
[32m+[m[32m    callback=_handle_no_cache_dir,[m
[32m+[m[32m    help="Disable the cache.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mno_deps: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--no-deps",[m
[32m+[m[32m    "--no-dependencies",[m
[32m+[m[32m    dest="ignore_dependencies",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Don't install package dependencies.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mignore_requires_python: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--ignore-requires-python",[m
[32m+[m[32m    dest="ignore_requires_python",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    help="Ignore the Requires-Python information.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mno_build_isolation: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--no-build-isolation",[m
[32m+[m[32m    dest="build_isolation",[m
[32m+[m[32m    action="store_false",[m
[32m+[m[32m    default=True,[m
[32m+[m[32m    help="Disable isolation when building a modern source distribution. "[m
[32m+[m[32m    "Build dependencies specified by PEP 518 must be already installed "[m
[32m+[m[32m    "if this option is used.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mcheck_build_deps: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--check-build-dependencies",[m
[32m+[m[32m    dest="check_build_deps",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Check the build dependencies when PEP517 is used.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mdef _handle_no_use_pep517([m
[32m+[m[32m    option: Option, opt: str, value: str, parser: OptionParser[m
[32m+[m[32m) -> None:[m
[32m+[m[32m    """[m
[32m+[m[32m    Process a value provided for the --no-use-pep517 option.[m
[32m+[m
[32m+[m[32m    This is an optparse.Option callback for the no_use_pep517 option.[m
[32m+[m[32m    """[m
[32m+[m[32m    # Since --no-use-pep517 doesn't accept arguments, the value argument[m
[32m+[m[32m    # will be None if --no-use-pep517 is passed via the command-line.[m
[32m+[m[32m    # However, the value can be non-None if the option is triggered e.g.[m
[32m+[m[32m    # by an environment variable, for example "PIP_NO_USE_PEP517=true".[m
[32m+[m[32m    if value is not None:[m
[32m+[m[32m        msg = """A value was passed for --no-use-pep517,[m
[32m+[m[32m        probably using either the PIP_NO_USE_PEP517 environment variable[m
[32m+[m[32m        or the "no-use-pep517" config file option. Use an appropriate value[m
[32m+[m[32m        of the PIP_USE_PEP517 environment variable or the "use-pep517"[m
[32m+[m[32m        config file option instead.[m
[32m+[m[32m        """[m
[32m+[m[32m        raise_option_error(parser, option=option, msg=msg)[m
[32m+[m
[32m+[m[32m    # If user doesn't wish to use pep517, we check if setuptools and wheel are installed[m
[32m+[m[32m    # and raise error if it is not.[m
[32m+[m[32m    packages = ("setuptools", "wheel")[m
[32m+[m[32m    if not all(importlib.util.find_spec(package) for package in packages):[m
[32m+[m[32m        msg = ([m
[32m+[m[32m            f"It is not possible to use --no-use-pep517 "[m
[32m+[m[32m            f"without {' and '.join(packages)} installed."[m
[32m+[m[32m        )[m
[32m+[m[32m        raise_option_error(parser, option=option, msg=msg)[m
[32m+[m
[32m+[m[32m    # Otherwise, --no-use-pep517 was passed via the command-line.[m
[32m+[m[32m    parser.values.use_pep517 = False[m
[32m+[m
[32m+[m
[32m+[m[32muse_pep517: Any = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--use-pep517",[m
[32m+[m[32m    dest="use_pep517",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=None,[m
[32m+[m[32m    help="Use PEP 517 for building source distributions "[m
[32m+[m[32m    "(use --no-use-pep517 to force legacy behaviour).",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mno_use_pep517: Any = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--no-use-pep517",[m
[32m+[m[32m    dest="use_pep517",[m
[32m+[m[32m    action="callback",[m
[32m+[m[32m    callback=_handle_no_use_pep517,[m
[32m+[m[32m    default=None,[m
[32m+[m[32m    help=SUPPRESS_HELP,[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mdef _handle_config_settings([m
[32m+[m[32m    option: Option, opt_str: str, value: str, parser: OptionParser[m
[32m+[m[32m) -> None:[m
[32m+[m[32m    key, sep, val = value.partition("=")[m
[32m+[m[32m    if sep != "=":[m
[32m+[m[32m        parser.error(f"Arguments to {opt_str} must be of the form KEY=VAL")[m
[32m+[m[32m    dest = getattr(parser.values, option.dest)[m
[32m+[m[32m    if dest is None:[m
[32m+[m[32m        dest = {}[m
[32m+[m[32m        setattr(parser.values, option.dest, dest)[m
[32m+[m[32m    if key in dest:[m
[32m+[m[32m        if isinstance(dest[key], list):[m
[32m+[m[32m            dest[key].append(val)[m
[32m+[m[32m        else:[m
[32m+[m[32m            dest[key] = [dest[key], val][m
[32m+[m[32m    else:[m
[32m+[m[32m        dest[key] = val[m
[32m+[m
[32m+[m
[32m+[m[32mconfig_settings: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "-C",[m
[32m+[m[32m    "--config-settings",[m
[32m+[m[32m    dest="config_settings",[m
[32m+[m[32m    type=str,[m
[32m+[m[32m    action="callback",[m
[32m+[m[32m    callback=_handle_config_settings,[m
[32m+[m[32m    metavar="settings",[m
[32m+[m[32m    help="Configuration settings to be passed to the PEP 517 build backend. "[m
[32m+[m[32m    "Settings take the form KEY=VALUE. Use multiple --config-settings options "[m
[32m+[m[32m    "to pass multiple keys to the backend.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mbuild_options: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--build-option",[m
[32m+[m[32m    dest="build_options",[m
[32m+[m[32m    metavar="options",[m
[32m+[m[32m    action="append",[m
[32m+[m[32m    help="Extra arguments to be supplied to 'setup.py bdist_wheel'.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mglobal_options: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--global-option",[m
[32m+[m[32m    dest="global_options",[m
[32m+[m[32m    action="append",[m
[32m+[m[32m    metavar="options",[m
[32m+[m[32m    help="Extra global options to be supplied to the setup.py "[m
[32m+[m[32m    "call before the install or bdist_wheel command.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mno_clean: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--no-clean",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Don't clean up build directories.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mpre: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--pre",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Include pre-release and development versions. By default, "[m
[32m+[m[32m    "pip only finds stable versions.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mdisable_pip_version_check: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--disable-pip-version-check",[m
[32m+[m[32m    dest="disable_pip_version_check",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Don't periodically check PyPI to determine whether a new version "[m
[32m+[m[32m    "of pip is available for download. Implied with --no-index.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mroot_user_action: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--root-user-action",[m
[32m+[m[32m    dest="root_user_action",[m
[32m+[m[32m    default="warn",[m
[32m+[m[32m    choices=["warn", "ignore"],[m
[32m+[m[32m    help="Action if pip is run as a root user. By default, a warning message is shown.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mdef _handle_merge_hash([m
[32m+[m[32m    option: Option, opt_str: str, value: str, parser: OptionParser[m
[32m+[m[32m) -> None:[m
[32m+[m[32m    """Given a value spelled "algo:digest", append the digest to a list[m
[32m+[m[32m    pointed to in a dict by the algo name."""[m
[32m+[m[32m    if not parser.values.hashes:[m
[32m+[m[32m        parser.values.hashes = {}[m
[32m+[m[32m    try:[m
[32m+[m[32m        algo, digest = value.split(":", 1)[m
[32m+[m[32m    except ValueError:[m
[32m+[m[32m        parser.error([m
[32m+[m[32m            f"Arguments to {opt_str} must be a hash name "[m
[32m+[m[32m            "followed by a value, like --hash=sha256:"[m
[32m+[m[32m            "abcde..."[m
[32m+[m[32m        )[m
[32m+[m[32m    if algo not in STRONG_HASHES:[m
[32m+[m[32m        parser.error([m
[32m+[m[32m            "Allowed hash algorithms for {} are {}.".format([m
[32m+[m[32m                opt_str, ", ".join(STRONG_HASHES)[m
[32m+[m[32m            )[m
[32m+[m[32m        )[m
[32m+[m[32m    parser.values.hashes.setdefault(algo, []).append(digest)[m
[32m+[m
[32m+[m
[32m+[m[32mhash: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--hash",[m
[32m+[m[32m    # Hash values eventually end up in InstallRequirement.hashes due to[m
[32m+[m[32m    # __dict__ copying in process_line().[m
[32m+[m[32m    dest="hashes",[m
[32m+[m[32m    action="callback",[m
[32m+[m[32m    callback=_handle_merge_hash,[m
[32m+[m[32m    type="string",[m
[32m+[m[32m    help="Verify that the package's archive matches this "[m
[32m+[m[32m    "hash before installing. Example: --hash=sha256:abcdef...",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mrequire_hashes: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--require-hashes",[m
[32m+[m[32m    dest="require_hashes",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Require a hash to check each requirement against, for "[m
[32m+[m[32m    "repeatable installs. This option is implied when any package in a "[m
[32m+[m[32m    "requirements file has a --hash option.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mlist_path: Callable[..., Option] = partial([m
[32m+[m[32m    PipOption,[m
[32m+[m[32m    "--path",[m
[32m+[m[32m    dest="path",[m
[32m+[m[32m    type="path",[m
[32m+[m[32m    action="append",[m
[32m+[m[32m    help="Restrict to the specified installation path for listing "[m
[32m+[m[32m    "packages (can be used multiple times).",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mdef check_list_path_option(options: Values) -> None:[m
[32m+[m[32m    if options.path and (options.user or options.local):[m
[32m+[m[32m        raise CommandError("Cannot combine '--path' with '--user' or '--local'")[m
[32m+[m
[32m+[m
[32m+[m[32mlist_exclude: Callable[..., Option] = partial([m
[32m+[m[32m    PipOption,[m
[32m+[m[32m    "--exclude",[m
[32m+[m[32m    dest="excludes",[m
[32m+[m[32m    action="append",[m
[32m+[m[32m    metavar="package",[m
[32m+[m[32m    type="package_name",[m
[32m+[m[32m    help="Exclude specified package from the output",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32mno_python_version_warning: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--no-python-version-warning",[m
[32m+[m[32m    dest="no_python_version_warning",[m
[32m+[m[32m    action="store_true",[m
[32m+[m[32m    default=False,[m
[32m+[m[32m    help="Silence deprecation warnings for upcoming unsupported Pythons.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32m# Features that are now always on. A warning is printed if they are used.[m
[32m+[m[32mALWAYS_ENABLED_FEATURES = [[m
[32m+[m[32m    "no-binary-enable-wheel-cache",  # always on since 23.1[m
[32m+[m[32m][m
[32m+[m
[32m+[m[32muse_new_feature: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--use-feature",[m
[32m+[m[32m    dest="features_enabled",[m
[32m+[m[32m    metavar="feature",[m
[32m+[m[32m    action="append",[m
[32m+[m[32m    default=[],[m
[32m+[m[32m    choices=[[m
[32m+[m[32m        "fast-deps",[m
[32m+[m[32m        "truststore",[m
[32m+[m[32m    ][m
[32m+[m[32m    + ALWAYS_ENABLED_FEATURES,[m
[32m+[m[32m    help="Enable new functionality, that may be backward incompatible.",[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32muse_deprecated_feature: Callable[..., Option] = partial([m
[32m+[m[32m    Option,[m
[32m+[m[32m    "--use-deprecated",[m
[32m+[m[32m    dest="deprecated_features_enabled",[m
[32m+[m[32m    metavar="feature",[m
[32m+[m[32m    action="append",[m
[32m+[m[32m    default=[],[m
[32m+[m[32m    choices=[[m
[32m+[m[32m        "legacy-resolver",[m
[32m+[m[32m    ],[m
[32m+[m[32m    help=("Enable deprecated functionality, that will be removed in the future."),[m
[32m+[m[32m)[m
[32m+[m
[32m+[m
[32m+[m[32m##########[m
[32m+[m[32m# groups #[m
[32m+[m[32m##########[m
[32m+[m
[32m+[m[32mgeneral_group: Dict[str, Any] = {[m
[32m+[m[32m    "name": "General Options",[m
[32m+[m[32m    "options": [[m
[32m+[m[32m        help_,[m
[32m+[m[32m        debug_mode,[m
[32m+[m[32m        isolated_mode,[m
[32m+[m[32m        require_virtualenv,[m
[32m+[m[32m        python,[m
[32m+[m[32m        verbose,[m
[32m+[m[32m        version,[m
[32m+[m[32m        quiet,[m
[32m+[m[32m        log,[m
[32m+[m[32m        no_input,[m
[32m+[m[32m        keyring_provider,[m
[32m+[m[32m        proxy,[m
[32m+[m[32m        retries,[m
[32m+[m[32m        timeout,[m
[32m+[m[32m        exists_action,[m
[32m+[m[32m        trusted_host,[m
[32m+[m[32m        cert,[m
[32m+[m[32m        client_cert,[m
[32m+[m[32m        cache_dir,[m
[32m+[m[32m        no_cache,[m
[32m+[m[32m        disable_pip_version_check,[m
[32m+[m[32m        no_color,[m
[32m+[m[32m        no_python_version_warning,[m
[32m+[m[32m        use_new_feature,[m
[32m+[m[32m        use_deprecated_feature,[m
[32m+[m[32m    ],[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mindex_group: Dict[str, Any] = {[m
[32m+[m[32m    "name": "Package Index Options",[m
[32m+[m[32m    "options": [[m
[32m+[m[32m        index_url,[m
[32m+[m[32m        extra_index_url,[m
[32m+[m[32m        no_index,[m
[32m+[m[32m        find_links,[m
[32m+[m[32m    ],[m
[32m+[m[32m}[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/command_context.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/command_context.py[m
[1mnew file mode 100644[m
[1mindex 0000000..139995a[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/command_context.py[m
[36m@@ -0,0 +1,27 @@[m
[32m+[m[32mfrom contextlib import ExitStack, contextmanager[m
[32m+[m[32mfrom typing import ContextManager, Generator, TypeVar[m
[32m+[m
[32m+[m[32m_T = TypeVar("_T", covariant=True)[m
[32m+[m
[32m+[m
[32m+[m[32mclass CommandContextMixIn:[m
[32m+[m[32m    def __init__(self) -> None:[m
[32m+[m[32m        super().__init__()[m
[32m+[m[32m        self._in_main_context = False[m
[32m+[m[32m        self._main_context = ExitStack()[m
[32m+[m
[32m+[m[32m    @contextmanager[m
[32m+[m[32m    def main_context(self) -> Generator[None, None, None]:[m
[32m+[m[32m        assert not self._in_main_context[m
[32m+[m
[32m+[m[32m        self._in_main_context = True[m
[32m+[m[32m        try:[m
[32m+[m[32m            with self._main_context:[m
[32m+[m[32m                yield[m
[32m+[m[32m        finally:[m
[32m+[m[32m            self._in_main_context = False[m
[32m+[m
[32m+[m[32m    def enter_context(self, context_provider: ContextManager[_T]) -> _T:[m
[32m+[m[32m        assert self._in_main_context[m
[32m+[m
[32m+[m[32m        return self._main_context.enter_context(context_provider)[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/main.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/main.py[m
[1mnew file mode 100644[m
[1mindex 0000000..7e061f5[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/main.py[m
[36m@@ -0,0 +1,79 @@[m
[32m+[m[32m"""Primary application entrypoint.[m
[32m+[m[32m"""[m
[32m+[m[32mimport locale[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport os[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport warnings[m
[32m+[m[32mfrom typing import List, Optional[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli.autocompletion import autocomplete[m
[32m+[m[32mfrom pip._internal.cli.main_parser import parse_command[m
[32m+[m[32mfrom pip._internal.commands import create_command[m
[32m+[m[32mfrom pip._internal.exceptions import PipError[m
[32m+[m[32mfrom pip._internal.utils import deprecation[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32m# Do not import and use main() directly! Using it directly is actively[m
[32m+[m[32m# discouraged by pip's maintainers. The name, location and behavior of[m
[32m+[m[32m# this function is subject to change, so calling it directly is not[m
[32m+[m[32m# portable across different pip versions.[m
[32m+[m
[32m+[m[32m# In addition, running pip in-process is unsupported and unsafe. This is[m
[32m+[m[32m# elaborated in detail at[m
[32m+[m[32m# https://pip.pypa.io/en/stable/user_guide/#using-pip-from-your-program.[m
[32m+[m[32m# That document also provides suggestions that should work for nearly[m
[32m+[m[32m# all users that are considering importing and using main() directly.[m
[32m+[m
[32m+[m[32m# However, we know that certain users will still want to invoke pip[m
[32m+[m[32m# in-process. If you understand and accept the implications of using pip[m
[32m+[m[32m# in an unsupported manner, the best approach is to use runpy to avoid[m
[32m+[m[32m# depending on the exact location of this entry point.[m
[32m+[m
[32m+[m[32m# The following example shows how to use runpy to invoke pip in that[m
[32m+[m[32m# case:[m
[32m+[m[32m#[m
[32m+[m[32m#     sys.argv = ["pip", your, args, here][m
[32m+[m[32m#     runpy.run_module("pip", run_name="__main__")[m
[32m+[m[32m#[m
[32m+[m[32m# Note that this will exit the process after running, unlike a direct[m
[32m+[m[32m# call to main. As it is not safe to do any processing after calling[m
[32m+[m[32m# main, this should not be an issue in practice.[m
[32m+[m
[32m+[m
[32m+[m[32mdef main(args: Optional[List[str]] = None) -> int:[m
[32m+[m[32m    if args is None:[m
[32m+[m[32m        args = sys.argv[1:][m
[32m+[m
[32m+[m[32m    # Suppress the pkg_resources deprecation warning[m
[32m+[m[32m    # Note - we use a module of .*pkg_resources to cover[m
[32m+[m[32m    # the normal case (pip._vendor.pkg_resources) and the[m
[32m+[m[32m    # devendored case (a bare pkg_resources)[m
[32m+[m[32m    warnings.filterwarnings([m
[32m+[m[32m        action="ignore", category=DeprecationWarning, module=".*pkg_resources"[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m[32m    # Configure our deprecation warnings to be sent through loggers[m
[32m+[m[32m    deprecation.install_warning_logger()[m
[32m+[m
[32m+[m[32m    autocomplete()[m
[32m+[m
[32m+[m[32m    try:[m
[32m+[m[32m        cmd_name, cmd_args = parse_command(args)[m
[32m+[m[32m    except PipError as exc:[m
[32m+[m[32m        sys.stderr.write(f"ERROR: {exc}")[m
[32m+[m[32m        sys.stderr.write(os.linesep)[m
[32m+[m[32m        sys.exit(1)[m
[32m+[m
[32m+[m[32m    # Needed for locale.getpreferredencoding(False) to work[m
[32m+[m[32m    # in pip._internal.utils.encoding.auto_decode[m
[32m+[m[32m    try:[m
[32m+[m[32m        locale.setlocale(locale.LC_ALL, "")[m
[32m+[m[32m    except locale.Error as e:[m
[32m+[m[32m        # setlocale can apparently crash if locale are uninitialized[m
[32m+[m[32m        logger.debug("Ignoring error %s when setting locale", e)[m
[32m+[m[32m    command = create_command(cmd_name, isolated=("--isolated" in cmd_args))[m
[32m+[m
[32m+[m[32m    return command.main(cmd_args)[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/main_parser.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/main_parser.py[m
[1mnew file mode 100644[m
[1mindex 0000000..5ade356[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/main_parser.py[m
[36m@@ -0,0 +1,134 @@[m
[32m+[m[32m"""A single place for constructing and exposing the main parser[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mimport os[m
[32m+[m[32mimport subprocess[m
[32m+[m[32mimport sys[m
[32m+[m[32mfrom typing import List, Optional, Tuple[m
[32m+[m
[32m+[m[32mfrom pip._internal.build_env import get_runnable_pip[m
[32m+[m[32mfrom pip._internal.cli import cmdoptions[m
[32m+[m[32mfrom pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter[m
[32m+[m[32mfrom pip._internal.commands import commands_dict, get_similar_commands[m
[32m+[m[32mfrom pip._internal.exceptions import CommandError[m
[32m+[m[32mfrom pip._internal.utils.misc import get_pip_version, get_prog[m
[32m+[m
[32m+[m[32m__all__ = ["create_main_parser", "parse_command"][m
[32m+[m
[32m+[m
[32m+[m[32mdef create_main_parser() -> ConfigOptionParser:[m
[32m+[m[32m    """Creates and returns the main parser for pip's CLI"""[m
[32m+[m
[32m+[m[32m    parser = ConfigOptionParser([m
[32m+[m[32m        usage="\n%prog <command> [options]",[m
[32m+[m[32m        add_help_option=False,[m
[32m+[m[32m        formatter=UpdatingDefaultsHelpFormatter(),[m
[32m+[m[32m        name="global",[m
[32m+[m[32m        prog=get_prog(),[m
[32m+[m[32m    )[m
[32m+[m[32m    parser.disable_interspersed_args()[m
[32m+[m
[32m+[m[32m    parser.version = get_pip_version()[m
[32m+[m
[32m+[m[32m    # add the general options[m
[32m+[m[32m    gen_opts = cmdoptions.make_option_group(cmdoptions.general_group, parser)[m
[32m+[m[32m    parser.add_option_group(gen_opts)[m
[32m+[m
[32m+[m[32m    # so the help formatter knows[m
[32m+[m[32m    parser.main = True  # type: ignore[m
[32m+[m
[32m+[m[32m    # create command listing for description[m
[32m+[m[32m    description = [""] + [[m
[32m+[m[32m        f"{name:27} {command_info.summary}"[m
[32m+[m[32m        for name, command_info in commands_dict.items()[m
[32m+[m[32m    ][m
[32m+[m[32m    parser.description = "\n".join(description)[m
[32m+[m
[32m+[m[32m    return parser[m
[32m+[m
[32m+[m
[32m+[m[32mdef identify_python_interpreter(python: str) -> Optional[str]:[m
[32m+[m[32m    # If the named file exists, use it.[m
[32m+[m[32m    # If it's a directory, assume it's a virtual environment and[m
[32m+[m[32m    # look for the environment's Python executable.[m
[32m+[m[32m    if os.path.exists(python):[m
[32m+[m[32m        if os.path.isdir(python):[m
[32m+[m[32m            # bin/python for Unix, Scripts/python.exe for Windows[m
[32m+[m[32m            # Try both in case of odd cases like cygwin.[m
[32m+[m[32m            for exe in ("bin/python", "Scripts/python.exe"):[m
[32m+[m[32m                py = os.path.join(python, exe)[m
[32m+[m[32m                if os.path.exists(py):[m
[32m+[m[32m                    return py[m
[32m+[m[32m        else:[m
[32m+[m[32m            return python[m
[32m+[m
[32m+[m[32m    # Could not find the interpreter specified[m
[32m+[m[32m    return None[m
[32m+[m
[32m+[m
[32m+[m[32mdef parse_command(args: List[str]) -> Tuple[str, List[str]]:[m
[32m+[m[32m    parser = create_main_parser()[m
[32m+[m
[32m+[m[32m    # Note: parser calls disable_interspersed_args(), so the result of this[m
[32m+[m[32m    # call is to split the initial args into the general options before the[m
[32m+[m[32m    # subcommand and everything else.[m
[32m+[m[32m    # For example:[m
[32m+[m[32m    #  args: ['--timeout=5', 'install', '--user', 'INITools'][m
[32m+[m[32m    #  general_options: ['--timeout==5'][m
[32m+[m[32m    #  args_else: ['install', '--user', 'INITools'][m
[32m+[m[32m    general_options, args_else = parser.parse_args(args)[m
[32m+[m
[32m+[m[32m    # --python[m
[32m+[m[32m    if general_options.python and "_PIP_RUNNING_IN_SUBPROCESS" not in os.environ:[m
[32m+[m[32m        # Re-invoke pip using the specified Python interpreter[m
[32m+[m[32m        interpreter = identify_python_interpreter(general_options.python)[m
[32m+[m[32m        if interpreter is None:[m
[32m+[m[32m            raise CommandError([m
[32m+[m[32m                f"Could not locate Python interpreter {general_options.python}"[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        pip_cmd = [[m
[32m+[m[32m            interpreter,[m
[32m+[m[32m            get_runnable_pip(),[m
[32m+[m[32m        ][m
[32m+[m[32m        pip_cmd.extend(args)[m
[32m+[m
[32m+[m[32m        # Set a flag so the child doesn't re-invoke itself, causing[m
[32m+[m[32m        # an infinite loop.[m
[32m+[m[32m        os.environ["_PIP_RUNNING_IN_SUBPROCESS"] = "1"[m
[32m+[m[32m        returncode = 0[m
[32m+[m[32m        try:[m
[32m+[m[32m            proc = subprocess.run(pip_cmd)[m
[32m+[m[32m            returncode = proc.returncode[m
[32m+[m[32m        except (subprocess.SubprocessError, OSError) as exc:[m
[32m+[m[32m            raise CommandError(f"Failed to run pip under {interpreter}: {exc}")[m
[32m+[m[32m        sys.exit(returncode)[m
[32m+[m
[32m+[m[32m    # --version[m
[32m+[m[32m    if general_options.version:[m
[32m+[m[32m        sys.stdout.write(parser.version)[m
[32m+[m[32m        sys.stdout.write(os.linesep)[m
[32m+[m[32m        sys.exit()[m
[32m+[m
[32m+[m[32m    # pip || pip help -> print_help()[m
[32m+[m[32m    if not args_else or (args_else[0] == "help" and len(args_else) == 1):[m
[32m+[m[32m        parser.print_help()[m
[32m+[m[32m        sys.exit()[m
[32m+[m
[32m+[m[32m    # the subcommand name[m
[32m+[m[32m    cmd_name = args_else[0][m
[32m+[m
[32m+[m[32m    if cmd_name not in commands_dict:[m
[32m+[m[32m        guess = get_similar_commands(cmd_name)[m
[32m+[m
[32m+[m[32m        msg = [f'unknown command "{cmd_name}"'][m
[32m+[m[32m        if guess:[m
[32m+[m[32m            msg.append(f'maybe you meant "{guess}"')[m
[32m+[m
[32m+[m[32m        raise CommandError(" - ".join(msg))[m
[32m+[m
[32m+[m[32m    # all the args without the subcommand[m
[32m+[m[32m    cmd_args = args[:][m
[32m+[m[32m    cmd_args.remove(cmd_name)[m
[32m+[m
[32m+[m[32m    return cmd_name, cmd_args[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/parser.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/parser.py[m
[1mnew file mode 100644[m
[1mindex 0000000..ae554b2[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/parser.py[m
[36m@@ -0,0 +1,294 @@[m
[32m+[m[32m"""Base option parser setup"""[m
[32m+[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport optparse[m
[32m+[m[32mimport shutil[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport textwrap[m
[32m+[m[32mfrom contextlib import suppress[m
[32m+[m[32mfrom typing import Any, Dict, Generator, List, Tuple[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli.status_codes import UNKNOWN_ERROR[m
[32m+[m[32mfrom pip._internal.configuration import Configuration, ConfigurationError[m
[32m+[m[32mfrom pip._internal.utils.misc import redact_auth_from_url, strtobool[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass PrettyHelpFormatter(optparse.IndentedHelpFormatter):[m
[32m+[m[32m    """A prettier/less verbose help formatter for optparse."""[m
[32m+[m
[32m+[m[32m    def __init__(self, *args: Any, **kwargs: Any) -> None:[m
[32m+[m[32m        # help position must be aligned with __init__.parseopts.description[m
[32m+[m[32m        kwargs["max_help_position"] = 30[m
[32m+[m[32m        kwargs["indent_increment"] = 1[m
[32m+[m[32m        kwargs["width"] = shutil.get_terminal_size()[0] - 2[m
[32m+[m[32m        super().__init__(*args, **kwargs)[m
[32m+[m
[32m+[m[32m    def format_option_strings(self, option: optparse.Option) -> str:[m
[32m+[m[32m        return self._format_option_strings(option)[m
[32m+[m
[32m+[m[32m    def _format_option_strings([m
[32m+[m[32m        self, option: optparse.Option, mvarfmt: str = " <{}>", optsep: str = ", "[m
[32m+[m[32m    ) -> str:[m
[32m+[m[32m        """[m
[32m+[m[32m        Return a comma-separated list of option strings and metavars.[m
[32m+[m
[32m+[m[32m        :param option:  tuple of (short opt, long opt), e.g: ('-f', '--format')[m
[32m+[m[32m        :param mvarfmt: metavar format string[m
[32m+[m[32m        :param optsep:  separator[m
[32m+[m[32m        """[m
[32m+[m[32m        opts = [][m
[32m+[m
[32m+[m[32m        if option._short_opts:[m
[32m+[m[32m            opts.append(option._short_opts[0])[m
[32m+[m[32m        if option._long_opts:[m
[32m+[m[32m            opts.append(option._long_opts[0])[m
[32m+[m[32m        if len(opts) > 1:[m
[32m+[m[32m            opts.insert(1, optsep)[m
[32m+[m
[32m+[m[32m        if option.takes_value():[m
[32m+[m[32m            assert option.dest is not None[m
[32m+[m[32m            metavar = option.metavar or option.dest.lower()[m
[32m+[m[32m            opts.append(mvarfmt.format(metavar.lower()))[m
[32m+[m
[32m+[m[32m        return "".join(opts)[m
[32m+[m
[32m+[m[32m    def format_heading(self, heading: str) -> str:[m
[32m+[m[32m        if heading == "Options":[m
[32m+[m[32m            return ""[m
[32m+[m[32m        return heading + ":\n"[m
[32m+[m
[32m+[m[32m    def format_usage(self, usage: str) -> str:[m
[32m+[m[32m        """[m
[32m+[m[32m        Ensure there is only one newline between usage and the first heading[m
[32m+[m[32m        if there is no description.[m
[32m+[m[32m        """[m
[32m+[m[32m        msg = "\nUsage: {}\n".format(self.indent_lines(textwrap.dedent(usage), "  "))[m
[32m+[m[32m        return msg[m
[32m+[m
[32m+[m[32m    def format_description(self, description: str) -> str:[m
[32m+[m[32m        # leave full control over description to us[m
[32m+[m[32m        if description:[m
[32m+[m[32m            if hasattr(self.parser, "main"):[m
[32m+[m[32m                label = "Commands"[m
[32m+[m[32m            else:[m
[32m+[m[32m                label = "Description"[m
[32m+[m[32m            # some doc strings have initial newlines, some don't[m
[32m+[m[32m            description = description.lstrip("\n")[m
[32m+[m[32m            # some doc strings have final newlines and spaces, some don't[m
[32m+[m[32m            description = description.rstrip()[m
[32m+[m[32m            # dedent, then reindent[m
[32m+[m[32m            description = self.indent_lines(textwrap.dedent(description), "  ")[m
[32m+[m[32m            description = f"{label}:\n{description}\n"[m
[32m+[m[32m            return description[m
[32m+[m[32m        else:[m
[32m+[m[32m            return ""[m
[32m+[m
[32m+[m[32m    def format_epilog(self, epilog: str) -> str:[m
[32m+[m[32m        # leave full control over epilog to us[m
[32m+[m[32m        if epilog:[m
[32m+[m[32m            return epilog[m
[32m+[m[32m        else:[m
[32m+[m[32m            return ""[m
[32m+[m
[32m+[m[32m    def indent_lines(self, text: str, indent: str) -> str:[m
[32m+[m[32m        new_lines = [indent + line for line in text.split("\n")][m
[32m+[m[32m        return "\n".join(new_lines)[m
[32m+[m
[32m+[m
[32m+[m[32mclass UpdatingDefaultsHelpFormatter(PrettyHelpFormatter):[m
[32m+[m[32m    """Custom help formatter for use in ConfigOptionParser.[m
[32m+[m
[32m+[m[32m    This is updates the defaults before expanding them, allowing[m
[32m+[m[32m    them to show up correctly in the help listing.[m
[32m+[m
[32m+[m[32m    Also redact auth from url type options[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def expand_default(self, option: optparse.Option) -> str:[m
[32m+[m[32m        default_values = None[m
[32m+[m[32m        if self.parser is not None:[m
[32m+[m[32m            assert isinstance(self.parser, ConfigOptionParser)[m
[32m+[m[32m            self.parser._update_defaults(self.parser.defaults)[m
[32m+[m[32m            assert option.dest is not None[m
[32m+[m[32m            default_values = self.parser.defaults.get(option.dest)[m
[32m+[m[32m        help_text = super().expand_default(option)[m
[32m+[m
[32m+[m[32m        if default_values and option.metavar == "URL":[m
[32m+[m[32m            if isinstance(default_values, str):[m
[32m+[m[32m                default_values = [default_values][m
[32m+[m
[32m+[m[32m            # If its not a list, we should abort and just return the help text[m
[32m+[m[32m            if not isinstance(default_values, list):[m
[32m+[m[32m                default_values = [][m
[32m+[m
[32m+[m[32m            for val in default_values:[m
[32m+[m[32m                help_text = help_text.replace(val, redact_auth_from_url(val))[m
[32m+[m
[32m+[m[32m        return help_text[m
[32m+[m
[32m+[m
[32m+[m[32mclass CustomOptionParser(optparse.OptionParser):[m
[32m+[m[32m    def insert_option_group([m
[32m+[m[32m        self, idx: int, *args: Any, **kwargs: Any[m
[32m+[m[32m    ) -> optparse.OptionGroup:[m
[32m+[m[32m        """Insert an OptionGroup at a given position."""[m
[32m+[m[32m        group = self.add_option_group(*args, **kwargs)[m
[32m+[m
[32m+[m[32m        self.option_groups.pop()[m
[32m+[m[32m        self.option_groups.insert(idx, group)[m
[32m+[m
[32m+[m[32m        return group[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def option_list_all(self) -> List[optparse.Option]:[m
[32m+[m[32m        """Get a list of all options, including those in option groups."""[m
[32m+[m[32m        res = self.option_list[:][m
[32m+[m[32m        for i in self.option_groups:[m
[32m+[m[32m            res.extend(i.option_list)[m
[32m+[m
[32m+[m[32m        return res[m
[32m+[m
[32m+[m
[32m+[m[32mclass ConfigOptionParser(CustomOptionParser):[m
[32m+[m[32m    """Custom option parser which updates its defaults by checking the[m
[32m+[m[32m    configuration files and environmental variables"""[m
[32m+[m
[32m+[m[32m    def __init__([m
[32m+[m[32m        self,[m
[32m+[m[32m        *args: Any,[m
[32m+[m[32m        name: str,[m
[32m+[m[32m        isolated: bool = False,[m
[32m+[m[32m        **kwargs: Any,[m
[32m+[m[32m    ) -> None:[m
[32m+[m[32m        self.name = name[m
[32m+[m[32m        self.config = Configuration(isolated)[m
[32m+[m
[32m+[m[32m        assert self.name[m
[32m+[m[32m        super().__init__(*args, **kwargs)[m
[32m+[m
[32m+[m[32m    def check_default(self, option: optparse.Option, key: str, val: Any) -> Any:[m
[32m+[m[32m        try:[m
[32m+[m[32m            return option.check_value(key, val)[m
[32m+[m[32m        except optparse.OptionValueError as exc:[m
[32m+[m[32m            print(f"An error occurred during configuration: {exc}")[m
[32m+[m[32m            sys.exit(3)[m
[32m+[m
[32m+[m[32m    def _get_ordered_configuration_items([m
[32m+[m[32m        self,[m
[32m+[m[32m    ) -> Generator[Tuple[str, Any], None, None]:[m
[32m+[m[32m        # Configuration gives keys in an unordered manner. Order them.[m
[32m+[m[32m        override_order = ["global", self.name, ":env:"][m
[32m+[m
[32m+[m[32m        # Pool the options into different groups[m
[32m+[m[32m        section_items: Dict[str, List[Tuple[str, Any]]] = {[m
[32m+[m[32m            name: [] for name in override_order[m
[32m+[m[32m        }[m
[32m+[m[32m        for section_key, val in self.config.items():[m
[32m+[m[32m            # ignore empty values[m
[32m+[m[32m            if not val:[m
[32m+[m[32m                logger.debug([m
[32m+[m[32m                    "Ignoring configuration key '%s' as it's value is empty.",[m
[32m+[m[32m                    section_key,[m
[32m+[m[32m                )[m
[32m+[m[32m                continue[m
[32m+[m
[32m+[m[32m            section, key = section_key.split(".", 1)[m
[32m+[m[32m            if section in override_order:[m
[32m+[m[32m                section_items[section].append((key, val))[m
[32m+[m
[32m+[m[32m        # Yield each group in their override order[m
[32m+[m[32m        for section in override_order:[m
[32m+[m[32m            for key, val in section_items[section]:[m
[32m+[m[32m                yield key, val[m
[32m+[m
[32m+[m[32m    def _update_defaults(self, defaults: Dict[str, Any]) -> Dict[str, Any]:[m
[32m+[m[32m        """Updates the given defaults with values from the config files and[m
[32m+[m[32m        the environ. Does a little special handling for certain types of[m
[32m+[m[32m        options (lists)."""[m
[32m+[m
[32m+[m[32m        # Accumulate complex default state.[m
[32m+[m[32m        self.values = optparse.Values(self.defaults)[m
[32m+[m[32m        late_eval = set()[m
[32m+[m[32m        # Then set the options with those values[m
[32m+[m[32m        for key, val in self._get_ordered_configuration_items():[m
[32m+[m[32m            # '--' because configuration supports only long names[m
[32m+[m[32m            option = self.get_option("--" + key)[m
[32m+[m
[32m+[m[32m            # Ignore options not present in this parser. E.g. non-globals put[m
[32m+[m[32m            # in [global] by users that want them to apply to all applicable[m
[32m+[m[32m            # commands.[m
[32m+[m[32m            if option is None:[m
[32m+[m[32m                continue[m
[32m+[m
[32m+[m[32m            assert option.dest is not None[m
[32m+[m
[32m+[m[32m            if option.action in ("store_true", "store_false"):[m
[32m+[m[32m                try:[m
[32m+[m[32m                    val = strtobool(val)[m
[32m+[m[32m                except ValueError:[m
[32m+[m[32m                    self.error([m
[32m+[m[32m                        f"{val} is not a valid value for {key} option, "[m
[32m+[m[32m                        "please specify a boolean value like yes/no, "[m
[32m+[m[32m                        "true/false or 1/0 instead."[m
[32m+[m[32m                    )[m
[32m+[m[32m            elif option.action == "count":[m
[32m+[m[32m                with suppress(ValueError):[m
[32m+[m[32m                    val = strtobool(val)[m
[32m+[m[32m                with suppress(ValueError):[m
[32m+[m[32m                    val = int(val)[m
[32m+[m[32m                if not isinstance(val, int) or val < 0:[m
[32m+[m[32m                    self.error([m
[32m+[m[32m                        f"{val} is not a valid value for {key} option, "[m
[32m+[m[32m                        "please instead specify either a non-negative integer "[m
[32m+[m[32m                        "or a boolean value like yes/no or false/true "[m
[32m+[m[32m                        "which is equivalent to 1/0."[m
[32m+[m[32m                    )[m
[32m+[m[32m            elif option.action == "append":[m
[32m+[m[32m                val = val.split()[m
[32m+[m[32m                val = [self.check_default(option, key, v) for v in val][m
[32m+[m[32m            elif option.action == "callback":[m
[32m+[m[32m                assert option.callback is not None[m
[32m+[m[32m                late_eval.add(option.dest)[m
[32m+[m[32m                opt_str = option.get_opt_string()[m
[32m+[m[32m                val = option.convert_value(opt_str, val)[m
[32m+[m[32m                # From take_action[m
[32m+[m[32m                args = option.callback_args or ()[m
[32m+[m[32m                kwargs = option.callback_kwargs or {}[m
[32m+[m[32m                option.callback(option, opt_str, val, self, *args, **kwargs)[m
[32m+[m[32m            else:[m
[32m+[m[32m                val = self.check_default(option, key, val)[m
[32m+[m
[32m+[m[32m            defaults[option.dest] = val[m
[32m+[m
[32m+[m[32m        for key in late_eval:[m
[32m+[m[32m            defaults[key] = getattr(self.values, key)[m
[32m+[m[32m        self.values = None[m
[32m+[m[32m        return defaults[m
[32m+[m
[32m+[m[32m    def get_default_values(self) -> optparse.Values:[m
[32m+[m[32m        """Overriding to make updating the defaults after instantiation of[m
[32m+[m[32m        the option parser possible, _update_defaults() does the dirty work."""[m
[32m+[m[32m        if not self.process_default_values:[m
[32m+[m[32m            # Old, pre-Optik 1.5 behaviour.[m
[32m+[m[32m            return optparse.Values(self.defaults)[m
[32m+[m
[32m+[m[32m        # Load the configuration, or error out in case of an error[m
[32m+[m[32m        try:[m
[32m+[m[32m            self.config.load()[m
[32m+[m[32m        except ConfigurationError as err:[m
[32m+[m[32m            self.exit(UNKNOWN_ERROR, str(err))[m
[32m+[m
[32m+[m[32m        defaults = self._update_defaults(self.defaults.copy())  # ours[m
[32m+[m[32m        for option in self._get_all_options():[m
[32m+[m[32m            assert option.dest is not None[m
[32m+[m[32m            default = defaults.get(option.dest)[m
[32m+[m[32m            if isinstance(default, str):[m
[32m+[m[32m                opt_str = option.get_opt_string()[m
[32m+[m[32m                defaults[option.dest] = option.check_value(opt_str, default)[m
[32m+[m[32m        return optparse.Values(defaults)[m
[32m+[m
[32m+[m[32m    def error(self, msg: str) -> None:[m
[32m+[m[32m        self.print_usage(sys.stderr)[m
[32m+[m[32m        self.exit(UNKNOWN_ERROR, f"{msg}\n")[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/progress_bars.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/progress_bars.py[m
[1mnew file mode 100644[m
[1mindex 0000000..0ad1403[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/progress_bars.py[m
[36m@@ -0,0 +1,68 @@[m
[32m+[m[32mimport functools[m
[32m+[m[32mfrom typing import Callable, Generator, Iterable, Iterator, Optional, Tuple[m
[32m+[m
[32m+[m[32mfrom pip._vendor.rich.progress import ([m
[32m+[m[32m    BarColumn,[m
[32m+[m[32m    DownloadColumn,[m
[32m+[m[32m    FileSizeColumn,[m
[32m+[m[32m    Progress,[m
[32m+[m[32m    ProgressColumn,[m
[32m+[m[32m    SpinnerColumn,[m
[32m+[m[32m    TextColumn,[m
[32m+[m[32m    TimeElapsedColumn,[m
[32m+[m[32m    TimeRemainingColumn,[m
[32m+[m[32m    TransferSpeedColumn,[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mfrom pip._internal.utils.logging import get_indentation[m
[32m+[m
[32m+[m[32mDownloadProgressRenderer = Callable[[Iterable[bytes]], Iterator[bytes]][m
[32m+[m
[32m+[m
[32m+[m[32mdef _rich_progress_bar([m
[32m+[m[32m    iterable: Iterable[bytes],[m
[32m+[m[32m    *,[m
[32m+[m[32m    bar_type: str,[m
[32m+[m[32m    size: int,[m
[32m+[m[32m) -> Generator[bytes, None, None]:[m
[32m+[m[32m    assert bar_type == "on", "This should only be used in the default mode."[m
[32m+[m
[32m+[m[32m    if not size:[m
[32m+[m[32m        total = float("inf")[m
[32m+[m[32m        columns: Tuple[ProgressColumn, ...] = ([m
[32m+[m[32m            TextColumn("[progress.description]{task.description}"),[m
[32m+[m[32m            SpinnerColumn("line", speed=1.5),[m
[32m+[m[32m            FileSizeColumn(),[m
[32m+[m[32m            TransferSpeedColumn(),[m
[32m+[m[32m            TimeElapsedColumn(),[m
[32m+[m[32m        )[m
[32m+[m[32m    else:[m
[32m+[m[32m        total = size[m
[32m+[m[32m        columns = ([m
[32m+[m[32m            TextColumn("[progress.description]{task.description}"),[m
[32m+[m[32m            BarColumn(),[m
[32m+[m[32m            DownloadColumn(),[m
[32m+[m[32m            TransferSpeedColumn(),[m
[32m+[m[32m            TextColumn("eta"),[m
[32m+[m[32m            TimeRemainingColumn(),[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    progress = Progress(*columns, refresh_per_second=30)[m
[32m+[m[32m    task_id = progress.add_task(" " * (get_indentation() + 2), total=total)[m
[32m+[m[32m    with progress:[m
[32m+[m[32m        for chunk in iterable:[m
[32m+[m[32m            yield chunk[m
[32m+[m[32m            progress.update(task_id, advance=len(chunk))[m
[32m+[m
[32m+[m
[32m+[m[32mdef get_download_progress_renderer([m
[32m+[m[32m    *, bar_type: str, size: Optional[int] = None[m
[32m+[m[32m) -> DownloadProgressRenderer:[m
[32m+[m[32m    """Get an object that can be used to render the download progress.[m
[32m+[m
[32m+[m[32m    Returns a callable, that takes an iterable to "wrap".[m
[32m+[m[32m    """[m
[32m+[m[32m    if bar_type == "on":[m
[32m+[m[32m        return functools.partial(_rich_progress_bar, bar_type=bar_type, size=size)[m
[32m+[m[32m    else:[m
[32m+[m[32m        return iter  # no-op, when passed an iterator[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/req_command.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/req_command.py[m
[1mnew file mode 100644[m
[1mindex 0000000..6f2f79c[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/req_command.py[m
[36m@@ -0,0 +1,505 @@[m
[32m+[m[32m"""Contains the Command base classes that depend on PipSession.[m
[32m+[m
[32m+[m[32mThe classes in this module are in a separate module so the commands not[m
[32m+[m[32mneeding download / PackageFinder capability don't unnecessarily import the[m
[32m+[m[32mPackageFinder machinery and all its vendored dependencies, etc.[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport os[m
[32m+[m[32mimport sys[m
[32m+[m[32mfrom functools import partial[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom typing import TYPE_CHECKING, Any, List, Optional, Tuple[m
[32m+[m
[32m+[m[32mfrom pip._internal.cache import WheelCache[m
[32m+[m[32mfrom pip._internal.cli import cmdoptions[m
[32m+[m[32mfrom pip._internal.cli.base_command import Command[m
[32m+[m[32mfrom pip._internal.cli.command_context import CommandContextMixIn[m
[32m+[m[32mfrom pip._internal.exceptions import CommandError, PreviousBuildDirError[m
[32m+[m[32mfrom pip._internal.index.collector import LinkCollector[m
[32m+[m[32mfrom pip._internal.index.package_finder import PackageFinder[m
[32m+[m[32mfrom pip._internal.models.selection_prefs import SelectionPreferences[m
[32m+[m[32mfrom pip._internal.models.target_python import TargetPython[m
[32m+[m[32mfrom pip._internal.network.session import PipSession[m
[32m+[m[32mfrom pip._internal.operations.build.build_tracker import BuildTracker[m
[32m+[m[32mfrom pip._internal.operations.prepare import RequirementPreparer[m
[32m+[m[32mfrom pip._internal.req.constructors import ([m
[32m+[m[32m    install_req_from_editable,[m
[32m+[m[32m    install_req_from_line,[m
[32m+[m[32m    install_req_from_parsed_requirement,[m
[32m+[m[32m    install_req_from_req_string,[m
[32m+[m[32m)[m
[32m+[m[32mfrom pip._internal.req.req_file import parse_requirements[m
[32m+[m[32mfrom pip._internal.req.req_install import InstallRequirement[m
[32m+[m[32mfrom pip._internal.resolution.base import BaseResolver[m
[32m+[m[32mfrom pip._internal.self_outdated_check import pip_self_version_check[m
[32m+[m[32mfrom pip._internal.utils.temp_dir import ([m
[32m+[m[32m    TempDirectory,[m
[32m+[m[32m    TempDirectoryTypeRegistry,[m
[32m+[m[32m    tempdir_kinds,[m
[32m+[m[32m)[m
[32m+[m[32mfrom pip._internal.utils.virtualenv import running_under_virtualenv[m
[32m+[m
[32m+[m[32mif TYPE_CHECKING:[m
[32m+[m[32m    from ssl import SSLContext[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mdef _create_truststore_ssl_context() -> Optional["SSLContext"]:[m
[32m+[m[32m    if sys.version_info < (3, 10):[m
[32m+[m[32m        raise CommandError("The truststore feature is only available for Python 3.10+")[m
[32m+[m
[32m+[m[32m    try:[m
[32m+[m[32m        import ssl[m
[32m+[m[32m    except ImportError:[m
[32m+[m[32m        logger.warning("Disabling truststore since ssl support is missing")[m
[32m+[m[32m        return None[m
[32m+[m
[32m+[m[32m    try:[m
[32m+[m[32m        from pip._vendor import truststore[m
[32m+[m[32m    except ImportError as e:[m
[32m+[m[32m        raise CommandError(f"The truststore feature is unavailable: {e}")[m
[32m+[m
[32m+[m[32m    return truststore.SSLContext(ssl.PROTOCOL_TLS_CLIENT)[m
[32m+[m
[32m+[m
[32m+[m[32mclass SessionCommandMixin(CommandContextMixIn):[m
[32m+[m
[32m+[m[32m    """[m
[32m+[m[32m    A class mixin for command classes needing _build_session().[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def __init__(self) -> None:[m
[32m+[m[32m        super().__init__()[m
[32m+[m[32m        self._session: Optional[PipSession] = None[m
[32m+[m
[32m+[m[32m    @classmethod[m
[32m+[m[32m    def _get_index_urls(cls, options: Values) -> Optional[List[str]]:[m
[32m+[m[32m        """Return a list of index urls from user-provided options."""[m
[32m+[m[32m        index_urls = [][m
[32m+[m[32m        if not getattr(options, "no_index", False):[m
[32m+[m[32m            url = getattr(options, "index_url", None)[m
[32m+[m[32m            if url:[m
[32m+[m[32m                index_urls.append(url)[m
[32m+[m[32m        urls = getattr(options, "extra_index_urls", None)[m
[32m+[m[32m        if urls:[m
[32m+[m[32m            index_urls.extend(urls)[m
[32m+[m[32m        # Return None rather than an empty list[m
[32m+[m[32m        return index_urls or None[m
[32m+[m
[32m+[m[32m    def get_default_session(self, options: Values) -> PipSession:[m
[32m+[m[32m        """Get a default-managed session."""[m
[32m+[m[32m        if self._session is None:[m
[32m+[m[32m            self._session = self.enter_context(self._build_session(options))[m
[32m+[m[32m            # there's no type annotation on requests.Session, so it's[m
[32m+[m[32m            # automatically ContextManager[Any] and self._session becomes Any,[m
[32m+[m[32m            # then https://github.com/python/mypy/issues/7696 kicks in[m
[32m+[m[32m            assert self._session is not None[m
[32m+[m[32m        return self._session[m
[32m+[m
[32m+[m[32m    def _build_session([m
[32m+[m[32m        self,[m
[32m+[m[32m        options: Values,[m
[32m+[m[32m        retries: Optional[int] = None,[m
[32m+[m[32m        timeout: Optional[int] = None,[m
[32m+[m[32m        fallback_to_certifi: bool = False,[m
[32m+[m[32m    ) -> PipSession:[m
[32m+[m[32m        cache_dir = options.cache_dir[m
[32m+[m[32m        assert not cache_dir or os.path.isabs(cache_dir)[m
[32m+[m
[32m+[m[32m        if "truststore" in options.features_enabled:[m
[32m+[m[32m            try:[m
[32m+[m[32m                ssl_context = _create_truststore_ssl_context()[m
[32m+[m[32m            except Exception:[m
[32m+[m[32m                if not fallback_to_certifi:[m
[32m+[m[32m                    raise[m
[32m+[m[32m                ssl_context = None[m
[32m+[m[32m        else:[m
[32m+[m[32m            ssl_context = None[m
[32m+[m
[32m+[m[32m        session = PipSession([m
[32m+[m[32m            cache=os.path.join(cache_dir, "http-v2") if cache_dir else None,[m
[32m+[m[32m            retries=retries if retries is not None else options.retries,[m
[32m+[m[32m            trusted_hosts=options.trusted_hosts,[m
[32m+[m[32m            index_urls=self._get_index_urls(options),[m
[32m+[m[32m            ssl_context=ssl_context,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        # Handle custom ca-bundles from the user[m
[32m+[m[32m        if options.cert:[m
[32m+[m[32m            session.verify = options.cert[m
[32m+[m
[32m+[m[32m        # Handle SSL client certificate[m
[32m+[m[32m        if options.client_cert:[m
[32m+[m[32m            session.cert = options.client_cert[m
[32m+[m
[32m+[m[32m        # Handle timeouts[m
[32m+[m[32m        if options.timeout or timeout:[m
[32m+[m[32m            session.timeout = timeout if timeout is not None else options.timeout[m
[32m+[m
[32m+[m[32m        # Handle configured proxies[m
[32m+[m[32m        if options.proxy:[m
[32m+[m[32m            session.proxies = {[m
[32m+[m[32m                "http": options.proxy,[m
[32m+[m[32m                "https": options.proxy,[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m        # Determine if we can prompt the user for authentication or not[m
[32m+[m[32m        session.auth.prompting = not options.no_input[m
[32m+[m[32m        session.auth.keyring_provider = options.keyring_provider[m
[32m+[m
[32m+[m[32m        return session[m
[32m+[m
[32m+[m
[32m+[m[32mclass IndexGroupCommand(Command, SessionCommandMixin):[m
[32m+[m
[32m+[m[32m    """[m
[32m+[m[32m    Abstract base class for commands with the index_group options.[m
[32m+[m
[32m+[m[32m    This also corresponds to the commands that permit the pip version check.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def handle_pip_version_check(self, options: Values) -> None:[m
[32m+[m[32m        """[m
[32m+[m[32m        Do the pip version check if not disabled.[m
[32m+[m
[32m+[m[32m        This overrides the default behavior of not doing the check.[m
[32m+[m[32m        """[m
[32m+[m[32m        # Make sure the index_group options are present.[m
[32m+[m[32m        assert hasattr(options, "no_index")[m
[32m+[m
[32m+[m[32m        if options.disable_pip_version_check or options.no_index:[m
[32m+[m[32m            return[m
[32m+[m
[32m+[m[32m        # Otherwise, check if we're using the latest version of pip available.[m
[32m+[m[32m        session = self._build_session([m
[32m+[m[32m            options,[m
[32m+[m[32m            retries=0,[m
[32m+[m[32m            timeout=min(5, options.timeout),[m
[32m+[m[32m            # This is set to ensure the function does not fail when truststore is[m
[32m+[m[32m            # specified in use-feature but cannot be loaded. This usually raises a[m
[32m+[m[32m            # CommandError and shows a nice user-facing error, but this function is not[m
[32m+[m[32m            # called in that try-except block.[m
[32m+[m[32m            fallback_to_certifi=True,[m
[32m+[m[32m        )[m
[32m+[m[32m        with session:[m
[32m+[m[32m            pip_self_version_check(session, options)[m
[32m+[m
[32m+[m
[32m+[m[32mKEEPABLE_TEMPDIR_TYPES = [[m
[32m+[m[32m    tempdir_kinds.BUILD_ENV,[m
[32m+[m[32m    tempdir_kinds.EPHEM_WHEEL_CACHE,[m
[32m+[m[32m    tempdir_kinds.REQ_BUILD,[m
[32m+[m[32m][m
[32m+[m
[32m+[m
[32m+[m[32mdef warn_if_run_as_root() -> None:[m
[32m+[m[32m    """Output a warning for sudo users on Unix.[m
[32m+[m
[32m+[m[32m    In a virtual environment, sudo pip still writes to virtualenv.[m
[32m+[m[32m    On Windows, users may run pip as Administrator without issues.[m
[32m+[m[32m    This warning only applies to Unix root users outside of virtualenv.[m
[32m+[m[32m    """[m
[32m+[m[32m    if running_under_virtualenv():[m
[32m+[m[32m        return[m
[32m+[m[32m    if not hasattr(os, "getuid"):[m
[32m+[m[32m        return[m
[32m+[m[32m    # On Windows, there are no "system managed" Python packages. Installing as[m
[32m+[m[32m    # Administrator via pip is the correct way of updating system environments.[m
[32m+[m[32m    #[m
[32m+[m[32m    # We choose sys.platform over utils.compat.WINDOWS here to enable Mypy platform[m
[32m+[m[32m    # checks: https://mypy.readthedocs.io/en/stable/common_issues.html[m
[32m+[m[32m    if sys.platform == "win32" or sys.platform == "cygwin":[m
[32m+[m[32m        return[m
[32m+[m
[32m+[m[32m    if os.getuid() != 0:[m
[32m+[m[32m        return[m
[32m+[m
[32m+[m[32m    logger.warning([m
[32m+[m[32m        "Running pip as the 'root' user can result in broken permissions and "[m
[32m+[m[32m        "conflicting behaviour with the system package manager. "[m
[32m+[m[32m        "It is recommended to use a virtual environment instead: "[m
[32m+[m[32m        "https://pip.pypa.io/warnings/venv"[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mdef with_cleanup(func: Any) -> Any:[m
[32m+[m[32m    """Decorator for common logic related to managing temporary[m
[32m+[m[32m    directories.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def configure_tempdir_registry(registry: TempDirectoryTypeRegistry) -> None:[m
[32m+[m[32m        for t in KEEPABLE_TEMPDIR_TYPES:[m
[32m+[m[32m            registry.set_delete(t, False)[m
[32m+[m
[32m+[m[32m    def wrapper([m
[32m+[m[32m        self: RequirementCommand, options: Values, args: List[Any][m
[32m+[m[32m    ) -> Optional[int]:[m
[32m+[m[32m        assert self.tempdir_registry is not None[m
[32m+[m[32m        if options.no_clean:[m
[32m+[m[32m            configure_tempdir_registry(self.tempdir_registry)[m
[32m+[m
[32m+[m[32m        try:[m
[32m+[m[32m            return func(self, options, args)[m
[32m+[m[32m        except PreviousBuildDirError:[m
[32m+[m[32m            # This kind of conflict can occur when the user passes an explicit[m
[32m+[m[32m            # build directory with a pre-existing folder. In that case we do[m
[32m+[m[32m            # not want to accidentally remove it.[m
[32m+[m[32m            configure_tempdir_registry(self.tempdir_registry)[m
[32m+[m[32m            raise[m
[32m+[m
[32m+[m[32m    return wrapper[m
[32m+[m
[32m+[m
[32m+[m[32mclass RequirementCommand(IndexGroupCommand):[m
[32m+[m[32m    def __init__(self, *args: Any, **kw: Any) -> None:[m
[32m+[m[32m        super().__init__(*args, **kw)[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.no_clean())[m
[32m+[m
[32m+[m[32m    @staticmethod[m
[32m+[m[32m    def determine_resolver_variant(options: Values) -> str:[m
[32m+[m[32m        """Determines which resolver should be used, based on the given options."""[m
[32m+[m[32m        if "legacy-resolver" in options.deprecated_features_enabled:[m
[32m+[m[32m            return "legacy"[m
[32m+[m
[32m+[m[32m        return "resolvelib"[m
[32m+[m
[32m+[m[32m    @classmethod[m
[32m+[m[32m    def make_requirement_preparer([m
[32m+[m[32m        cls,[m
[32m+[m[32m        temp_build_dir: TempDirectory,[m
[32m+[m[32m        options: Values,[m
[32m+[m[32m        build_tracker: BuildTracker,[m
[32m+[m[32m        session: PipSession,[m
[32m+[m[32m        finder: PackageFinder,[m
[32m+[m[32m        use_user_site: bool,[m
[32m+[m[32m        download_dir: Optional[str] = None,[m
[32m+[m[32m        verbosity: int = 0,[m
[32m+[m[32m    ) -> RequirementPreparer:[m
[32m+[m[32m        """[m
[32m+[m[32m        Create a RequirementPreparer instance for the given parameters.[m
[32m+[m[32m        """[m
[32m+[m[32m        temp_build_dir_path = temp_build_dir.path[m
[32m+[m[32m        assert temp_build_dir_path is not None[m
[32m+[m[32m        legacy_resolver = False[m
[32m+[m
[32m+[m[32m        resolver_variant = cls.determine_resolver_variant(options)[m
[32m+[m[32m        if resolver_variant == "resolvelib":[m
[32m+[m[32m            lazy_wheel = "fast-deps" in options.features_enabled[m
[32m+[m[32m            if lazy_wheel:[m
[32m+[m[32m                logger.warning([m
[32m+[m[32m                    "pip is using lazily downloaded wheels using HTTP "[m
[32m+[m[32m                    "range requests to obtain dependency information. "[m
[32m+[m[32m                    "This experimental feature is enabled through "[m
[32m+[m[32m                    "--use-feature=fast-deps and it is not ready for "[m
[32m+[m[32m                    "production."[m
[32m+[m[32m                )[m
[32m+[m[32m        else:[m
[32m+[m[32m            legacy_resolver = True[m
[32m+[m[32m            lazy_wheel = False[m
[32m+[m[32m            if "fast-deps" in options.features_enabled:[m
[32m+[m[32m                logger.warning([m
[32m+[m[32m                    "fast-deps has no effect when used with the legacy resolver."[m
[32m+[m[32m                )[m
[32m+[m
[32m+[m[32m        return RequirementPreparer([m
[32m+[m[32m            build_dir=temp_build_dir_path,[m
[32m+[m[32m            src_dir=options.src_dir,[m
[32m+[m[32m            download_dir=download_dir,[m
[32m+[m[32m            build_isolation=options.build_isolation,[m
[32m+[m[32m            check_build_deps=options.check_build_deps,[m
[32m+[m[32m            build_tracker=build_tracker,[m
[32m+[m[32m            session=session,[m
[32m+[m[32m            progress_bar=options.progress_bar,[m
[32m+[m[32m            finder=finder,[m
[32m+[m[32m            require_hashes=options.require_hashes,[m
[32m+[m[32m            use_user_site=use_user_site,[m
[32m+[m[32m            lazy_wheel=lazy_wheel,[m
[32m+[m[32m            verbosity=verbosity,[m
[32m+[m[32m            legacy_resolver=legacy_resolver,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    @classmethod[m
[32m+[m[32m    def make_resolver([m
[32m+[m[32m        cls,[m
[32m+[m[32m        preparer: RequirementPreparer,[m
[32m+[m[32m        finder: PackageFinder,[m
[32m+[m[32m        options: Values,[m
[32m+[m[32m        wheel_cache: Optional[WheelCache] = None,[m
[32m+[m[32m        use_user_site: bool = False,[m
[32m+[m[32m        ignore_installed: bool = True,[m
[32m+[m[32m        ignore_requires_python: bool = False,[m
[32m+[m[32m        force_reinstall: bool = False,[m
[32m+[m[32m        upgrade_strategy: str = "to-satisfy-only",[m
[32m+[m[32m        use_pep517: Optional[bool] = None,[m
[32m+[m[32m        py_version_info: Optional[Tuple[int, ...]] = None,[m
[32m+[m[32m    ) -> BaseResolver:[m
[32m+[m[32m        """[m
[32m+[m[32m        Create a Resolver instance for the given parameters.[m
[32m+[m[32m        """[m
[32m+[m[32m        make_install_req = partial([m
[32m+[m[32m            install_req_from_req_string,[m
[32m+[m[32m            isolated=options.isolated_mode,[m
[32m+[m[32m            use_pep517=use_pep517,[m
[32m+[m[32m        )[m
[32m+[m[32m        resolver_variant = cls.determine_resolver_variant(options)[m
[32m+[m[32m        # The long import name and duplicated invocation is needed to convince[m
[32m+[m[32m        # Mypy into correctly typechecking. Otherwise it would complain the[m
[32m+[m[32m        # "Resolver" class being redefined.[m
[32m+[m[32m        if resolver_variant == "resolvelib":[m
[32m+[m[32m            import pip._internal.resolution.resolvelib.resolver[m
[32m+[m
[32m+[m[32m            return pip._internal.resolution.resolvelib.resolver.Resolver([m
[32m+[m[32m                preparer=preparer,[m
[32m+[m[32m                finder=finder,[m
[32m+[m[32m                wheel_cache=wheel_cache,[m
[32m+[m[32m                make_install_req=make_install_req,[m
[32m+[m[32m                use_user_site=use_user_site,[m
[32m+[m[32m                ignore_dependencies=options.ignore_dependencies,[m
[32m+[m[32m                ignore_installed=ignore_installed,[m
[32m+[m[32m                ignore_requires_python=ignore_requires_python,[m
[32m+[m[32m                force_reinstall=force_reinstall,[m
[32m+[m[32m                upgrade_strategy=upgrade_strategy,[m
[32m+[m[32m                py_version_info=py_version_info,[m
[32m+[m[32m            )[m
[32m+[m[32m        import pip._internal.resolution.legacy.resolver[m
[32m+[m
[32m+[m[32m        return pip._internal.resolution.legacy.resolver.Resolver([m
[32m+[m[32m            preparer=preparer,[m
[32m+[m[32m            finder=finder,[m
[32m+[m[32m            wheel_cache=wheel_cache,[m
[32m+[m[32m            make_install_req=make_install_req,[m
[32m+[m[32m            use_user_site=use_user_site,[m
[32m+[m[32m            ignore_dependencies=options.ignore_dependencies,[m
[32m+[m[32m            ignore_installed=ignore_installed,[m
[32m+[m[32m            ignore_requires_python=ignore_requires_python,[m
[32m+[m[32m            force_reinstall=force_reinstall,[m
[32m+[m[32m            upgrade_strategy=upgrade_strategy,[m
[32m+[m[32m            py_version_info=py_version_info,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    def get_requirements([m
[32m+[m[32m        self,[m
[32m+[m[32m        args: List[str],[m
[32m+[m[32m        options: Values,[m
[32m+[m[32m        finder: PackageFinder,[m
[32m+[m[32m        session: PipSession,[m
[32m+[m[32m    ) -> List[InstallRequirement]:[m
[32m+[m[32m        """[m
[32m+[m[32m        Parse command-line arguments into the corresponding requirements.[m
[32m+[m[32m        """[m
[32m+[m[32m        requirements: List[InstallRequirement] = [][m
[32m+[m[32m        for filename in options.constraints:[m
[32m+[m[32m            for parsed_req in parse_requirements([m
[32m+[m[32m                filename,[m
[32m+[m[32m                constraint=True,[m
[32m+[m[32m                finder=finder,[m
[32m+[m[32m                options=options,[m
[32m+[m[32m                session=session,[m
[32m+[m[32m            ):[m
[32m+[m[32m                req_to_add = install_req_from_parsed_requirement([m
[32m+[m[32m                    parsed_req,[m
[32m+[m[32m                    isolated=options.isolated_mode,[m
[32m+[m[32m                    user_supplied=False,[m
[32m+[m[32m                )[m
[32m+[m[32m                requirements.append(req_to_add)[m
[32m+[m
[32m+[m[32m        for req in args:[m
[32m+[m[32m            req_to_add = install_req_from_line([m
[32m+[m[32m                req,[m
[32m+[m[32m                comes_from=None,[m
[32m+[m[32m                isolated=options.isolated_mode,[m
[32m+[m[32m                use_pep517=options.use_pep517,[m
[32m+[m[32m                user_supplied=True,[m
[32m+[m[32m                config_settings=getattr(options, "config_settings", None),[m
[32m+[m[32m            )[m
[32m+[m[32m            requirements.append(req_to_add)[m
[32m+[m
[32m+[m[32m        for req in options.editables:[m
[32m+[m[32m            req_to_add = install_req_from_editable([m
[32m+[m[32m                req,[m
[32m+[m[32m                user_supplied=True,[m
[32m+[m[32m                isolated=options.isolated_mode,[m
[32m+[m[32m                use_pep517=options.use_pep517,[m
[32m+[m[32m                config_settings=getattr(options, "config_settings", None),[m
[32m+[m[32m            )[m
[32m+[m[32m            requirements.append(req_to_add)[m
[32m+[m
[32m+[m[32m        # NOTE: options.require_hashes may be set if --require-hashes is True[m
[32m+[m[32m        for filename in options.requirements:[m
[32m+[m[32m            for parsed_req in parse_requirements([m
[32m+[m[32m                filename, finder=finder, options=options, session=session[m
[32m+[m[32m            ):[m
[32m+[m[32m                req_to_add = install_req_from_parsed_requirement([m
[32m+[m[32m                    parsed_req,[m
[32m+[m[32m                    isolated=options.isolated_mode,[m
[32m+[m[32m                    use_pep517=options.use_pep517,[m
[32m+[m[32m                    user_supplied=True,[m
[32m+[m[32m                    config_settings=parsed_req.options.get("config_settings")[m
[32m+[m[32m                    if parsed_req.options[m
[32m+[m[32m                    else None,[m
[32m+[m[32m                )[m
[32m+[m[32m                requirements.append(req_to_add)[m
[32m+[m
[32m+[m[32m        # If any requirement has hash options, enable hash checking.[m
[32m+[m[32m        if any(req.has_hash_options for req in requirements):[m
[32m+[m[32m            options.require_hashes = True[m
[32m+[m
[32m+[m[32m        if not (args or options.editables or options.requirements):[m
[32m+[m[32m            opts = {"name": self.name}[m
[32m+[m[32m            if options.find_links:[m
[32m+[m[32m                raise CommandError([m
[32m+[m[32m                    "You must give at least one requirement to {name} "[m
[32m+[m[32m                    '(maybe you meant "pip {name} {links}"?)'.format([m
[32m+[m[32m                        **dict(opts, links=" ".join(options.find_links))[m
[32m+[m[32m                    )[m
[32m+[m[32m                )[m
[32m+[m[32m            else:[m
[32m+[m[32m                raise CommandError([m
[32m+[m[32m                    "You must give at least one requirement to {name} "[m
[32m+[m[32m                    '(see "pip help {name}")'.format(**opts)[m
[32m+[m[32m                )[m
[32m+[m
[32m+[m[32m        return requirements[m
[32m+[m
[32m+[m[32m    @staticmethod[m
[32m+[m[32m    def trace_basic_info(finder: PackageFinder) -> None:[m
[32m+[m[32m        """[m
[32m+[m[32m        Trace basic information about the provided objects.[m
[32m+[m[32m        """[m
[32m+[m[32m        # Display where finder is looking for packages[m
[32m+[m[32m        search_scope = finder.search_scope[m
[32m+[m[32m        locations = search_scope.get_formatted_locations()[m
[32m+[m[32m        if locations:[m
[32m+[m[32m            logger.info(locations)[m
[32m+[m
[32m+[m[32m    def _build_package_finder([m
[32m+[m[32m        self,[m
[32m+[m[32m        options: Values,[m
[32m+[m[32m        session: PipSession,[m
[32m+[m[32m        target_python: Optional[TargetPython] = None,[m
[32m+[m[32m        ignore_requires_python: Optional[bool] = None,[m
[32m+[m[32m    ) -> PackageFinder:[m
[32m+[m[32m        """[m
[32m+[m[32m        Create a package finder appropriate to this requirement command.[m
[32m+[m
[32m+[m[32m        :param ignore_requires_python: Whether to ignore incompatible[m
[32m+[m[32m            "Requires-Python" values in links. Defaults to False.[m
[32m+[m[32m        """[m
[32m+[m[32m        link_collector = LinkCollector.create(session, options=options)[m
[32m+[m[32m        selection_prefs = SelectionPreferences([m
[32m+[m[32m            allow_yanked=True,[m
[32m+[m[32m            format_control=options.format_control,[m
[32m+[m[32m            allow_all_prereleases=options.pre,[m
[32m+[m[32m            prefer_binary=options.prefer_binary,[m
[32m+[m[32m            ignore_requires_python=ignore_requires_python,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        return PackageFinder.create([m
[32m+[m[32m            link_collector=link_collector,[m
[32m+[m[32m            selection_prefs=selection_prefs,[m
[32m+[m[32m            target_python=target_python,[m
[32m+[m[32m        )[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/spinners.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/spinners.py[m
[1mnew file mode 100644[m
[1mindex 0000000..cf2b976[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/spinners.py[m
[36m@@ -0,0 +1,159 @@[m
[32m+[m[32mimport contextlib[m
[32m+[m[32mimport itertools[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport time[m
[32m+[m[32mfrom typing import IO, Generator, Optional[m
[32m+[m
[32m+[m[32mfrom pip._internal.utils.compat import WINDOWS[m
[32m+[m[32mfrom pip._internal.utils.logging import get_indentation[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass SpinnerInterface:[m
[32m+[m[32m    def spin(self) -> None:[m
[32m+[m[32m        raise NotImplementedError()[m
[32m+[m
[32m+[m[32m    def finish(self, final_status: str) -> None:[m
[32m+[m[32m        raise NotImplementedError()[m
[32m+[m
[32m+[m
[32m+[m[32mclass InteractiveSpinner(SpinnerInterface):[m
[32m+[m[32m    def __init__([m
[32m+[m[32m        self,[m
[32m+[m[32m        message: str,[m
[32m+[m[32m        file: Optional[IO[str]] = None,[m
[32m+[m[32m        spin_chars: str = "-\\|/",[m
[32m+[m[32m        # Empirically, 8 updates/second looks nice[m
[32m+[m[32m        min_update_interval_seconds: float = 0.125,[m
[32m+[m[32m    ):[m
[32m+[m[32m        self._message = message[m
[32m+[m[32m        if file is None:[m
[32m+[m[32m            file = sys.stdout[m
[32m+[m[32m        self._file = file[m
[32m+[m[32m        self._rate_limiter = RateLimiter(min_update_interval_seconds)[m
[32m+[m[32m        self._finished = False[m
[32m+[m
[32m+[m[32m        self._spin_cycle = itertools.cycle(spin_chars)[m
[32m+[m
[32m+[m[32m        self._file.write(" " * get_indentation() + self._message + " ... ")[m
[32m+[m[32m        self._width = 0[m
[32m+[m
[32m+[m[32m    def _write(self, status: str) -> None:[m
[32m+[m[32m        assert not self._finished[m
[32m+[m[32m        # Erase what we wrote before by backspacing to the beginning, writing[m
[32m+[m[32m        # spaces to overwrite the old text, and then backspacing again[m
[32m+[m[32m        backup = "\b" * self._width[m
[32m+[m[32m        self._file.write(backup + " " * self._width + backup)[m
[32m+[m[32m        # Now we have a blank slate to add our status[m
[32m+[m[32m        self._file.write(status)[m
[32m+[m[32m        self._width = len(status)[m
[32m+[m[32m        self._file.flush()[m
[32m+[m[32m        self._rate_limiter.reset()[m
[32m+[m
[32m+[m[32m    def spin(self) -> None:[m
[32m+[m[32m        if self._finished:[m
[32m+[m[32m            return[m
[32m+[m[32m        if not self._rate_limiter.ready():[m
[32m+[m[32m            return[m
[32m+[m[32m        self._write(next(self._spin_cycle))[m
[32m+[m
[32m+[m[32m    def finish(self, final_status: str) -> None:[m
[32m+[m[32m        if self._finished:[m
[32m+[m[32m            return[m
[32m+[m[32m        self._write(final_status)[m
[32m+[m[32m        self._file.write("\n")[m
[32m+[m[32m        self._file.flush()[m
[32m+[m[32m        self._finished = True[m
[32m+[m
[32m+[m
[32m+[m[32m# Used for dumb terminals, non-interactive installs (no tty), etc.[m
[32m+[m[32m# We still print updates occasionally (once every 60 seconds by default) to[m
[32m+[m[32m# act as a keep-alive for systems like Travis-CI that take lack-of-output as[m
[32m+[m[32m# an indication that a task has frozen.[m
[32m+[m[32mclass NonInteractiveSpinner(SpinnerInterface):[m
[32m+[m[32m    def __init__(self, message: str, min_update_interval_seconds: float = 60.0) -> None:[m
[32m+[m[32m        self._message = message[m
[32m+[m[32m        self._finished = False[m
[32m+[m[32m        self._rate_limiter = RateLimiter(min_update_interval_seconds)[m
[32m+[m[32m        self._update("started")[m
[32m+[m
[32m+[m[32m    def _update(self, status: str) -> None:[m
[32m+[m[32m        assert not self._finished[m
[32m+[m[32m        self._rate_limiter.reset()[m
[32m+[m[32m        logger.info("%s: %s", self._message, status)[m
[32m+[m
[32m+[m[32m    def spin(self) -> None:[m
[32m+[m[32m        if self._finished:[m
[32m+[m[32m            return[m
[32m+[m[32m        if not self._rate_limiter.ready():[m
[32m+[m[32m            return[m
[32m+[m[32m        self._update("still running...")[m
[32m+[m
[32m+[m[32m    def finish(self, final_status: str) -> None:[m
[32m+[m[32m        if self._finished:[m
[32m+[m[32m            return[m
[32m+[m[32m        self._update(f"finished with status '{final_status}'")[m
[32m+[m[32m        self._finished = True[m
[32m+[m
[32m+[m
[32m+[m[32mclass RateLimiter:[m
[32m+[m[32m    def __init__(self, min_update_interval_seconds: float) -> None:[m
[32m+[m[32m        self._min_update_interval_seconds = min_update_interval_seconds[m
[32m+[m[32m        self._last_update: float = 0[m
[32m+[m
[32m+[m[32m    def ready(self) -> bool:[m
[32m+[m[32m        now = time.time()[m
[32m+[m[32m        delta = now - self._last_update[m
[32m+[m[32m        return delta >= self._min_update_interval_seconds[m
[32m+[m
[32m+[m[32m    def reset(self) -> None:[m
[32m+[m[32m        self._last_update = time.time()[m
[32m+[m
[32m+[m
[32m+[m[32m@contextlib.contextmanager[m
[32m+[m[32mdef open_spinner(message: str) -> Generator[SpinnerInterface, None, None]:[m
[32m+[m[32m    # Interactive spinner goes directly to sys.stdout rather than being routed[m
[32m+[m[32m    # through the logging system, but it acts like it has level INFO,[m
[32m+[m[32m    # i.e. it's only displayed if we're at level INFO or better.[m
[32m+[m[32m    # Non-interactive spinner goes through the logging system, so it is always[m
[32m+[m[32m    # in sync with logging configuration.[m
[32m+[m[32m    if sys.stdout.isatty() and logger.getEffectiveLevel() <= logging.INFO:[m
[32m+[m[32m        spinner: SpinnerInterface = InteractiveSpinner(message)[m
[32m+[m[32m    else:[m
[32m+[m[32m        spinner = NonInteractiveSpinner(message)[m
[32m+[m[32m    try:[m
[32m+[m[32m        with hidden_cursor(sys.stdout):[m
[32m+[m[32m            yield spinner[m
[32m+[m[32m    except KeyboardInterrupt:[m
[32m+[m[32m        spinner.finish("canceled")[m
[32m+[m[32m        raise[m
[32m+[m[32m    except Exception:[m
[32m+[m[32m        spinner.finish("error")[m
[32m+[m[32m        raise[m
[32m+[m[32m    else:[m
[32m+[m[32m        spinner.finish("done")[m
[32m+[m
[32m+[m
[32m+[m[32mHIDE_CURSOR = "\x1b[?25l"[m
[32m+[m[32mSHOW_CURSOR = "\x1b[?25h"[m
[32m+[m
[32m+[m
[32m+[m[32m@contextlib.contextmanager[m
[32m+[m[32mdef hidden_cursor(file: IO[str]) -> Generator[None, None, None]:[m
[32m+[m[32m    # The Windows terminal does not support the hide/show cursor ANSI codes,[m
[32m+[m[32m    # even via colorama. So don't even try.[m
[32m+[m[32m    if WINDOWS:[m
[32m+[m[32m        yield[m
[32m+[m[32m    # We don't want to clutter the output with control characters if we're[m
[32m+[m[32m    # writing to a file, or if the user is running with --quiet.[m
[32m+[m[32m    # See https://github.com/pypa/pip/issues/3418[m
[32m+[m[32m    elif not file.isatty() or logger.getEffectiveLevel() > logging.INFO:[m
[32m+[m[32m        yield[m
[32m+[m[32m    else:[m
[32m+[m[32m        file.write(HIDE_CURSOR)[m
[32m+[m[32m        try:[m
[32m+[m[32m            yield[m
[32m+[m[32m        finally:[m
[32m+[m[32m            file.write(SHOW_CURSOR)[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/status_codes.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/status_codes.py[m
[1mnew file mode 100644[m
[1mindex 0000000..5e29502[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/cli/status_codes.py[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32mSUCCESS = 0[m
[32m+[m[32mERROR = 1[m
[32m+[m[32mUNKNOWN_ERROR = 2[m
[32m+[m[32mVIRTUALENV_NOT_FOUND = 3[m
[32m+[m[32mPREVIOUS_BUILD_DIR_ERROR = 4[m
[32m+[m[32mNO_MATCHES_FOUND = 23[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/__init__.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/__init__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..858a410[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/__init__.py[m
[36m@@ -0,0 +1,132 @@[m
[32m+[m[32m"""[m
[32m+[m[32mPackage containing all pip commands[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mimport importlib[m
[32m+[m[32mfrom collections import namedtuple[m
[32m+[m[32mfrom typing import Any, Dict, Optional[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli.base_command import Command[m
[32m+[m
[32m+[m[32mCommandInfo = namedtuple("CommandInfo", "module_path, class_name, summary")[m
[32m+[m
[32m+[m[32m# This dictionary does a bunch of heavy lifting for help output:[m
[32m+[m[32m# - Enables avoiding additional (costly) imports for presenting `--help`.[m
[32m+[m[32m# - The ordering matters for help display.[m
[32m+[m[32m#[m
[32m+[m[32m# Even though the module path starts with the same "pip._internal.commands"[m
[32m+[m[32m# prefix, the full path makes testing easier (specifically when modifying[m
[32m+[m[32m# `commands_dict` in test setup / teardown).[m
[32m+[m[32mcommands_dict: Dict[str, CommandInfo] = {[m
[32m+[m[32m    "install": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.install",[m
[32m+[m[32m        "InstallCommand",[m
[32m+[m[32m        "Install packages.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "download": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.download",[m
[32m+[m[32m        "DownloadCommand",[m
[32m+[m[32m        "Download packages.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "uninstall": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.uninstall",[m
[32m+[m[32m        "UninstallCommand",[m
[32m+[m[32m        "Uninstall packages.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "freeze": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.freeze",[m
[32m+[m[32m        "FreezeCommand",[m
[32m+[m[32m        "Output installed packages in requirements format.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "inspect": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.inspect",[m
[32m+[m[32m        "InspectCommand",[m
[32m+[m[32m        "Inspect the python environment.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "list": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.list",[m
[32m+[m[32m        "ListCommand",[m
[32m+[m[32m        "List installed packages.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "show": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.show",[m
[32m+[m[32m        "ShowCommand",[m
[32m+[m[32m        "Show information about installed packages.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "check": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.check",[m
[32m+[m[32m        "CheckCommand",[m
[32m+[m[32m        "Verify installed packages have compatible dependencies.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "config": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.configuration",[m
[32m+[m[32m        "ConfigurationCommand",[m
[32m+[m[32m        "Manage local and global configuration.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "search": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.search",[m
[32m+[m[32m        "SearchCommand",[m
[32m+[m[32m        "Search PyPI for packages.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "cache": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.cache",[m
[32m+[m[32m        "CacheCommand",[m
[32m+[m[32m        "Inspect and manage pip's wheel cache.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "index": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.index",[m
[32m+[m[32m        "IndexCommand",[m
[32m+[m[32m        "Inspect information available from package indexes.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "wheel": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.wheel",[m
[32m+[m[32m        "WheelCommand",[m
[32m+[m[32m        "Build wheels from your requirements.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "hash": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.hash",[m
[32m+[m[32m        "HashCommand",[m
[32m+[m[32m        "Compute hashes of package archives.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "completion": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.completion",[m
[32m+[m[32m        "CompletionCommand",[m
[32m+[m[32m        "A helper command used for command completion.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "debug": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.debug",[m
[32m+[m[32m        "DebugCommand",[m
[32m+[m[32m        "Show information useful for debugging.",[m
[32m+[m[32m    ),[m
[32m+[m[32m    "help": CommandInfo([m
[32m+[m[32m        "pip._internal.commands.help",[m
[32m+[m[32m        "HelpCommand",[m
[32m+[m[32m        "Show help for commands.",[m
[32m+[m[32m    ),[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32mdef create_command(name: str, **kwargs: Any) -> Command:[m
[32m+[m[32m    """[m
[32m+[m[32m    Create an instance of the Command class with the given name.[m
[32m+[m[32m    """[m
[32m+[m[32m    module_path, class_name, summary = commands_dict[name][m
[32m+[m[32m    module = importlib.import_module(module_path)[m
[32m+[m[32m    command_class = getattr(module, class_name)[m
[32m+[m[32m    command = command_class(name=name, summary=summary, **kwargs)[m
[32m+[m
[32m+[m[32m    return command[m
[32m+[m
[32m+[m
[32m+[m[32mdef get_similar_commands(name: str) -> Optional[str]:[m
[32m+[m[32m    """Command name auto-correct."""[m
[32m+[m[32m    from difflib import get_close_matches[m
[32m+[m
[32m+[m[32m    name = name.lower()[m
[32m+[m
[32m+[m[32m    close_commands = get_close_matches(name, commands_dict.keys())[m
[32m+[m
[32m+[m[32m    if close_commands:[m
[32m+[m[32m        return close_commands[0][m
[32m+[m[32m    else:[m
[32m+[m[32m        return None[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/cache.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/cache.py[m
[1mnew file mode 100644[m
[1mindex 0000000..3283361[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/cache.py[m
[36m@@ -0,0 +1,225 @@[m
[32m+[m[32mimport os[m
[32m+[m[32mimport textwrap[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom typing import Any, List[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli.base_command import Command[m
[32m+[m[32mfrom pip._internal.cli.status_codes import ERROR, SUCCESS[m
[32m+[m[32mfrom pip._internal.exceptions import CommandError, PipError[m
[32m+[m[32mfrom pip._internal.utils import filesystem[m
[32m+[m[32mfrom pip._internal.utils.logging import getLogger[m
[32m+[m
[32m+[m[32mlogger = getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass CacheCommand(Command):[m
[32m+[m[32m    """[m
[32m+[m[32m    Inspect and manage pip's wheel cache.[m
[32m+[m
[32m+[m[32m    Subcommands:[m
[32m+[m
[32m+[m[32m    - dir: Show the cache directory.[m
[32m+[m[32m    - info: Show information about the cache.[m
[32m+[m[32m    - list: List filenames of packages stored in the cache.[m
[32m+[m[32m    - remove: Remove one or more package from the cache.[m
[32m+[m[32m    - purge: Remove all items from the cache.[m
[32m+[m
[32m+[m[32m    ``<pattern>`` can be a glob expression or a package name.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    ignore_require_venv = True[m
[32m+[m[32m    usage = """[m
[32m+[m[32m        %prog dir[m
[32m+[m[32m        %prog info[m
[32m+[m[32m        %prog list [<pattern>] [--format=[human, abspath]][m
[32m+[m[32m        %prog remove <pattern>[m
[32m+[m[32m        %prog purge[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def add_options(self) -> None:[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--format",[m
[32m+[m[32m            action="store",[m
[32m+[m[32m            dest="list_format",[m
[32m+[m[32m            default="human",[m
[32m+[m[32m            choices=("human", "abspath"),[m
[32m+[m[32m            help="Select the output format among: human (default) or abspath",[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.parser.insert_option_group(0, self.cmd_opts)[m
[32m+[m
[32m+[m[32m    def run(self, options: Values, args: List[str]) -> int:[m
[32m+[m[32m        handlers = {[m
[32m+[m[32m            "dir": self.get_cache_dir,[m
[32m+[m[32m            "info": self.get_cache_info,[m
[32m+[m[32m            "list": self.list_cache_items,[m
[32m+[m[32m            "remove": self.remove_cache_items,[m
[32m+[m[32m            "purge": self.purge_cache,[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if not options.cache_dir:[m
[32m+[m[32m            logger.error("pip cache commands can not function since cache is disabled.")[m
[32m+[m[32m            return ERROR[m
[32m+[m
[32m+[m[32m        # Determine action[m
[32m+[m[32m        if not args or args[0] not in handlers:[m
[32m+[m[32m            logger.error([m
[32m+[m[32m                "Need an action (%s) to perform.",[m
[32m+[m[32m                ", ".join(sorted(handlers)),[m
[32m+[m[32m            )[m
[32m+[m[32m            return ERROR[m
[32m+[m
[32m+[m[32m        action = args[0][m
[32m+[m
[32m+[m[32m        # Error handling happens here, not in the action-handlers.[m
[32m+[m[32m        try:[m
[32m+[m[32m            handlers[action](options, args[1:])[m
[32m+[m[32m        except PipError as e:[m
[32m+[m[32m            logger.error(e.args[0])[m
[32m+[m[32m            return ERROR[m
[32m+[m
[32m+[m[32m        return SUCCESS[m
[32m+[m
[32m+[m[32m    def get_cache_dir(self, options: Values, args: List[Any]) -> None:[m
[32m+[m[32m        if args:[m
[32m+[m[32m            raise CommandError("Too many arguments")[m
[32m+[m
[32m+[m[32m        logger.info(options.cache_dir)[m
[32m+[m
[32m+[m[32m    def get_cache_info(self, options: Values, args: List[Any]) -> None:[m
[32m+[m[32m        if args:[m
[32m+[m[32m            raise CommandError("Too many arguments")[m
[32m+[m
[32m+[m[32m        num_http_files = len(self._find_http_files(options))[m
[32m+[m[32m        num_packages = len(self._find_wheels(options, "*"))[m
[32m+[m
[32m+[m[32m        http_cache_location = self._cache_dir(options, "http-v2")[m
[32m+[m[32m        old_http_cache_location = self._cache_dir(options, "http")[m
[32m+[m[32m        wheels_cache_location = self._cache_dir(options, "wheels")[m
[32m+[m[32m        http_cache_size = filesystem.format_size([m
[32m+[m[32m            filesystem.directory_size(http_cache_location)[m
[32m+[m[32m            + filesystem.directory_size(old_http_cache_location)[m
[32m+[m[32m        )[m
[32m+[m[32m        wheels_cache_size = filesystem.format_directory_size(wheels_cache_location)[m
[32m+[m
[32m+[m[32m        message = ([m
[32m+[m[32m            textwrap.dedent([m
[32m+[m[32m                """[m
[32m+[m[32m                    Package index page cache location (pip v23.3+): {http_cache_location}[m
[32m+[m[32m                    Package index page cache location (older pips): {old_http_cache_location}[m
[32m+[m[32m                    Package index page cache size: {http_cache_size}[m
[32m+[m[32m                    Number of HTTP files: {num_http_files}[m
[32m+[m[32m                    Locally built wheels location: {wheels_cache_location}[m
[32m+[m[32m                    Locally built wheels size: {wheels_cache_size}[m
[32m+[m[32m                    Number of locally built wheels: {package_count}[m
[32m+[m[32m                """  # noqa: E501[m
[32m+[m[32m            )[m
[32m+[m[32m            .format([m
[32m+[m[32m                http_cache_location=http_cache_location,[m
[32m+[m[32m                old_http_cache_location=old_http_cache_location,[m
[32m+[m[32m                http_cache_size=http_cache_size,[m
[32m+[m[32m                num_http_files=num_http_files,[m
[32m+[m[32m                wheels_cache_location=wheels_cache_location,[m
[32m+[m[32m                package_count=num_packages,[m
[32m+[m[32m                wheels_cache_size=wheels_cache_size,[m
[32m+[m[32m            )[m
[32m+[m[32m            .strip()[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        logger.info(message)[m
[32m+[m
[32m+[m[32m    def list_cache_items(self, options: Values, args: List[Any]) -> None:[m
[32m+[m[32m        if len(args) > 1:[m
[32m+[m[32m            raise CommandError("Too many arguments")[m
[32m+[m
[32m+[m[32m        if args:[m
[32m+[m[32m            pattern = args[0][m
[32m+[m[32m        else:[m
[32m+[m[32m            pattern = "*"[m
[32m+[m
[32m+[m[32m        files = self._find_wheels(options, pattern)[m
[32m+[m[32m        if options.list_format == "human":[m
[32m+[m[32m            self.format_for_human(files)[m
[32m+[m[32m        else:[m
[32m+[m[32m            self.format_for_abspath(files)[m
[32m+[m
[32m+[m[32m    def format_for_human(self, files: List[str]) -> None:[m
[32m+[m[32m        if not files:[m
[32m+[m[32m            logger.info("No locally built wheels cached.")[m
[32m+[m[32m            return[m
[32m+[m
[32m+[m[32m        results = [][m
[32m+[m[32m        for filename in files:[m
[32m+[m[32m            wheel = os.path.basename(filename)[m
[32m+[m[32m            size = filesystem.format_file_size(filename)[m
[32m+[m[32m            results.append(f" - {wheel} ({size})")[m
[32m+[m[32m        logger.info("Cache contents:\n")[m
[32m+[m[32m        logger.info("\n".join(sorted(results)))[m
[32m+[m
[32m+[m[32m    def format_for_abspath(self, files: List[str]) -> None:[m
[32m+[m[32m        if files:[m
[32m+[m[32m            logger.info("\n".join(sorted(files)))[m
[32m+[m
[32m+[m[32m    def remove_cache_items(self, options: Values, args: List[Any]) -> None:[m
[32m+[m[32m        if len(args) > 1:[m
[32m+[m[32m            raise CommandError("Too many arguments")[m
[32m+[m
[32m+[m[32m        if not args:[m
[32m+[m[32m            raise CommandError("Please provide a pattern")[m
[32m+[m
[32m+[m[32m        files = self._find_wheels(options, args[0])[m
[32m+[m
[32m+[m[32m        no_matching_msg = "No matching packages"[m
[32m+[m[32m        if args[0] == "*":[m
[32m+[m[32m            # Only fetch http files if no specific pattern given[m
[32m+[m[32m            files += self._find_http_files(options)[m
[32m+[m[32m        else:[m
[32m+[m[32m            # Add the pattern to the log message[m
[32m+[m[32m            no_matching_msg += f' for pattern "{args[0]}"'[m
[32m+[m
[32m+[m[32m        if not files:[m
[32m+[m[32m            logger.warning(no_matching_msg)[m
[32m+[m
[32m+[m[32m        for filename in files:[m
[32m+[m[32m            os.unlink(filename)[m
[32m+[m[32m            logger.verbose("Removed %s", filename)[m
[32m+[m[32m        logger.info("Files removed: %s", len(files))[m
[32m+[m
[32m+[m[32m    def purge_cache(self, options: Values, args: List[Any]) -> None:[m
[32m+[m[32m        if args:[m
[32m+[m[32m            raise CommandError("Too many arguments")[m
[32m+[m
[32m+[m[32m        return self.remove_cache_items(options, ["*"])[m
[32m+[m
[32m+[m[32m    def _cache_dir(self, options: Values, subdir: str) -> str:[m
[32m+[m[32m        return os.path.join(options.cache_dir, subdir)[m
[32m+[m
[32m+[m[32m    def _find_http_files(self, options: Values) -> List[str]:[m
[32m+[m[32m        old_http_dir = self._cache_dir(options, "http")[m
[32m+[m[32m        new_http_dir = self._cache_dir(options, "http-v2")[m
[32m+[m[32m        return filesystem.find_files(old_http_dir, "*") + filesystem.find_files([m
[32m+[m[32m            new_http_dir, "*"[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    def _find_wheels(self, options: Values, pattern: str) -> List[str]:[m
[32m+[m[32m        wheel_dir = self._cache_dir(options, "wheels")[m
[32m+[m
[32m+[m[32m        # The wheel filename format, as specified in PEP 427, is:[m
[32m+[m[32m        #     {distribution}-{version}(-{build})?-{python}-{abi}-{platform}.whl[m
[32m+[m[32m        #[m
[32m+[m[32m        # Additionally, non-alphanumeric values in the distribution are[m
[32m+[m[32m        # normalized to underscores (_), meaning hyphens can never occur[m
[32m+[m[32m        # before `-{version}`.[m
[32m+[m[32m        #[m
[32m+[m[32m        # Given that information:[m
[32m+[m[32m        # - If the pattern we're given contains a hyphen (-), the user is[m
[32m+[m[32m        #   providing at least the version. Thus, we can just append `*.whl`[m
[32m+[m[32m        #   to match the rest of it.[m
[32m+[m[32m        # - If the pattern we're given doesn't contain a hyphen (-), the[m
[32m+[m[32m        #   user is only providing the name. Thus, we append `-*.whl` to[m
[32m+[m[32m        #   match the hyphen before the version, followed by anything else.[m
[32m+[m[32m        #[m
[32m+[m[32m        # PEP 427: https://www.python.org/dev/peps/pep-0427/[m
[32m+[m[32m        pattern = pattern + ("*.whl" if "-" in pattern else "-*.whl")[m
[32m+[m
[32m+[m[32m        return filesystem.find_files(wheel_dir, pattern)[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/check.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/check.py[m
[1mnew file mode 100644[m
[1mindex 0000000..5efd0a3[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/check.py[m
[36m@@ -0,0 +1,54 @@[m
[32m+[m[32mimport logging[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom typing import List[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli.base_command import Command[m
[32m+[m[32mfrom pip._internal.cli.status_codes import ERROR, SUCCESS[m
[32m+[m[32mfrom pip._internal.operations.check import ([m
[32m+[m[32m    check_package_set,[m
[32m+[m[32m    create_package_set_from_installed,[m
[32m+[m[32m    warn_legacy_versions_and_specifiers,[m
[32m+[m[32m)[m
[32m+[m[32mfrom pip._internal.utils.misc import write_output[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass CheckCommand(Command):[m
[32m+[m[32m    """Verify installed packages have compatible dependencies."""[m
[32m+[m
[32m+[m[32m    usage = """[m
[32m+[m[32m      %prog [options]"""[m
[32m+[m
[32m+[m[32m    def run(self, options: Values, args: List[str]) -> int:[m
[32m+[m[32m        package_set, parsing_probs = create_package_set_from_installed()[m
[32m+[m[32m        warn_legacy_versions_and_specifiers(package_set)[m
[32m+[m[32m        missing, conflicting = check_package_set(package_set)[m
[32m+[m
[32m+[m[32m        for project_name in missing:[m
[32m+[m[32m            version = package_set[project_name].version[m
[32m+[m[32m            for dependency in missing[project_name]:[m
[32m+[m[32m                write_output([m
[32m+[m[32m                    "%s %s requires %s, which is not installed.",[m
[32m+[m[32m                    project_name,[m
[32m+[m[32m                    version,[m
[32m+[m[32m                    dependency[0],[m
[32m+[m[32m                )[m
[32m+[m
[32m+[m[32m        for project_name in conflicting:[m
[32m+[m[32m            version = package_set[project_name].version[m
[32m+[m[32m            for dep_name, dep_version, req in conflicting[project_name]:[m
[32m+[m[32m                write_output([m
[32m+[m[32m                    "%s %s has requirement %s, but you have %s %s.",[m
[32m+[m[32m                    project_name,[m
[32m+[m[32m                    version,[m
[32m+[m[32m                    req,[m
[32m+[m[32m                    dep_name,[m
[32m+[m[32m                    dep_version,[m
[32m+[m[32m                )[m
[32m+[m
[32m+[m[32m        if missing or conflicting or parsing_probs:[m
[32m+[m[32m            return ERROR[m
[32m+[m[32m        else:[m
[32m+[m[32m            write_output("No broken requirements found.")[m
[32m+[m[32m            return SUCCESS[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/completion.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/completion.py[m
[1mnew file mode 100644[m
[1mindex 0000000..9e89e27[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/completion.py[m
[36m@@ -0,0 +1,130 @@[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport textwrap[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom typing import List[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli.base_command import Command[m
[32m+[m[32mfrom pip._internal.cli.status_codes import SUCCESS[m
[32m+[m[32mfrom pip._internal.utils.misc import get_prog[m
[32m+[m
[32m+[m[32mBASE_COMPLETION = """[m
[32m+[m[32m# pip {shell} completion start{script}# pip {shell} completion end[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mCOMPLETION_SCRIPTS = {[m
[32m+[m[32m    "bash": """[m
[32m+[m[32m        _pip_completion()[m
[32m+[m[32m        {{[m
[32m+[m[32m            COMPREPLY=( $( COMP_WORDS="${{COMP_WORDS[*]}}" \\[m
[32m+[m[32m                           COMP_CWORD=$COMP_CWORD \\[m
[32m+[m[32m                           PIP_AUTO_COMPLETE=1 $1 2>/dev/null ) )[m
[32m+[m[32m        }}[m
[32m+[m[32m        complete -o default -F _pip_completion {prog}[m
[32m+[m[32m    """,[m
[32m+[m[32m    "zsh": """[m
[32m+[m[32m        #compdef -P pip[0-9.]#[m
[32m+[m[32m        __pip() {{[m
[32m+[m[32m          compadd $( COMP_WORDS="$words[*]" \\[m
[32m+[m[32m                     COMP_CWORD=$((CURRENT-1)) \\[m
[32m+[m[32m                     PIP_AUTO_COMPLETE=1 $words[1] 2>/dev/null )[m
[32m+[m[32m        }}[m
[32m+[m[32m        if [[ $zsh_eval_context[-1] == loadautofunc ]]; then[m
[32m+[m[32m          # autoload from fpath, call function directly[m
[32m+[m[32m          __pip "$@"[m
[32m+[m[32m        else[m
[32m+[m[32m          # eval/source/. command, register function for later[m
[32m+[m[32m          compdef __pip -P 'pip[0-9.]#'[m
[32m+[m[32m        fi[m
[32m+[m[32m    """,[m
[32m+[m[32m    "fish": """[m
[32m+[m[32m        function __fish_complete_pip[m
[32m+[m[32m            set -lx COMP_WORDS (commandline -o) ""[m
[32m+[m[32m            set -lx COMP_CWORD ( \\[m
[32m+[m[32m                math (contains -i -- (commandline -t) $COMP_WORDS)-1 \\[m
[32m+[m[32m            )[m
[32m+[m[32m            set -lx PIP_AUTO_COMPLETE 1[m
[32m+[m[32m            string split \\  -- (eval $COMP_WORDS[1])[m
[32m+[m[32m        end[m
[32m+[m[32m        complete -fa "(__fish_complete_pip)" -c {prog}[m
[32m+[m[32m    """,[m
[32m+[m[32m    "powershell": """[m
[32m+[m[32m        if ((Test-Path Function:\\TabExpansion) -and -not `[m
[32m+[m[32m            (Test-Path Function:\\_pip_completeBackup)) {{[m
[32m+[m[32m            Rename-Item Function:\\TabExpansion _pip_completeBackup[m
[32m+[m[32m        }}[m
[32m+[m[32m        function TabExpansion($line, $lastWord) {{[m
[32m+[m[32m            $lastBlock = [regex]::Split($line, '[|;]')[-1].TrimStart()[m
[32m+[m[32m            if ($lastBlock.StartsWith("{prog} ")) {{[m
[32m+[m[32m                $Env:COMP_WORDS=$lastBlock[m
[32m+[m[32m                $Env:COMP_CWORD=$lastBlock.Split().Length - 1[m
[32m+[m[32m                $Env:PIP_AUTO_COMPLETE=1[m
[32m+[m[32m                (& {prog}).Split()[m
[32m+[m[32m                Remove-Item Env:COMP_WORDS[m
[32m+[m[32m                Remove-Item Env:COMP_CWORD[m
[32m+[m[32m                Remove-Item Env:PIP_AUTO_COMPLETE[m
[32m+[m[32m            }}[m
[32m+[m[32m            elseif (Test-Path Function:\\_pip_completeBackup) {{[m
[32m+[m[32m                # Fall back on existing tab expansion[m
[32m+[m[32m                _pip_completeBackup $line $lastWord[m
[32m+[m[32m            }}[m
[32m+[m[32m        }}[m
[32m+[m[32m    """,[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32mclass CompletionCommand(Command):[m
[32m+[m[32m    """A helper command to be used for command completion."""[m
[32m+[m
[32m+[m[32m    ignore_require_venv = True[m
[32m+[m
[32m+[m[32m    def add_options(self) -> None:[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--bash",[m
[32m+[m[32m            "-b",[m
[32m+[m[32m            action="store_const",[m
[32m+[m[32m            const="bash",[m
[32m+[m[32m            dest="shell",[m
[32m+[m[32m            help="Emit completion code for bash",[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--zsh",[m
[32m+[m[32m            "-z",[m
[32m+[m[32m            action="store_const",[m
[32m+[m[32m            const="zsh",[m
[32m+[m[32m            dest="shell",[m
[32m+[m[32m            help="Emit completion code for zsh",[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--fish",[m
[32m+[m[32m            "-f",[m
[32m+[m[32m            action="store_const",[m
[32m+[m[32m            const="fish",[m
[32m+[m[32m            dest="shell",[m
[32m+[m[32m            help="Emit completion code for fish",[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--powershell",[m
[32m+[m[32m            "-p",[m
[32m+[m[32m            action="store_const",[m
[32m+[m[32m            const="powershell",[m
[32m+[m[32m            dest="shell",[m
[32m+[m[32m            help="Emit completion code for powershell",[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.parser.insert_option_group(0, self.cmd_opts)[m
[32m+[m
[32m+[m[32m    def run(self, options: Values, args: List[str]) -> int:[m
[32m+[m[32m        """Prints the completion code of the given shell"""[m
[32m+[m[32m        shells = COMPLETION_SCRIPTS.keys()[m
[32m+[m[32m        shell_options = ["--" + shell for shell in sorted(shells)][m
[32m+[m[32m        if options.shell in shells:[m
[32m+[m[32m            script = textwrap.dedent([m
[32m+[m[32m                COMPLETION_SCRIPTS.get(options.shell, "").format(prog=get_prog())[m
[32m+[m[32m            )[m
[32m+[m[32m            print(BASE_COMPLETION.format(script=script, shell=options.shell))[m
[32m+[m[32m            return SUCCESS[m
[32m+[m[32m        else:[m
[32m+[m[32m            sys.stderr.write([m
[32m+[m[32m                "ERROR: You must pass {}\n".format(" or ".join(shell_options))[m
[32m+[m[32m            )[m
[32m+[m[32m            return SUCCESS[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/configuration.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/configuration.py[m
[1mnew file mode 100644[m
[1mindex 0000000..1a1dc6b[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/configuration.py[m
[36m@@ -0,0 +1,280 @@[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport os[m
[32m+[m[32mimport subprocess[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom typing import Any, List, Optional[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli.base_command import Command[m
[32m+[m[32mfrom pip._internal.cli.status_codes import ERROR, SUCCESS[m
[32m+[m[32mfrom pip._internal.configuration import ([m
[32m+[m[32m    Configuration,[m
[32m+[m[32m    Kind,[m
[32m+[m[32m    get_configuration_files,[m
[32m+[m[32m    kinds,[m
[32m+[m[32m)[m
[32m+[m[32mfrom pip._internal.exceptions import PipError[m
[32m+[m[32mfrom pip._internal.utils.logging import indent_log[m
[32m+[m[32mfrom pip._internal.utils.misc import get_prog, write_output[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass ConfigurationCommand(Command):[m
[32m+[m[32m    """[m
[32m+[m[32m    Manage local and global configuration.[m
[32m+[m
[32m+[m[32m    Subcommands:[m
[32m+[m
[32m+[m[32m    - list: List the active configuration (or from the file specified)[m
[32m+[m[32m    - edit: Edit the configuration file in an editor[m
[32m+[m[32m    - get: Get the value associated with command.option[m
[32m+[m[32m    - set: Set the command.option=value[m
[32m+[m[32m    - unset: Unset the value associated with command.option[m
[32m+[m[32m    - debug: List the configuration files and values defined under them[m
[32m+[m
[32m+[m[32m    Configuration keys should be dot separated command and option name,[m
[32m+[m[32m    with the special prefix "global" affecting any command. For example,[m
[32m+[m[32m    "pip config set global.index-url https://example.org/" would configure[m
[32m+[m[32m    the index url for all commands, but "pip config set download.timeout 10"[m
[32m+[m[32m    would configure a 10 second timeout only for "pip download" commands.[m
[32m+[m
[32m+[m[32m    If none of --user, --global and --site are passed, a virtual[m
[32m+[m[32m    environment configuration file is used if one is active and the file[m
[32m+[m[32m    exists. Otherwise, all modifications happen to the user file by[m
[32m+[m[32m    default.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    ignore_require_venv = True[m
[32m+[m[32m    usage = """[m
[32m+[m[32m        %prog [<file-option>] list[m
[32m+[m[32m        %prog [<file-option>] [--editor <editor-path>] edit[m
[32m+[m
[32m+[m[32m        %prog [<file-option>] get command.option[m
[32m+[m[32m        %prog [<file-option>] set command.option value[m
[32m+[m[32m        %prog [<file-option>] unset command.option[m
[32m+[m[32m        %prog [<file-option>] debug[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def add_options(self) -> None:[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--editor",[m
[32m+[m[32m            dest="editor",[m
[32m+[m[32m            action="store",[m
[32m+[m[32m            default=None,[m
[32m+[m[32m            help=([m
[32m+[m[32m                "Editor to use to edit the file. Uses VISUAL or EDITOR "[m
[32m+[m[32m                "environment variables if not provided."[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--global",[m
[32m+[m[32m            dest="global_file",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            default=False,[m
[32m+[m[32m            help="Use the system-wide configuration file only",[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--user",[m
[32m+[m[32m            dest="user_file",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            default=False,[m
[32m+[m[32m            help="Use the user configuration file only",[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--site",[m
[32m+[m[32m            dest="site_file",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            default=False,[m
[32m+[m[32m            help="Use the current environment configuration file only",[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.parser.insert_option_group(0, self.cmd_opts)[m
[32m+[m
[32m+[m[32m    def run(self, options: Values, args: List[str]) -> int:[m
[32m+[m[32m        handlers = {[m
[32m+[m[32m            "list": self.list_values,[m
[32m+[m[32m            "edit": self.open_in_editor,[m
[32m+[m[32m            "get": self.get_name,[m
[32m+[m[32m            "set": self.set_name_value,[m
[32m+[m[32m            "unset": self.unset_name,[m
[32m+[m[32m            "debug": self.list_config_values,[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        # Determine action[m
[32m+[m[32m        if not args or args[0] not in handlers:[m
[32m+[m[32m            logger.error([m
[32m+[m[32m                "Need an action (%s) to perform.",[m
[32m+[m[32m                ", ".join(sorted(handlers)),[m
[32m+[m[32m            )[m
[32m+[m[32m            return ERROR[m
[32m+[m
[32m+[m[32m        action = args[0][m
[32m+[m
[32m+[m[32m        # Determine which configuration files are to be loaded[m
[32m+[m[32m        #    Depends on whether the command is modifying.[m
[32m+[m[32m        try:[m
[32m+[m[32m            load_only = self._determine_file([m
[32m+[m[32m                options, need_value=(action in ["get", "set", "unset", "edit"])[m
[32m+[m[32m            )[m
[32m+[m[32m        except PipError as e:[m
[32m+[m[32m            logger.error(e.args[0])[m
[32m+[m[32m            return ERROR[m
[32m+[m
[32m+[m[32m        # Load a new configuration[m
[32m+[m[32m        self.configuration = Configuration([m
[32m+[m[32m            isolated=options.isolated_mode, load_only=load_only[m
[32m+[m[32m        )[m
[32m+[m[32m        self.configuration.load()[m
[32m+[m
[32m+[m[32m        # Error handling happens here, not in the action-handlers.[m
[32m+[m[32m        try:[m
[32m+[m[32m            handlers[action](options, args[1:])[m
[32m+[m[32m        except PipError as e:[m
[32m+[m[32m            logger.error(e.args[0])[m
[32m+[m[32m            return ERROR[m
[32m+[m
[32m+[m[32m        return SUCCESS[m
[32m+[m
[32m+[m[32m    def _determine_file(self, options: Values, need_value: bool) -> Optional[Kind]:[m
[32m+[m[32m        file_options = [[m
[32m+[m[32m            key[m
[32m+[m[32m            for key, value in ([m
[32m+[m[32m                (kinds.USER, options.user_file),[m
[32m+[m[32m                (kinds.GLOBAL, options.global_file),[m
[32m+[m[32m                (kinds.SITE, options.site_file),[m
[32m+[m[32m            )[m
[32m+[m[32m            if value[m
[32m+[m[32m        ][m
[32m+[m
[32m+[m[32m        if not file_options:[m
[32m+[m[32m            if not need_value:[m
[32m+[m[32m                return None[m
[32m+[m[32m            # Default to user, unless there's a site file.[m
[32m+[m[32m            elif any([m
[32m+[m[32m                os.path.exists(site_config_file)[m
[32m+[m[32m                for site_config_file in get_configuration_files()[kinds.SITE][m
[32m+[m[32m            ):[m
[32m+[m[32m                return kinds.SITE[m
[32m+[m[32m            else:[m
[32m+[m[32m                return kinds.USER[m
[32m+[m[32m        elif len(file_options) == 1:[m
[32m+[m[32m            return file_options[0][m
[32m+[m
[32m+[m[32m        raise PipError([m
[32m+[m[32m            "Need exactly one file to operate upon "[m
[32m+[m[32m            "(--user, --site, --global) to perform."[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    def list_values(self, options: Values, args: List[str]) -> None:[m
[32m+[m[32m        self._get_n_args(args, "list", n=0)[m
[32m+[m
[32m+[m[32m        for key, value in sorted(self.configuration.items()):[m
[32m+[m[32m            write_output("%s=%r", key, value)[m
[32m+[m
[32m+[m[32m    def get_name(self, options: Values, args: List[str]) -> None:[m
[32m+[m[32m        key = self._get_n_args(args, "get [name]", n=1)[m
[32m+[m[32m        value = self.configuration.get_value(key)[m
[32m+[m
[32m+[m[32m        write_output("%s", value)[m
[32m+[m
[32m+[m[32m    def set_name_value(self, options: Values, args: List[str]) -> None:[m
[32m+[m[32m        key, value = self._get_n_args(args, "set [name] [value]", n=2)[m
[32m+[m[32m        self.configuration.set_value(key, value)[m
[32m+[m
[32m+[m[32m        self._save_configuration()[m
[32m+[m
[32m+[m[32m    def unset_name(self, options: Values, args: List[str]) -> None:[m
[32m+[m[32m        key = self._get_n_args(args, "unset [name]", n=1)[m
[32m+[m[32m        self.configuration.unset_value(key)[m
[32m+[m
[32m+[m[32m        self._save_configuration()[m
[32m+[m
[32m+[m[32m    def list_config_values(self, options: Values, args: List[str]) -> None:[m
[32m+[m[32m        """List config key-value pairs across different config files"""[m
[32m+[m[32m        self._get_n_args(args, "debug", n=0)[m
[32m+[m
[32m+[m[32m        self.print_env_var_values()[m
[32m+[m[32m        # Iterate over config files and print if they exist, and the[m
[32m+[m[32m        # key-value pairs present in them if they do[m
[32m+[m[32m        for variant, files in sorted(self.configuration.iter_config_files()):[m
[32m+[m[32m            write_output("%s:", variant)[m
[32m+[m[32m            for fname in files:[m
[32m+[m[32m                with indent_log():[m
[32m+[m[32m                    file_exists = os.path.exists(fname)[m
[32m+[m[32m                    write_output("%s, exists: %r", fname, file_exists)[m
[32m+[m[32m                    if file_exists:[m
[32m+[m[32m                        self.print_config_file_values(variant)[m
[32m+[m
[32m+[m[32m    def print_config_file_values(self, variant: Kind) -> None:[m
[32m+[m[32m        """Get key-value pairs from the file of a variant"""[m
[32m+[m[32m        for name, value in self.configuration.get_values_in_config(variant).items():[m
[32m+[m[32m            with indent_log():[m
[32m+[m[32m                write_output("%s: %s", name, value)[m
[32m+[m
[32m+[m[32m    def print_env_var_values(self) -> None:[m
[32m+[m[32m        """Get key-values pairs present as environment variables"""[m
[32m+[m[32m        write_output("%s:", "env_var")[m
[32m+[m[32m        with indent_log():[m
[32m+[m[32m            for key, value in sorted(self.configuration.get_environ_vars()):[m
[32m+[m[32m                env_var = f"PIP_{key.upper()}"[m
[32m+[m[32m                write_output("%s=%r", env_var, value)[m
[32m+[m
[32m+[m[32m    def open_in_editor(self, options: Values, args: List[str]) -> None:[m
[32m+[m[32m        editor = self._determine_editor(options)[m
[32m+[m
[32m+[m[32m        fname = self.configuration.get_file_to_edit()[m
[32m+[m[32m        if fname is None:[m
[32m+[m[32m            raise PipError("Could not determine appropriate file.")[m
[32m+[m[32m        elif '"' in fname:[m
[32m+[m[32m            # This shouldn't happen, unless we see a username like that.[m
[32m+[m[32m            # If that happens, we'd appreciate a pull request fixing this.[m
[32m+[m[32m            raise PipError([m
[32m+[m[32m                f'Can not open an editor for a file name containing "\n{fname}'[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        try:[m
[32m+[m[32m            subprocess.check_call(f'{editor} "{fname}"', shell=True)[m
[32m+[m[32m        except FileNotFoundError as e:[m
[32m+[m[32m            if not e.filename:[m
[32m+[m[32m                e.filename = editor[m
[32m+[m[32m            raise[m
[32m+[m[32m        except subprocess.CalledProcessError as e:[m
[32m+[m[32m            raise PipError(f"Editor Subprocess exited with exit code {e.returncode}")[m
[32m+[m
[32m+[m[32m    def _get_n_args(self, args: List[str], example: str, n: int) -> Any:[m
[32m+[m[32m        """Helper to make sure the command got the right number of arguments"""[m
[32m+[m[32m        if len(args) != n:[m
[32m+[m[32m            msg = ([m
[32m+[m[32m                f"Got unexpected number of arguments, expected {n}. "[m
[32m+[m[32m                f'(example: "{get_prog()} config {example}")'[m
[32m+[m[32m            )[m
[32m+[m[32m            raise PipError(msg)[m
[32m+[m
[32m+[m[32m        if n == 1:[m
[32m+[m[32m            return args[0][m
[32m+[m[32m        else:[m
[32m+[m[32m            return args[m
[32m+[m
[32m+[m[32m    def _save_configuration(self) -> None:[m
[32m+[m[32m        # We successfully ran a modifying command. Need to save the[m
[32m+[m[32m        # configuration.[m
[32m+[m[32m        try:[m
[32m+[m[32m            self.configuration.save()[m
[32m+[m[32m        except Exception:[m
[32m+[m[32m            logger.exception([m
[32m+[m[32m                "Unable to save configuration. Please report this as a bug."[m
[32m+[m[32m            )[m
[32m+[m[32m            raise PipError("Internal Error.")[m
[32m+[m
[32m+[m[32m    def _determine_editor(self, options: Values) -> str:[m
[32m+[m[32m        if options.editor is not None:[m
[32m+[m[32m            return options.editor[m
[32m+[m[32m        elif "VISUAL" in os.environ:[m
[32m+[m[32m            return os.environ["VISUAL"][m
[32m+[m[32m        elif "EDITOR" in os.environ:[m
[32m+[m[32m            return os.environ["EDITOR"][m
[32m+[m[32m        else:[m
[32m+[m[32m            raise PipError("Could not determine editor to use.")[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/debug.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/debug.py[m
[1mnew file mode 100644[m
[1mindex 0000000..7e5271c[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/debug.py[m
[36m@@ -0,0 +1,201 @@[m
[32m+[m[32mimport importlib.resources[m
[32m+[m[32mimport locale[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport os[m
[32m+[m[32mimport sys[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom types import ModuleType[m
[32m+[m[32mfrom typing import Any, Dict, List, Optional[m
[32m+[m
[32m+[m[32mimport pip._vendor[m
[32m+[m[32mfrom pip._vendor.certifi import where[m
[32m+[m[32mfrom pip._vendor.packaging.version import parse as parse_version[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli import cmdoptions[m
[32m+[m[32mfrom pip._internal.cli.base_command import Command[m
[32m+[m[32mfrom pip._internal.cli.cmdoptions import make_target_python[m
[32m+[m[32mfrom pip._internal.cli.status_codes import SUCCESS[m
[32m+[m[32mfrom pip._internal.configuration import Configuration[m
[32m+[m[32mfrom pip._internal.metadata import get_environment[m
[32m+[m[32mfrom pip._internal.utils.logging import indent_log[m
[32m+[m[32mfrom pip._internal.utils.misc import get_pip_version[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mdef show_value(name: str, value: Any) -> None:[m
[32m+[m[32m    logger.info("%s: %s", name, value)[m
[32m+[m
[32m+[m
[32m+[m[32mdef show_sys_implementation() -> None:[m
[32m+[m[32m    logger.info("sys.implementation:")[m
[32m+[m[32m    implementation_name = sys.implementation.name[m
[32m+[m[32m    with indent_log():[m
[32m+[m[32m        show_value("name", implementation_name)[m
[32m+[m
[32m+[m
[32m+[m[32mdef create_vendor_txt_map() -> Dict[str, str]:[m
[32m+[m[32m    with importlib.resources.open_text("pip._vendor", "vendor.txt") as f:[m
[32m+[m[32m        # Purge non version specifying lines.[m
[32m+[m[32m        # Also, remove any space prefix or suffixes (including comments).[m
[32m+[m[32m        lines = [[m
[32m+[m[32m            line.strip().split(" ", 1)[0] for line in f.readlines() if "==" in line[m
[32m+[m[32m        ][m
[32m+[m
[32m+[m[32m    # Transform into "module" -> version dict.[m
[32m+[m[32m    return dict(line.split("==", 1) for line in lines)[m
[32m+[m
[32m+[m
[32m+[m[32mdef get_module_from_module_name(module_name: str) -> Optional[ModuleType]:[m
[32m+[m[32m    # Module name can be uppercase in vendor.txt for some reason...[m
[32m+[m[32m    module_name = module_name.lower().replace("-", "_")[m
[32m+[m[32m    # PATCH: setuptools is actually only pkg_resources.[m
[32m+[m[32m    if module_name == "setuptools":[m
[32m+[m[32m        module_name = "pkg_resources"[m
[32m+[m
[32m+[m[32m    try:[m
[32m+[m[32m        __import__(f"pip._vendor.{module_name}", globals(), locals(), level=0)[m
[32m+[m[32m        return getattr(pip._vendor, module_name)[m
[32m+[m[32m    except ImportError:[m
[32m+[m[32m        # We allow 'truststore' to fail to import due[m
[32m+[m[32m        # to being unavailable on Python 3.9 and earlier.[m
[32m+[m[32m        if module_name == "truststore" and sys.version_info < (3, 10):[m
[32m+[m[32m            return None[m
[32m+[m[32m        raise[m
[32m+[m
[32m+[m
[32m+[m[32mdef get_vendor_version_from_module(module_name: str) -> Optional[str]:[m
[32m+[m[32m    module = get_module_from_module_name(module_name)[m
[32m+[m[32m    version = getattr(module, "__version__", None)[m
[32m+[m
[32m+[m[32m    if module and not version:[m
[32m+[m[32m        # Try to find version in debundled module info.[m
[32m+[m[32m        assert module.__file__ is not None[m
[32m+[m[32m        env = get_environment([os.path.dirname(module.__file__)])[m
[32m+[m[32m        dist = env.get_distribution(module_name)[m
[32m+[m[32m        if dist:[m
[32m+[m[32m            version = str(dist.version)[m
[32m+[m
[32m+[m[32m    return version[m
[32m+[m
[32m+[m
[32m+[m[32mdef show_actual_vendor_versions(vendor_txt_versions: Dict[str, str]) -> None:[m
[32m+[m[32m    """Log the actual version and print extra info if there is[m
[32m+[m[32m    a conflict or if the actual version could not be imported.[m
[32m+[m[32m    """[m
[32m+[m[32m    for module_name, expected_version in vendor_txt_versions.items():[m
[32m+[m[32m        extra_message = ""[m
[32m+[m[32m        actual_version = get_vendor_version_from_module(module_name)[m
[32m+[m[32m        if not actual_version:[m
[32m+[m[32m            extra_message = ([m
[32m+[m[32m                " (Unable to locate actual module version, using"[m
[32m+[m[32m                " vendor.txt specified version)"[m
[32m+[m[32m            )[m
[32m+[m[32m            actual_version = expected_version[m
[32m+[m[32m        elif parse_version(actual_version) != parse_version(expected_version):[m
[32m+[m[32m            extra_message = ([m
[32m+[m[32m                " (CONFLICT: vendor.txt suggests version should"[m
[32m+[m[32m                f" be {expected_version})"[m
[32m+[m[32m            )[m
[32m+[m[32m        logger.info("%s==%s%s", module_name, actual_version, extra_message)[m
[32m+[m
[32m+[m
[32m+[m[32mdef show_vendor_versions() -> None:[m
[32m+[m[32m    logger.info("vendored library versions:")[m
[32m+[m
[32m+[m[32m    vendor_txt_versions = create_vendor_txt_map()[m
[32m+[m[32m    with indent_log():[m
[32m+[m[32m        show_actual_vendor_versions(vendor_txt_versions)[m
[32m+[m
[32m+[m
[32m+[m[32mdef show_tags(options: Values) -> None:[m
[32m+[m[32m    tag_limit = 10[m
[32m+[m
[32m+[m[32m    target_python = make_target_python(options)[m
[32m+[m[32m    tags = target_python.get_sorted_tags()[m
[32m+[m
[32m+[m[32m    # Display the target options that were explicitly provided.[m
[32m+[m[32m    formatted_target = target_python.format_given()[m
[32m+[m[32m    suffix = ""[m
[32m+[m[32m    if formatted_target:[m
[32m+[m[32m        suffix = f" (target: {formatted_target})"[m
[32m+[m
[32m+[m[32m    msg = f"Compatible tags: {len(tags)}{suffix}"[m
[32m+[m[32m    logger.info(msg)[m
[32m+[m
[32m+[m[32m    if options.verbose < 1 and len(tags) > tag_limit:[m
[32m+[m[32m        tags_limited = True[m
[32m+[m[32m        tags = tags[:tag_limit][m
[32m+[m[32m    else:[m
[32m+[m[32m        tags_limited = False[m
[32m+[m
[32m+[m[32m    with indent_log():[m
[32m+[m[32m        for tag in tags:[m
[32m+[m[32m            logger.info(str(tag))[m
[32m+[m
[32m+[m[32m        if tags_limited:[m
[32m+[m[32m            msg = f"...\n[First {tag_limit} tags shown. Pass --verbose to show all.]"[m
[32m+[m[32m            logger.info(msg)[m
[32m+[m
[32m+[m
[32m+[m[32mdef ca_bundle_info(config: Configuration) -> str:[m
[32m+[m[32m    levels = {key.split(".", 1)[0] for key, _ in config.items()}[m
[32m+[m[32m    if not levels:[m
[32m+[m[32m        return "Not specified"[m
[32m+[m
[32m+[m[32m    levels_that_override_global = ["install", "wheel", "download"][m
[32m+[m[32m    global_overriding_level = [[m
[32m+[m[32m        level for level in levels if level in levels_that_override_global[m
[32m+[m[32m    ][m
[32m+[m[32m    if not global_overriding_level:[m
[32m+[m[32m        return "global"[m
[32m+[m
[32m+[m[32m    if "global" in levels:[m
[32m+[m[32m        levels.remove("global")[m
[32m+[m[32m    return ", ".join(levels)[m
[32m+[m
[32m+[m
[32m+[m[32mclass DebugCommand(Command):[m
[32m+[m[32m    """[m
[32m+[m[32m    Display debug information.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    usage = """[m
[32m+[m[32m      %prog <options>"""[m
[32m+[m[32m    ignore_require_venv = True[m
[32m+[m
[32m+[m[32m    def add_options(self) -> None:[m
[32m+[m[32m        cmdoptions.add_target_python_options(self.cmd_opts)[m
[32m+[m[32m        self.parser.insert_option_group(0, self.cmd_opts)[m
[32m+[m[32m        self.parser.config.load()[m
[32m+[m
[32m+[m[32m    def run(self, options: Values, args: List[str]) -> int:[m
[32m+[m[32m        logger.warning([m
[32m+[m[32m            "This command is only meant for debugging. "[m
[32m+[m[32m            "Do not use this with automation for parsing and getting these "[m
[32m+[m[32m            "details, since the output and options of this command may "[m
[32m+[m[32m            "change without notice."[m
[32m+[m[32m        )[m
[32m+[m[32m        show_value("pip version", get_pip_version())[m
[32m+[m[32m        show_value("sys.version", sys.version)[m
[32m+[m[32m        show_value("sys.executable", sys.executable)[m
[32m+[m[32m        show_value("sys.getdefaultencoding", sys.getdefaultencoding())[m
[32m+[m[32m        show_value("sys.getfilesystemencoding", sys.getfilesystemencoding())[m
[32m+[m[32m        show_value([m
[32m+[m[32m            "locale.getpreferredencoding",[m
[32m+[m[32m            locale.getpreferredencoding(),[m
[32m+[m[32m        )[m
[32m+[m[32m        show_value("sys.platform", sys.platform)[m
[32m+[m[32m        show_sys_implementation()[m
[32m+[m
[32m+[m[32m        show_value("'cert' config value", ca_bundle_info(self.parser.config))[m
[32m+[m[32m        show_value("REQUESTS_CA_BUNDLE", os.environ.get("REQUESTS_CA_BUNDLE"))[m
[32m+[m[32m        show_value("CURL_CA_BUNDLE", os.environ.get("CURL_CA_BUNDLE"))[m
[32m+[m[32m        show_value("pip._vendor.certifi.where()", where())[m
[32m+[m[32m        show_value("pip._vendor.DEBUNDLED", pip._vendor.DEBUNDLED)[m
[32m+[m
[32m+[m[32m        show_vendor_versions()[m
[32m+[m
[32m+[m[32m        show_tags(options)[m
[32m+[m
[32m+[m[32m        return SUCCESS[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/download.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/download.py[m
[1mnew file mode 100644[m
[1mindex 0000000..54247a7[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/download.py[m
[36m@@ -0,0 +1,147 @@[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport os[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom typing import List[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli import cmdoptions[m
[32m+[m[32mfrom pip._internal.cli.cmdoptions import make_target_python[m
[32m+[m[32mfrom pip._internal.cli.req_command import RequirementCommand, with_cleanup[m
[32m+[m[32mfrom pip._internal.cli.status_codes import SUCCESS[m
[32m+[m[32mfrom pip._internal.operations.build.build_tracker import get_build_tracker[m
[32m+[m[32mfrom pip._internal.req.req_install import check_legacy_setup_py_options[m
[32m+[m[32mfrom pip._internal.utils.misc import ensure_dir, normalize_path, write_output[m
[32m+[m[32mfrom pip._internal.utils.temp_dir import TempDirectory[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass DownloadCommand(RequirementCommand):[m
[32m+[m[32m    """[m
[32m+[m[32m    Download packages from:[m
[32m+[m
[32m+[m[32m    - PyPI (and other indexes) using requirement specifiers.[m
[32m+[m[32m    - VCS project urls.[m
[32m+[m[32m    - Local project directories.[m
[32m+[m[32m    - Local or remote source archives.[m
[32m+[m
[32m+[m[32m    pip also supports downloading from "requirements files", which provide[m
[32m+[m[32m    an easy way to specify a whole environment to be downloaded.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    usage = """[m
[32m+[m[32m      %prog [options] <requirement specifier> [package-index-options] ...[m
[32m+[m[32m      %prog [options] -r <requirements file> [package-index-options] ...[m
[32m+[m[32m      %prog [options] <vcs project url> ...[m
[32m+[m[32m      %prog [options] <local project path> ...[m
[32m+[m[32m      %prog [options] <archive url/path> ..."""[m
[32m+[m
[32m+[m[32m    def add_options(self) -> None:[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.constraints())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.requirements())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.no_deps())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.global_options())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.no_binary())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.only_binary())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.prefer_binary())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.src())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.pre())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.require_hashes())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.progress_bar())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.no_build_isolation())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.use_pep517())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.no_use_pep517())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.check_build_deps())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.ignore_requires_python())[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "-d",[m
[32m+[m[32m            "--dest",[m
[32m+[m[32m            "--destination-dir",[m
[32m+[m[32m            "--destination-directory",[m
[32m+[m[32m            dest="download_dir",[m
[32m+[m[32m            metavar="dir",[m
[32m+[m[32m            default=os.curdir,[m
[32m+[m[32m            help="Download packages into <dir>.",[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        cmdoptions.add_target_python_options(self.cmd_opts)[m
[32m+[m
[32m+[m[32m        index_opts = cmdoptions.make_option_group([m
[32m+[m[32m            cmdoptions.index_group,[m
[32m+[m[32m            self.parser,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.parser.insert_option_group(0, index_opts)[m
[32m+[m[32m        self.parser.insert_option_group(0, self.cmd_opts)[m
[32m+[m
[32m+[m[32m    @with_cleanup[m
[32m+[m[32m    def run(self, options: Values, args: List[str]) -> int:[m
[32m+[m[32m        options.ignore_installed = True[m
[32m+[m[32m        # editable doesn't really make sense for `pip download`, but the bowels[m
[32m+[m[32m        # of the RequirementSet code require that property.[m
[32m+[m[32m        options.editables = [][m
[32m+[m
[32m+[m[32m        cmdoptions.check_dist_restriction(options)[m
[32m+[m
[32m+[m[32m        options.download_dir = normalize_path(options.download_dir)[m
[32m+[m[32m        ensure_dir(options.download_dir)[m
[32m+[m
[32m+[m[32m        session = self.get_default_session(options)[m
[32m+[m
[32m+[m[32m        target_python = make_target_python(options)[m
[32m+[m[32m        finder = self._build_package_finder([m
[32m+[m[32m            options=options,[m
[32m+[m[32m            session=session,[m
[32m+[m[32m            target_python=target_python,[m
[32m+[m[32m            ignore_requires_python=options.ignore_requires_python,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        build_tracker = self.enter_context(get_build_tracker())[m
[32m+[m
[32m+[m[32m        directory = TempDirectory([m
[32m+[m[32m            delete=not options.no_clean,[m
[32m+[m[32m            kind="download",[m
[32m+[m[32m            globally_managed=True,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        reqs = self.get_requirements(args, options, finder, session)[m
[32m+[m[32m        check_legacy_setup_py_options(options, reqs)[m
[32m+[m
[32m+[m[32m        preparer = self.make_requirement_preparer([m
[32m+[m[32m            temp_build_dir=directory,[m
[32m+[m[32m            options=options,[m
[32m+[m[32m            build_tracker=build_tracker,[m
[32m+[m[32m            session=session,[m
[32m+[m[32m            finder=finder,[m
[32m+[m[32m            download_dir=options.download_dir,[m
[32m+[m[32m            use_user_site=False,[m
[32m+[m[32m            verbosity=self.verbosity,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        resolver = self.make_resolver([m
[32m+[m[32m            preparer=preparer,[m
[32m+[m[32m            finder=finder,[m
[32m+[m[32m            options=options,[m
[32m+[m[32m            ignore_requires_python=options.ignore_requires_python,[m
[32m+[m[32m            use_pep517=options.use_pep517,[m
[32m+[m[32m            py_version_info=options.python_version,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.trace_basic_info(finder)[m
[32m+[m
[32m+[m[32m        requirement_set = resolver.resolve(reqs, check_supported_wheels=True)[m
[32m+[m
[32m+[m[32m        downloaded: List[str] = [][m
[32m+[m[32m        for req in requirement_set.requirements.values():[m
[32m+[m[32m            if req.satisfied_by is None:[m
[32m+[m[32m                assert req.name is not None[m
[32m+[m[32m                preparer.save_linked_requirement(req)[m
[32m+[m[32m                downloaded.append(req.name)[m
[32m+[m
[32m+[m[32m        preparer.prepare_linked_requirements_more(requirement_set.requirements.values())[m
[32m+[m[32m        requirement_set.warn_legacy_versions_and_specifiers()[m
[32m+[m
[32m+[m[32m        if downloaded:[m
[32m+[m[32m            write_output("Successfully downloaded %s", " ".join(downloaded))[m
[32m+[m
[32m+[m[32m        return SUCCESS[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/freeze.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/freeze.py[m
[1mnew file mode 100644[m
[1mindex 0000000..fd9d88a[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/freeze.py[m
[36m@@ -0,0 +1,108 @@[m
[32m+[m[32mimport sys[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom typing import AbstractSet, List[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli import cmdoptions[m
[32m+[m[32mfrom pip._internal.cli.base_command import Command[m
[32m+[m[32mfrom pip._internal.cli.status_codes import SUCCESS[m
[32m+[m[32mfrom pip._internal.operations.freeze import freeze[m
[32m+[m[32mfrom pip._internal.utils.compat import stdlib_pkgs[m
[32m+[m
[32m+[m
[32m+[m[32mdef _should_suppress_build_backends() -> bool:[m
[32m+[m[32m    return sys.version_info < (3, 12)[m
[32m+[m
[32m+[m
[32m+[m[32mdef _dev_pkgs() -> AbstractSet[str]:[m
[32m+[m[32m    pkgs = {"pip"}[m
[32m+[m
[32m+[m[32m    if _should_suppress_build_backends():[m
[32m+[m[32m        pkgs |= {"setuptools", "distribute", "wheel"}[m
[32m+[m
[32m+[m[32m    return pkgs[m
[32m+[m
[32m+[m
[32m+[m[32mclass FreezeCommand(Command):[m
[32m+[m[32m    """[m
[32m+[m[32m    Output installed packages in requirements format.[m
[32m+[m
[32m+[m[32m    packages are listed in a case-insensitive sorted order.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    usage = """[m
[32m+[m[32m      %prog [options]"""[m
[32m+[m[32m    log_streams = ("ext://sys.stderr", "ext://sys.stderr")[m
[32m+[m
[32m+[m[32m    def add_options(self) -> None:[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "-r",[m
[32m+[m[32m            "--requirement",[m
[32m+[m[32m            dest="requirements",[m
[32m+[m[32m            action="append",[m
[32m+[m[32m            default=[],[m
[32m+[m[32m            metavar="file",[m
[32m+[m[32m            help=([m
[32m+[m[32m                "Use the order in the given requirements file and its "[m
[32m+[m[32m                "comments when generating output. This option can be "[m
[32m+[m[32m                "used multiple times."[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "-l",[m
[32m+[m[32m            "--local",[m
[32m+[m[32m            dest="local",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            default=False,[m
[32m+[m[32m            help=([m
[32m+[m[32m                "If in a virtualenv that has global access, do not output "[m
[32m+[m[32m                "globally-installed packages."[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--user",[m
[32m+[m[32m            dest="user",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            default=False,[m
[32m+[m[32m            help="Only output packages installed in user-site.",[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.list_path())[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--all",[m
[32m+[m[32m            dest="freeze_all",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            help=([m
[32m+[m[32m                "Do not skip these packages in the output:"[m
[32m+[m[32m                " {}".format(", ".join(_dev_pkgs()))[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--exclude-editable",[m
[32m+[m[32m            dest="exclude_editable",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            help="Exclude editable package from output.",[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.list_exclude())[m
[32m+[m
[32m+[m[32m        self.parser.insert_option_group(0, self.cmd_opts)[m
[32m+[m
[32m+[m[32m    def run(self, options: Values, args: List[str]) -> int:[m
[32m+[m[32m        skip = set(stdlib_pkgs)[m
[32m+[m[32m        if not options.freeze_all:[m
[32m+[m[32m            skip.update(_dev_pkgs())[m
[32m+[m
[32m+[m[32m        if options.excludes:[m
[32m+[m[32m            skip.update(options.excludes)[m
[32m+[m
[32m+[m[32m        cmdoptions.check_list_path_option(options)[m
[32m+[m
[32m+[m[32m        for line in freeze([m
[32m+[m[32m            requirement=options.requirements,[m
[32m+[m[32m            local_only=options.local,[m
[32m+[m[32m            user_only=options.user,[m
[32m+[m[32m            paths=options.path,[m
[32m+[m[32m            isolated=options.isolated_mode,[m
[32m+[m[32m            skip=skip,[m
[32m+[m[32m            exclude_editable=options.exclude_editable,[m
[32m+[m[32m        ):[m
[32m+[m[32m            sys.stdout.write(line + "\n")[m
[32m+[m[32m        return SUCCESS[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/hash.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/hash.py[m
[1mnew file mode 100644[m
[1mindex 0000000..042dac8[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/hash.py[m
[36m@@ -0,0 +1,59 @@[m
[32m+[m[32mimport hashlib[m
[32m+[m[32mimport logging[m
[32m+[m[32mimport sys[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom typing import List[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli.base_command import Command[m
[32m+[m[32mfrom pip._internal.cli.status_codes import ERROR, SUCCESS[m
[32m+[m[32mfrom pip._internal.utils.hashes import FAVORITE_HASH, STRONG_HASHES[m
[32m+[m[32mfrom pip._internal.utils.misc import read_chunks, write_output[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass HashCommand(Command):[m
[32m+[m[32m    """[m
[32m+[m[32m    Compute a hash of a local package archive.[m
[32m+[m
[32m+[m[32m    These can be used with --hash in a requirements file to do repeatable[m
[32m+[m[32m    installs.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    usage = "%prog [options] <file> ..."[m
[32m+[m[32m    ignore_require_venv = True[m
[32m+[m
[32m+[m[32m    def add_options(self) -> None:[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "-a",[m
[32m+[m[32m            "--algorithm",[m
[32m+[m[32m            dest="algorithm",[m
[32m+[m[32m            choices=STRONG_HASHES,[m
[32m+[m[32m            action="store",[m
[32m+[m[32m            default=FAVORITE_HASH,[m
[32m+[m[32m            help="The hash algorithm to use: one of {}".format([m
[32m+[m[32m                ", ".join(STRONG_HASHES)[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m[32m        self.parser.insert_option_group(0, self.cmd_opts)[m
[32m+[m
[32m+[m[32m    def run(self, options: Values, args: List[str]) -> int:[m
[32m+[m[32m        if not args:[m
[32m+[m[32m            self.parser.print_usage(sys.stderr)[m
[32m+[m[32m            return ERROR[m
[32m+[m
[32m+[m[32m        algorithm = options.algorithm[m
[32m+[m[32m        for path in args:[m
[32m+[m[32m            write_output([m
[32m+[m[32m                "%s:\n--hash=%s:%s", path, algorithm, _hash_of_file(path, algorithm)[m
[32m+[m[32m            )[m
[32m+[m[32m        return SUCCESS[m
[32m+[m
[32m+[m
[32m+[m[32mdef _hash_of_file(path: str, algorithm: str) -> str:[m
[32m+[m[32m    """Return the hash digest of a file."""[m
[32m+[m[32m    with open(path, "rb") as archive:[m
[32m+[m[32m        hash = hashlib.new(algorithm)[m
[32m+[m[32m        for chunk in read_chunks(archive):[m
[32m+[m[32m            hash.update(chunk)[m
[32m+[m[32m    return hash.hexdigest()[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/help.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/help.py[m
[1mnew file mode 100644[m
[1mindex 0000000..6206631[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/help.py[m
[36m@@ -0,0 +1,41 @@[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom typing import List[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli.base_command import Command[m
[32m+[m[32mfrom pip._internal.cli.status_codes import SUCCESS[m
[32m+[m[32mfrom pip._internal.exceptions import CommandError[m
[32m+[m
[32m+[m
[32m+[m[32mclass HelpCommand(Command):[m
[32m+[m[32m    """Show help for commands"""[m
[32m+[m
[32m+[m[32m    usage = """[m
[32m+[m[32m      %prog <command>"""[m
[32m+[m[32m    ignore_require_venv = True[m
[32m+[m
[32m+[m[32m    def run(self, options: Values, args: List[str]) -> int:[m
[32m+[m[32m        from pip._internal.commands import ([m
[32m+[m[32m            commands_dict,[m
[32m+[m[32m            create_command,[m
[32m+[m[32m            get_similar_commands,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        try:[m
[32m+[m[32m            # 'pip help' with no args is handled by pip.__init__.parseopt()[m
[32m+[m[32m            cmd_name = args[0]  # the command we need help for[m
[32m+[m[32m        except IndexError:[m
[32m+[m[32m            return SUCCESS[m
[32m+[m
[32m+[m[32m        if cmd_name not in commands_dict:[m
[32m+[m[32m            guess = get_similar_commands(cmd_name)[m
[32m+[m
[32m+[m[32m            msg = [f'unknown command "{cmd_name}"'][m
[32m+[m[32m            if guess:[m
[32m+[m[32m                msg.append(f'maybe you meant "{guess}"')[m
[32m+[m
[32m+[m[32m            raise CommandError(" - ".join(msg))[m
[32m+[m
[32m+[m[32m        command = create_command(cmd_name)[m
[32m+[m[32m        command.parser.print_help()[m
[32m+[m
[32m+[m[32m        return SUCCESS[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/index.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/index.py[m
[1mnew file mode 100644[m
[1mindex 0000000..f55e9e4[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/index.py[m
[36m@@ -0,0 +1,139 @@[m
[32m+[m[32mimport logging[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom typing import Any, Iterable, List, Optional, Union[m
[32m+[m
[32m+[m[32mfrom pip._vendor.packaging.version import LegacyVersion, Version[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli import cmdoptions[m
[32m+[m[32mfrom pip._internal.cli.req_command import IndexGroupCommand[m
[32m+[m[32mfrom pip._internal.cli.status_codes import ERROR, SUCCESS[m
[32m+[m[32mfrom pip._internal.commands.search import print_dist_installation_info[m
[32m+[m[32mfrom pip._internal.exceptions import CommandError, DistributionNotFound, PipError[m
[32m+[m[32mfrom pip._internal.index.collector import LinkCollector[m
[32m+[m[32mfrom pip._internal.index.package_finder import PackageFinder[m
[32m+[m[32mfrom pip._internal.models.selection_prefs import SelectionPreferences[m
[32m+[m[32mfrom pip._internal.models.target_python import TargetPython[m
[32m+[m[32mfrom pip._internal.network.session import PipSession[m
[32m+[m[32mfrom pip._internal.utils.misc import write_output[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass IndexCommand(IndexGroupCommand):[m
[32m+[m[32m    """[m
[32m+[m[32m    Inspect information available from package indexes.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    ignore_require_venv = True[m
[32m+[m[32m    usage = """[m
[32m+[m[32m        %prog versions <package>[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    def add_options(self) -> None:[m
[32m+[m[32m        cmdoptions.add_target_python_options(self.cmd_opts)[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.ignore_requires_python())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.pre())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.no_binary())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.only_binary())[m
[32m+[m
[32m+[m[32m        index_opts = cmdoptions.make_option_group([m
[32m+[m[32m            cmdoptions.index_group,[m
[32m+[m[32m            self.parser,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.parser.insert_option_group(0, index_opts)[m
[32m+[m[32m        self.parser.insert_option_group(0, self.cmd_opts)[m
[32m+[m
[32m+[m[32m    def run(self, options: Values, args: List[str]) -> int:[m
[32m+[m[32m        handlers = {[m
[32m+[m[32m            "versions": self.get_available_package_versions,[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        logger.warning([m
[32m+[m[32m            "pip index is currently an experimental command. "[m
[32m+[m[32m            "It may be removed/changed in a future release "[m
[32m+[m[32m            "without prior warning."[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        # Determine action[m
[32m+[m[32m        if not args or args[0] not in handlers:[m
[32m+[m[32m            logger.error([m
[32m+[m[32m                "Need an action (%s) to perform.",[m
[32m+[m[32m                ", ".join(sorted(handlers)),[m
[32m+[m[32m            )[m
[32m+[m[32m            return ERROR[m
[32m+[m
[32m+[m[32m        action = args[0][m
[32m+[m
[32m+[m[32m        # Error handling happens here, not in the action-handlers.[m
[32m+[m[32m        try:[m
[32m+[m[32m            handlers[action](options, args[1:])[m
[32m+[m[32m        except PipError as e:[m
[32m+[m[32m            logger.error(e.args[0])[m
[32m+[m[32m            return ERROR[m
[32m+[m
[32m+[m[32m        return SUCCESS[m
[32m+[m
[32m+[m[32m    def _build_package_finder([m
[32m+[m[32m        self,[m
[32m+[m[32m        options: Values,[m
[32m+[m[32m        session: PipSession,[m
[32m+[m[32m        target_python: Optional[TargetPython] = None,[m
[32m+[m[32m        ignore_requires_python: Optional[bool] = None,[m
[32m+[m[32m    ) -> PackageFinder:[m
[32m+[m[32m        """[m
[32m+[m[32m        Create a package finder appropriate to the index command.[m
[32m+[m[32m        """[m
[32m+[m[32m        link_collector = LinkCollector.create(session, options=options)[m
[32m+[m
[32m+[m[32m        # Pass allow_yanked=False to ignore yanked versions.[m
[32m+[m[32m        selection_prefs = SelectionPreferences([m
[32m+[m[32m            allow_yanked=False,[m
[32m+[m[32m            allow_all_prereleases=options.pre,[m
[32m+[m[32m            ignore_requires_python=ignore_requires_python,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        return PackageFinder.create([m
[32m+[m[32m            link_collector=link_collector,[m
[32m+[m[32m            selection_prefs=selection_prefs,[m
[32m+[m[32m            target_python=target_python,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    def get_available_package_versions(self, options: Values, args: List[Any]) -> None:[m
[32m+[m[32m        if len(args) != 1:[m
[32m+[m[32m            raise CommandError("You need to specify exactly one argument")[m
[32m+[m
[32m+[m[32m        target_python = cmdoptions.make_target_python(options)[m
[32m+[m[32m        query = args[0][m
[32m+[m
[32m+[m[32m        with self._build_session(options) as session:[m
[32m+[m[32m            finder = self._build_package_finder([m
[32m+[m[32m                options=options,[m
[32m+[m[32m                session=session,[m
[32m+[m[32m                target_python=target_python,[m
[32m+[m[32m                ignore_requires_python=options.ignore_requires_python,[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m            versions: Iterable[Union[LegacyVersion, Version]] = ([m
[32m+[m[32m                candidate.version for candidate in finder.find_all_candidates(query)[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m            if not options.pre:[m
[32m+[m[32m                # Remove prereleases[m
[32m+[m[32m                versions = ([m
[32m+[m[32m                    version for version in versions if not version.is_prerelease[m
[32m+[m[32m                )[m
[32m+[m[32m            versions = set(versions)[m
[32m+[m
[32m+[m[32m            if not versions:[m
[32m+[m[32m                raise DistributionNotFound([m
[32m+[m[32m                    f"No matching distribution found for {query}"[m
[32m+[m[32m                )[m
[32m+[m
[32m+[m[32m            formatted_versions = [str(ver) for ver in sorted(versions, reverse=True)][m
[32m+[m[32m            latest = formatted_versions[0][m
[32m+[m
[32m+[m[32m        write_output(f"{query} ({latest})")[m
[32m+[m[32m        write_output("Available versions: {}".format(", ".join(formatted_versions)))[m
[32m+[m[32m        print_dist_installation_info(query, latest)[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/inspect.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/inspect.py[m
[1mnew file mode 100644[m
[1mindex 0000000..27c8fa3[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/inspect.py[m
[36m@@ -0,0 +1,92 @@[m
[32m+[m[32mimport logging[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom typing import Any, Dict, List[m
[32m+[m
[32m+[m[32mfrom pip._vendor.packaging.markers import default_environment[m
[32m+[m[32mfrom pip._vendor.rich import print_json[m
[32m+[m
[32m+[m[32mfrom pip import __version__[m
[32m+[m[32mfrom pip._internal.cli import cmdoptions[m
[32m+[m[32mfrom pip._internal.cli.req_command import Command[m
[32m+[m[32mfrom pip._internal.cli.status_codes import SUCCESS[m
[32m+[m[32mfrom pip._internal.metadata import BaseDistribution, get_environment[m
[32m+[m[32mfrom pip._internal.utils.compat import stdlib_pkgs[m
[32m+[m[32mfrom pip._internal.utils.urls import path_to_url[m
[32m+[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass InspectCommand(Command):[m
[32m+[m[32m    """[m
[32m+[m[32m    Inspect the content of a Python environment and produce a report in JSON format.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    ignore_require_venv = True[m
[32m+[m[32m    usage = """[m
[32m+[m[32m      %prog [options]"""[m
[32m+[m
[32m+[m[32m    def add_options(self) -> None:[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--local",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            default=False,[m
[32m+[m[32m            help=([m
[32m+[m[32m                "If in a virtualenv that has global access, do not list "[m
[32m+[m[32m                "globally-installed packages."[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--user",[m
[32m+[m[32m            dest="user",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            default=False,[m
[32m+[m[32m            help="Only output packages installed in user-site.",[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.list_path())[m
[32m+[m[32m        self.parser.insert_option_group(0, self.cmd_opts)[m
[32m+[m
[32m+[m[32m    def run(self, options: Values, args: List[str]) -> int:[m
[32m+[m[32m        cmdoptions.check_list_path_option(options)[m
[32m+[m[32m        dists = get_environment(options.path).iter_installed_distributions([m
[32m+[m[32m            local_only=options.local,[m
[32m+[m[32m            user_only=options.user,[m
[32m+[m[32m            skip=set(stdlib_pkgs),[m
[32m+[m[32m        )[m
[32m+[m[32m        output = {[m
[32m+[m[32m            "version": "1",[m
[32m+[m[32m            "pip_version": __version__,[m
[32m+[m[32m            "installed": [self._dist_to_dict(dist) for dist in dists],[m
[32m+[m[32m            "environment": default_environment(),[m
[32m+[m[32m            # TODO tags? scheme?[m
[32m+[m[32m        }[m
[32m+[m[32m        print_json(data=output)[m
[32m+[m[32m        return SUCCESS[m
[32m+[m
[32m+[m[32m    def _dist_to_dict(self, dist: BaseDistribution) -> Dict[str, Any]:[m
[32m+[m[32m        res: Dict[str, Any] = {[m
[32m+[m[32m            "metadata": dist.metadata_dict,[m
[32m+[m[32m            "metadata_location": dist.info_location,[m
[32m+[m[32m        }[m
[32m+[m[32m        # direct_url. Note that we don't have download_info (as in the installation[m
[32m+[m[32m        # report) since it is not recorded in installed metadata.[m
[32m+[m[32m        direct_url = dist.direct_url[m
[32m+[m[32m        if direct_url is not None:[m
[32m+[m[32m            res["direct_url"] = direct_url.to_dict()[m
[32m+[m[32m        else:[m
[32m+[m[32m            # Emulate direct_url for legacy editable installs.[m
[32m+[m[32m            editable_project_location = dist.editable_project_location[m
[32m+[m[32m            if editable_project_location is not None:[m
[32m+[m[32m                res["direct_url"] = {[m
[32m+[m[32m                    "url": path_to_url(editable_project_location),[m
[32m+[m[32m                    "dir_info": {[m
[32m+[m[32m                        "editable": True,[m
[32m+[m[32m                    },[m
[32m+[m[32m                }[m
[32m+[m[32m        # installer[m
[32m+[m[32m        installer = dist.installer[m
[32m+[m[32m        if dist.installer:[m
[32m+[m[32m            res["installer"] = installer[m
[32m+[m[32m        # requested[m
[32m+[m[32m        if dist.installed_with_dist_info:[m
[32m+[m[32m            res["requested"] = dist.requested[m
[32m+[m[32m        return res[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/install.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/install.py[m
[1mnew file mode 100644[m
[1mindex 0000000..e944bb9[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/install.py[m
[36m@@ -0,0 +1,774 @@[m
[32m+[m[32mimport errno[m
[32m+[m[32mimport json[m
[32m+[m[32mimport operator[m
[32m+[m[32mimport os[m
[32m+[m[32mimport shutil[m
[32m+[m[32mimport site[m
[32m+[m[32mfrom optparse import SUPPRESS_HELP, Values[m
[32m+[m[32mfrom typing import List, Optional[m
[32m+[m
[32m+[m[32mfrom pip._vendor.rich import print_json[m
[32m+[m
[32m+[m[32mfrom pip._internal.cache import WheelCache[m
[32m+[m[32mfrom pip._internal.cli import cmdoptions[m
[32m+[m[32mfrom pip._internal.cli.cmdoptions import make_target_python[m
[32m+[m[32mfrom pip._internal.cli.req_command import ([m
[32m+[m[32m    RequirementCommand,[m
[32m+[m[32m    warn_if_run_as_root,[m
[32m+[m[32m    with_cleanup,[m
[32m+[m[32m)[m
[32m+[m[32mfrom pip._internal.cli.status_codes import ERROR, SUCCESS[m
[32m+[m[32mfrom pip._internal.exceptions import CommandError, InstallationError[m
[32m+[m[32mfrom pip._internal.locations import get_scheme[m
[32m+[m[32mfrom pip._internal.metadata import get_environment[m
[32m+[m[32mfrom pip._internal.models.installation_report import InstallationReport[m
[32m+[m[32mfrom pip._internal.operations.build.build_tracker import get_build_tracker[m
[32m+[m[32mfrom pip._internal.operations.check import ConflictDetails, check_install_conflicts[m
[32m+[m[32mfrom pip._internal.req import install_given_reqs[m
[32m+[m[32mfrom pip._internal.req.req_install import ([m
[32m+[m[32m    InstallRequirement,[m
[32m+[m[32m    check_legacy_setup_py_options,[m
[32m+[m[32m)[m
[32m+[m[32mfrom pip._internal.utils.compat import WINDOWS[m
[32m+[m[32mfrom pip._internal.utils.filesystem import test_writable_dir[m
[32m+[m[32mfrom pip._internal.utils.logging import getLogger[m
[32m+[m[32mfrom pip._internal.utils.misc import ([m
[32m+[m[32m    check_externally_managed,[m
[32m+[m[32m    ensure_dir,[m
[32m+[m[32m    get_pip_version,[m
[32m+[m[32m    protect_pip_from_modification_on_windows,[m
[32m+[m[32m    write_output,[m
[32m+[m[32m)[m
[32m+[m[32mfrom pip._internal.utils.temp_dir import TempDirectory[m
[32m+[m[32mfrom pip._internal.utils.virtualenv import ([m
[32m+[m[32m    running_under_virtualenv,[m
[32m+[m[32m    virtualenv_no_global,[m
[32m+[m[32m)[m
[32m+[m[32mfrom pip._internal.wheel_builder import build, should_build_for_install_command[m
[32m+[m
[32m+[m[32mlogger = getLogger(__name__)[m
[32m+[m
[32m+[m
[32m+[m[32mclass InstallCommand(RequirementCommand):[m
[32m+[m[32m    """[m
[32m+[m[32m    Install packages from:[m
[32m+[m
[32m+[m[32m    - PyPI (and other indexes) using requirement specifiers.[m
[32m+[m[32m    - VCS project urls.[m
[32m+[m[32m    - Local project directories.[m
[32m+[m[32m    - Local or remote source archives.[m
[32m+[m
[32m+[m[32m    pip also supports installing from "requirements files", which provide[m
[32m+[m[32m    an easy way to specify a whole environment to be installed.[m
[32m+[m[32m    """[m
[32m+[m
[32m+[m[32m    usage = """[m
[32m+[m[32m      %prog [options] <requirement specifier> [package-index-options] ...[m
[32m+[m[32m      %prog [options] -r <requirements file> [package-index-options] ...[m
[32m+[m[32m      %prog [options] [-e] <vcs project url> ...[m
[32m+[m[32m      %prog [options] [-e] <local project path> ...[m
[32m+[m[32m      %prog [options] <archive url/path> ..."""[m
[32m+[m
[32m+[m[32m    def add_options(self) -> None:[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.requirements())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.constraints())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.no_deps())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.pre())[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.editable())[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--dry-run",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            dest="dry_run",[m
[32m+[m[32m            default=False,[m
[32m+[m[32m            help=([m
[32m+[m[32m                "Don't actually install anything, just print what would be. "[m
[32m+[m[32m                "Can be used in combination with --ignore-installed "[m
[32m+[m[32m                "to 'resolve' the requirements."[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "-t",[m
[32m+[m[32m            "--target",[m
[32m+[m[32m            dest="target_dir",[m
[32m+[m[32m            metavar="dir",[m
[32m+[m[32m            default=None,[m
[32m+[m[32m            help=([m
[32m+[m[32m                "Install packages into <dir>. "[m
[32m+[m[32m                "By default this will not replace existing files/folders in "[m
[32m+[m[32m                "<dir>. Use --upgrade to replace existing packages in <dir> "[m
[32m+[m[32m                "with new versions."[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m[32m        cmdoptions.add_target_python_options(self.cmd_opts)[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--user",[m
[32m+[m[32m            dest="use_user_site",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            help=([m
[32m+[m[32m                "Install to the Python user install directory for your "[m
[32m+[m[32m                "platform. Typically ~/.local/, or %APPDATA%\\Python on "[m
[32m+[m[32m                "Windows. (See the Python documentation for site.USER_BASE "[m
[32m+[m[32m                "for full details.)"[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--no-user",[m
[32m+[m[32m            dest="use_user_site",[m
[32m+[m[32m            action="store_false",[m
[32m+[m[32m            help=SUPPRESS_HELP,[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--root",[m
[32m+[m[32m            dest="root_path",[m
[32m+[m[32m            metavar="dir",[m
[32m+[m[32m            default=None,[m
[32m+[m[32m            help="Install everything relative to this alternate root directory.",[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--prefix",[m
[32m+[m[32m            dest="prefix_path",[m
[32m+[m[32m            metavar="dir",[m
[32m+[m[32m            default=None,[m
[32m+[m[32m            help=([m
[32m+[m[32m                "Installation prefix where lib, bin and other top-level "[m
[32m+[m[32m                "folders are placed. Note that the resulting installation may "[m
[32m+[m[32m                "contain scripts and other resources which reference the "[m
[32m+[m[32m                "Python interpreter of pip, and not that of ``--prefix``. "[m
[32m+[m[32m                "See also the ``--python`` option if the intention is to "[m
[32m+[m[32m                "install packages into another (possibly pip-free) "[m
[32m+[m[32m                "environment."[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.src())[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "-U",[m
[32m+[m[32m            "--upgrade",[m
[32m+[m[32m            dest="upgrade",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            help=([m
[32m+[m[32m                "Upgrade all specified packages to the newest available "[m
[32m+[m[32m                "version. The handling of dependencies depends on the "[m
[32m+[m[32m                "upgrade-strategy used."[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--upgrade-strategy",[m
[32m+[m[32m            dest="upgrade_strategy",[m
[32m+[m[32m            default="only-if-needed",[m
[32m+[m[32m            choices=["only-if-needed", "eager"],[m
[32m+[m[32m            help=([m
[32m+[m[32m                "Determines how dependency upgrading should be handled "[m
[32m+[m[32m                "[default: %default]. "[m
[32m+[m[32m                '"eager" - dependencies are upgraded regardless of '[m
[32m+[m[32m                "whether the currently installed version satisfies the "[m
[32m+[m[32m                "requirements of the upgraded package(s). "[m
[32m+[m[32m                '"only-if-needed" -  are upgraded only when they do not '[m
[32m+[m[32m                "satisfy the requirements of the upgraded package(s)."[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--force-reinstall",[m
[32m+[m[32m            dest="force_reinstall",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            help="Reinstall all packages even if they are already up-to-date.",[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "-I",[m
[32m+[m[32m            "--ignore-installed",[m
[32m+[m[32m            dest="ignore_installed",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            help=([m
[32m+[m[32m                "Ignore the installed packages, overwriting them. "[m
[32m+[m[32m                "This can break your system if the existing package "[m
[32m+[m[32m                "is of a different version or was installed "[m
[32m+[m[32m                "with a different package manager!"[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.ignore_requires_python())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.no_build_isolation())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.use_pep517())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.no_use_pep517())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.check_build_deps())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.override_externally_managed())[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.config_settings())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.global_options())[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--compile",[m
[32m+[m[32m            action="store_true",[m
[32m+[m[32m            dest="compile",[m
[32m+[m[32m            default=True,[m
[32m+[m[32m            help="Compile Python source files to bytecode",[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--no-compile",[m
[32m+[m[32m            action="store_false",[m
[32m+[m[32m            dest="compile",[m
[32m+[m[32m            help="Do not compile Python source files to bytecode",[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--no-warn-script-location",[m
[32m+[m[32m            action="store_false",[m
[32m+[m[32m            dest="warn_script_location",[m
[32m+[m[32m            default=True,[m
[32m+[m[32m            help="Do not warn when installing scripts outside PATH",[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--no-warn-conflicts",[m
[32m+[m[32m            action="store_false",[m
[32m+[m[32m            dest="warn_about_conflicts",[m
[32m+[m[32m            default=True,[m
[32m+[m[32m            help="Do not warn about broken dependencies",[m
[32m+[m[32m        )[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.no_binary())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.only_binary())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.prefer_binary())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.require_hashes())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.progress_bar())[m
[32m+[m[32m        self.cmd_opts.add_option(cmdoptions.root_user_action())[m
[32m+[m
[32m+[m[32m        index_opts = cmdoptions.make_option_group([m
[32m+[m[32m            cmdoptions.index_group,[m
[32m+[m[32m            self.parser,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        self.parser.insert_option_group(0, index_opts)[m
[32m+[m[32m        self.parser.insert_option_group(0, self.cmd_opts)[m
[32m+[m
[32m+[m[32m        self.cmd_opts.add_option([m
[32m+[m[32m            "--report",[m
[32m+[m[32m            dest="json_report_file",[m
[32m+[m[32m            metavar="file",[m
[32m+[m[32m            default=None,[m
[32m+[m[32m            help=([m
[32m+[m[32m                "Generate a JSON file describing what pip did to install "[m
[32m+[m[32m                "the provided requirements. "[m
[32m+[m[32m                "Can be used in combination with --dry-run and --ignore-installed "[m
[32m+[m[32m                "to 'resolve' the requirements. "[m
[32m+[m[32m                "When - is used as file name it writes to stdout. "[m
[32m+[m[32m                "When writing to stdout, please combine with the --quiet option "[m
[32m+[m[32m                "to avoid mixing pip logging output with JSON output."[m
[32m+[m[32m            ),[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    @with_cleanup[m
[32m+[m[32m    def run(self, options: Values, args: List[str]) -> int:[m
[32m+[m[32m        if options.use_user_site and options.target_dir is not None:[m
[32m+[m[32m            raise CommandError("Can not combine '--user' and '--target'")[m
[32m+[m
[32m+[m[32m        # Check whether the environment we're installing into is externally[m
[32m+[m[32m        # managed, as specified in PEP 668. Specifying --root, --target, or[m
[32m+[m[32m        # --prefix disables the check, since there's no reliable way to locate[m
[32m+[m[32m        # the EXTERNALLY-MANAGED file for those cases. An exception is also[m
[32m+[m[32m        # made specifically for "--dry-run --report" for convenience.[m
[32m+[m[32m        installing_into_current_environment = ([m
[32m+[m[32m            not (options.dry_run and options.json_report_file)[m
[32m+[m[32m            and options.root_path is None[m
[32m+[m[32m            and options.target_dir is None[m
[32m+[m[32m            and options.prefix_path is None[m
[32m+[m[32m        )[m
[32m+[m[32m        if ([m
[32m+[m[32m            installing_into_current_environment[m
[32m+[m[32m            and not options.override_externally_managed[m
[32m+[m[32m        ):[m
[32m+[m[32m            check_externally_managed()[m
[32m+[m
[32m+[m[32m        upgrade_strategy = "to-satisfy-only"[m
[32m+[m[32m        if options.upgrade:[m
[32m+[m[32m            upgrade_strategy = options.upgrade_strategy[m
[32m+[m
[32m+[m[32m        cmdoptions.check_dist_restriction(options, check_target=True)[m
[32m+[m
[32m+[m[32m        logger.verbose("Using %s", get_pip_version())[m
[32m+[m[32m        options.use_user_site = decide_user_install([m
[32m+[m[32m            options.use_user_site,[m
[32m+[m[32m            prefix_path=options.prefix_path,[m
[32m+[m[32m            target_dir=options.target_dir,[m
[32m+[m[32m            root_path=options.root_path,[m
[32m+[m[32m            isolated_mode=options.isolated_mode,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        target_temp_dir: Optional[TempDirectory] = None[m
[32m+[m[32m        target_temp_dir_path: Optional[str] = None[m
[32m+[m[32m        if options.target_dir:[m
[32m+[m[32m            options.ignore_installed = True[m
[32m+[m[32m            options.target_dir = os.path.abspath(options.target_dir)[m
[32m+[m[32m            if ([m
[32m+[m[32m                # fmt: off[m
[32m+[m[32m                os.path.exists(options.target_dir) and[m
[32m+[m[32m                not os.path.isdir(options.target_dir)[m
[32m+[m[32m                # fmt: on[m
[32m+[m[32m            ):[m
[32m+[m[32m                raise CommandError([m
[32m+[m[32m                    "Target path exists but is not a directory, will not continue."[m
[32m+[m[32m                )[m
[32m+[m
[32m+[m[32m            # Create a target directory for using with the target option[m
[32m+[m[32m            target_temp_dir = TempDirectory(kind="target")[m
[32m+[m[32m            target_temp_dir_path = target_temp_dir.path[m
[32m+[m[32m            self.enter_context(target_temp_dir)[m
[32m+[m
[32m+[m[32m        global_options = options.global_options or [][m
[32m+[m
[32m+[m[32m        session = self.get_default_session(options)[m
[32m+[m
[32m+[m[32m        target_python = make_target_python(options)[m
[32m+[m[32m        finder = self._build_package_finder([m
[32m+[m[32m            options=options,[m
[32m+[m[32m            session=session,[m
[32m+[m[32m            target_python=target_python,[m
[32m+[m[32m            ignore_requires_python=options.ignore_requires_python,[m
[32m+[m[32m        )[m
[32m+[m[32m        build_tracker = self.enter_context(get_build_tracker())[m
[32m+[m
[32m+[m[32m        directory = TempDirectory([m
[32m+[m[32m            delete=not options.no_clean,[m
[32m+[m[32m            kind="install",[m
[32m+[m[32m            globally_managed=True,[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m        try:[m
[32m+[m[32m            reqs = self.get_requirements(args, options, finder, session)[m
[32m+[m[32m            check_legacy_setup_py_options(options, reqs)[m
[32m+[m
[32m+[m[32m            wheel_cache = WheelCache(options.cache_dir)[m
[32m+[m
[32m+[m[32m            # Only when installing is it permitted to use PEP 660.[m
[32m+[m[32m            # In other circumstances (pip wheel, pip download) we generate[m
[32m+[m[32m            # regular (i.e. non editable) metadata and wheels.[m
[32m+[m[32m            for req in reqs:[m
[32m+[m[32m                req.permit_editable_wheels = True[m
[32m+[m
[32m+[m[32m            preparer = self.make_requirement_preparer([m
[32m+[m[32m                temp_build_dir=directory,[m
[32m+[m[32m                options=options,[m
[32m+[m[32m                build_tracker=build_tracker,[m
[32m+[m[32m                session=session,[m
[32m+[m[32m                finder=finder,[m
[32m+[m[32m                use_user_site=options.use_user_site,[m
[32m+[m[32m                verbosity=self.verbosity,[m
[32m+[m[32m            )[m
[32m+[m[32m            resolver = self.make_resolver([m
[32m+[m[32m                preparer=preparer,[m
[32m+[m[32m                finder=finder,[m
[32m+[m[32m                options=options,[m
[32m+[m[32m                wheel_cache=wheel_cache,[m
[32m+[m[32m                use_user_site=options.use_user_site,[m
[32m+[m[32m                ignore_installed=options.ignore_installed,[m
[32m+[m[32m                ignore_requires_python=options.ignore_requires_python,[m
[32m+[m[32m                force_reinstall=options.force_reinstall,[m
[32m+[m[32m                upgrade_strategy=upgrade_strategy,[m
[32m+[m[32m                use_pep517=options.use_pep517,[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m            self.trace_basic_info(finder)[m
[32m+[m
[32m+[m[32m            requirement_set = resolver.resolve([m
[32m+[m[32m                reqs, check_supported_wheels=not options.target_dir[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m            if options.json_report_file:[m
[32m+[m[32m                report = InstallationReport(requirement_set.requirements_to_install)[m
[32m+[m[32m                if options.json_report_file == "-":[m
[32m+[m[32m                    print_json(data=report.to_dict())[m
[32m+[m[32m                else:[m
[32m+[m[32m                    with open(options.json_report_file, "w", encoding="utf-8") as f:[m
[32m+[m[32m                        json.dump(report.to_dict(), f, indent=2, ensure_ascii=False)[m
[32m+[m
[32m+[m[32m            if options.dry_run:[m
[32m+[m[32m                # In non dry-run mode, the legacy versions and specifiers check[m
[32m+[m[32m                # will be done as part of conflict detection.[m
[32m+[m[32m                requirement_set.warn_legacy_versions_and_specifiers()[m
[32m+[m[32m                would_install_items = sorted([m
[32m+[m[32m                    (r.metadata["name"], r.metadata["version"])[m
[32m+[m[32m                    for r in requirement_set.requirements_to_install[m
[32m+[m[32m                )[m
[32m+[m[32m                if would_install_items:[m
[32m+[m[32m                    write_output([m
[32m+[m[32m                        "Would install %s",[m
[32m+[m[32m                        " ".join("-".join(item) for item in would_install_items),[m
[32m+[m[32m                    )[m
[32m+[m[32m                return SUCCESS[m
[32m+[m
[32m+[m[32m            try:[m
[32m+[m[32m                pip_req = requirement_set.get_requirement("pip")[m
[32m+[m[32m            except KeyError:[m
[32m+[m[32m                modifying_pip = False[m
[32m+[m[32m            else:[m
[32m+[m[32m                # If we're not replacing an already installed pip,[m
[32m+[m[32m                # we're not modifying it.[m
[32m+[m[32m                modifying_pip = pip_req.satisfied_by is None[m
[32m+[m[32m            protect_pip_from_modification_on_windows(modifying_pip=modifying_pip)[m
[32m+[m
[32m+[m[32m            reqs_to_build = [[m
[32m+[m[32m                r[m
[32m+[m[32m                for r in requirement_set.requirements.values()[m
[32m+[m[32m                if should_build_for_install_command(r)[m
[32m+[m[32m            ][m
[32m+[m
[32m+[m[32m            _, build_failures = build([m
[32m+[m[32m                reqs_to_build,[m
[32m+[m[32m                wheel_cache=wheel_cache,[m
[32m+[m[32m                verify=True,[m
[32m+[m[32m                build_options=[],[m
[32m+[m[32m                global_options=global_options,[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m            if build_failures:[m
[32m+[m[32m                raise InstallationError([m
[32m+[m[32m                    "Could not build wheels for {}, which is required to "[m
[32m+[m[32m                    "install pyproject.toml-based projects".format([m
[32m+[m[32m                        ", ".join(r.name for r in build_failures)  # type: ignore[m
[32m+[m[32m                    )[m
[32m+[m[32m                )[m
[32m+[m
[32m+[m[32m            to_install = resolver.get_installation_order(requirement_set)[m
[32m+[m
[32m+[m[32m            # Check for conflicts in the package set we're installing.[m
[32m+[m[32m            conflicts: Optional[ConflictDetails] = None[m
[32m+[m[32m            should_warn_about_conflicts = ([m
[32m+[m[32m                not options.ignore_dependencies and options.warn_about_conflicts[m
[32m+[m[32m            )[m
[32m+[m[32m            if should_warn_about_conflicts:[m
[32m+[m[32m                conflicts = self._determine_conflicts(to_install)[m
[32m+[m
[32m+[m[32m            # Don't warn about script install locations if[m
[32m+[m[32m            # --target or --prefix has been specified[m
[32m+[m[32m            warn_script_location = options.warn_script_location[m
[32m+[m[32m            if options.target_dir or options.prefix_path:[m
[32m+[m[32m                warn_script_location = False[m
[32m+[m
[32m+[m[32m            installed = install_given_reqs([m
[32m+[m[32m                to_install,[m
[32m+[m[32m                global_options,[m
[32m+[m[32m                root=options.root_path,[m
[32m+[m[32m                home=target_temp_dir_path,[m
[32m+[m[32m                prefix=options.prefix_path,[m
[32m+[m[32m                warn_script_location=warn_script_location,[m
[32m+[m[32m                use_user_site=options.use_user_site,[m
[32m+[m[32m                pycompile=options.compile,[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m            lib_locations = get_lib_location_guesses([m
[32m+[m[32m                user=options.use_user_site,[m
[32m+[m[32m                home=target_temp_dir_path,[m
[32m+[m[32m                root=options.root_path,[m
[32m+[m[32m                prefix=options.prefix_path,[m
[32m+[m[32m                isolated=options.isolated_mode,[m
[32m+[m[32m            )[m
[32m+[m[32m            env = get_environment(lib_locations)[m
[32m+[m
[32m+[m[32m            installed.sort(key=operator.attrgetter("name"))[m
[32m+[m[32m            items = [][m
[32m+[m[32m            for result in installed:[m
[32m+[m[32m                item = result.name[m
[32m+[m[32m                try:[m
[32m+[m[32m                    installed_dist = env.get_distribution(item)[m
[32m+[m[32m                    if installed_dist is not None:[m
[32m+[m[32m                        item = f"{item}-{installed_dist.version}"[m
[32m+[m[32m                except Exception:[m
[32m+[m[32m                    pass[m
[32m+[m[32m                items.append(item)[m
[32m+[m
[32m+[m[32m            if conflicts is not None:[m
[32m+[m[32m                self._warn_about_conflicts([m
[32m+[m[32m                    conflicts,[m
[32m+[m[32m                    resolver_variant=self.determine_resolver_variant(options),[m
[32m+[m[32m                )[m
[32m+[m
[32m+[m[32m            installed_desc = " ".join(items)[m
[32m+[m[32m            if installed_desc:[m
[32m+[m[32m                write_output([m
[32m+[m[32m                    "Successfully installed %s",[m
[32m+[m[32m                    installed_desc,[m
[32m+[m[32m                )[m
[32m+[m[32m        except OSError as error:[m
[32m+[m[32m            show_traceback = self.verbosity >= 1[m
[32m+[m
[32m+[m[32m            message = create_os_error_message([m
[32m+[m[32m                error,[m
[32m+[m[32m                show_traceback,[m
[32m+[m[32m                options.use_user_site,[m
[32m+[m[32m            )[m
[32m+[m[32m            logger.error(message, exc_info=show_traceback)[m
[32m+[m
[32m+[m[32m            return ERROR[m
[32m+[m
[32m+[m[32m        if options.target_dir:[m
[32m+[m[32m            assert target_temp_dir[m
[32m+[m[32m            self._handle_target_dir([m
[32m+[m[32m                options.target_dir, target_temp_dir, options.upgrade[m
[32m+[m[32m            )[m
[32m+[m[32m        if options.root_user_action == "warn":[m
[32m+[m[32m            warn_if_run_as_root()[m
[32m+[m[32m        return SUCCESS[m
[32m+[m
[32m+[m[32m    def _handle_target_dir([m
[32m+[m[32m        self, target_dir: str, target_temp_dir: TempDirectory, upgrade: bool[m
[32m+[m[32m    ) -> None:[m
[32m+[m[32m        ensure_dir(target_dir)[m
[32m+[m
[32m+[m[32m        # Checking both purelib and platlib directories for installed[m
[32m+[m[32m        # packages to be moved to target directory[m
[32m+[m[32m        lib_dir_list = [][m
[32m+[m
[32m+[m[32m        # Checking both purelib and platlib directories for installed[m
[32m+[m[32m        # packages to be moved to target directory[m
[32m+[m[32m        scheme = get_scheme("", home=target_temp_dir.path)[m
[32m+[m[32m        purelib_dir = scheme.purelib[m
[32m+[m[32m        platlib_dir = scheme.platlib[m
[32m+[m[32m        data_dir = scheme.data[m
[32m+[m
[32m+[m[32m        if os.path.exists(purelib_dir):[m
[32m+[m[32m            lib_dir_list.append(purelib_dir)[m
[32m+[m[32m        if os.path.exists(platlib_dir) and platlib_dir != purelib_dir:[m
[32m+[m[32m            lib_dir_list.append(platlib_dir)[m
[32m+[m[32m        if os.path.exists(data_dir):[m
[32m+[m[32m            lib_dir_list.append(data_dir)[m
[32m+[m
[32m+[m[32m        for lib_dir in lib_dir_list:[m
[32m+[m[32m            for item in os.listdir(lib_dir):[m
[32m+[m[32m                if lib_dir == data_dir:[m
[32m+[m[32m                    ddir = os.path.join(data_dir, item)[m
[32m+[m[32m                    if any(s.startswith(ddir) for s in lib_dir_list[:-1]):[m
[32m+[m[32m                        continue[m
[32m+[m[32m                target_item_dir = os.path.join(target_dir, item)[m
[32m+[m[32m                if os.path.exists(target_item_dir):[m
[32m+[m[32m                    if not upgrade:[m
[32m+[m[32m                        logger.warning([m
[32m+[m[32m                            "Target directory %s already exists. Specify "[m
[32m+[m[32m                            "--upgrade to force replacement.",[m
[32m+[m[32m                            target_item_dir,[m
[32m+[m[32m                        )[m
[32m+[m[32m                        continue[m
[32m+[m[32m                    if os.path.islink(target_item_dir):[m
[32m+[m[32m                        logger.warning([m
[32m+[m[32m                            "Target directory %s already exists and is "[m
[32m+[m[32m                            "a link. pip will not automatically replace "[m
[32m+[m[32m                            "links, please remove if replacement is "[m
[32m+[m[32m                            "desired.",[m
[32m+[m[32m                            target_item_dir,[m
[32m+[m[32m                        )[m
[32m+[m[32m                        continue[m
[32m+[m[32m                    if os.path.isdir(target_item_dir):[m
[32m+[m[32m                        shutil.rmtree(target_item_dir)[m
[32m+[m[32m                    else:[m
[32m+[m[32m                        os.remove(target_item_dir)[m
[32m+[m
[32m+[m[32m                shutil.move(os.path.join(lib_dir, item), target_item_dir)[m
[32m+[m
[32m+[m[32m    def _determine_conflicts([m
[32m+[m[32m        self, to_install: List[InstallRequirement][m
[32m+[m[32m    ) -> Optional[ConflictDetails]:[m
[32m+[m[32m        try:[m
[32m+[m[32m            return check_install_conflicts(to_install)[m
[32m+[m[32m        except Exception:[m
[32m+[m[32m            logger.exception([m
[32m+[m[32m                "Error while checking for conflicts. Please file an issue on "[m
[32m+[m[32m                "pip's issue tracker: https://github.com/pypa/pip/issues/new"[m
[32m+[m[32m            )[m
[32m+[m[32m            return None[m
[32m+[m
[32m+[m[32m    def _warn_about_conflicts([m
[32m+[m[32m        self, conflict_details: ConflictDetails, resolver_variant: str[m
[32m+[m[32m    ) -> None:[m
[32m+[m[32m        package_set, (missing, conflicting) = conflict_details[m
[32m+[m[32m        if not missing and not conflicting:[m
[32m+[m[32m            return[m
[32m+[m
[32m+[m[32m        parts: List[str] = [][m
[32m+[m[32m        if resolver_variant == "legacy":[m
[32m+[m[32m            parts.append([m
[32m+[m[32m                "pip's legacy dependency resolver does not consider dependency "[m
[32m+[m[32m                "conflicts when selecting packages. This behaviour is the "[m
[32m+[m[32m                "source of the following dependency conflicts."[m
[32m+[m[32m            )[m
[32m+[m[32m        else:[m
[32m+[m[32m            assert resolver_variant == "resolvelib"[m
[32m+[m[32m            parts.append([m
[32m+[m[32m                "pip's dependency resolver does not currently take into account "[m
[32m+[m[32m                "all the packages that are installed. This behaviour is the "[m
[32m+[m[32m                "source of the following dependency conflicts."[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        # NOTE: There is some duplication here, with commands/check.py[m
[32m+[m[32m        for project_name in missing:[m
[32m+[m[32m            version = package_set[project_name][0][m
[32m+[m[32m            for dependency in missing[project_name]:[m
[32m+[m[32m                message = ([m
[32m+[m[32m                    f"{project_name} {version} requires {dependency[1]}, "[m
[32m+[m[32m                    "which is not installed."[m
[32m+[m[32m                )[m
[32m+[m[32m                parts.append(message)[m
[32m+[m
[32m+[m[32m        for project_name in conflicting:[m
[32m+[m[32m            version = package_set[project_name][0][m
[32m+[m[32m            for dep_name, dep_version, req in conflicting[project_name]:[m
[32m+[m[32m                message = ([m
[32m+[m[32m                    "{name} {version} requires {requirement}, but {you} have "[m
[32m+[m[32m                    "{dep_name} {dep_version} which is incompatible."[m
[32m+[m[32m                ).format([m
[32m+[m[32m                    name=project_name,[m
[32m+[m[32m                    version=version,[m
[32m+[m[32m                    requirement=req,[m
[32m+[m[32m                    dep_name=dep_name,[m
[32m+[m[32m                    dep_version=dep_version,[m
[32m+[m[32m                    you=("you" if resolver_variant == "resolvelib" else "you'll"),[m
[32m+[m[32m                )[m
[32m+[m[32m                parts.append(message)[m
[32m+[m
[32m+[m[32m        logger.critical("\n".join(parts))[m
[32m+[m
[32m+[m
[32m+[m[32mdef get_lib_location_guesses([m
[32m+[m[32m    user: bool = False,[m
[32m+[m[32m    home: Optional[str] = None,[m
[32m+[m[32m    root: Optional[str] = None,[m
[32m+[m[32m    isolated: bool = False,[m
[32m+[m[32m    prefix: Optional[str] = None,[m
[32m+[m[32m) -> List[str]:[m
[32m+[m[32m    scheme = get_scheme([m
[32m+[m[32m        "",[m
[32m+[m[32m        user=user,[m
[32m+[m[32m        home=home,[m
[32m+[m[32m        root=root,[m
[32m+[m[32m        isolated=isolated,[m
[32m+[m[32m        prefix=prefix,[m
[32m+[m[32m    )[m
[32m+[m[32m    return [scheme.purelib, scheme.platlib][m
[32m+[m
[32m+[m
[32m+[m[32mdef site_packages_writable(root: Optional[str], isolated: bool) -> bool:[m
[32m+[m[32m    return all([m
[32m+[m[32m        test_writable_dir(d)[m
[32m+[m[32m        for d in set(get_lib_location_guesses(root=root, isolated=isolated))[m
[32m+[m[32m    )[m
[32m+[m
[32m+[m
[32m+[m[32mdef decide_user_install([m
[32m+[m[32m    use_user_site: Optional[bool],[m
[32m+[m[32m    prefix_path: Optional[str] = None,[m
[32m+[m[32m    target_dir: Optional[str] = None,[m
[32m+[m[32m    root_path: Optional[str] = None,[m
[32m+[m[32m    isolated_mode: bool = False,[m
[32m+[m[32m) -> bool:[m
[32m+[m[32m    """Determine whether to do a user install based on the input options.[m
[32m+[m
[32m+[m[32m    If use_user_site is False, no additional checks are done.[m
[32m+[m[32m    If use_user_site is True, it is checked for compatibility with other[m
[32m+[m[32m    options.[m
[32m+[m[32m    If use_user_site is None, the default behaviour depends on the environment,[m
[32m+[m[32m    which is provided by the other arguments.[m
[32m+[m[32m    """[m
[32m+[m[32m    # In some cases (config from tox), use_user_site can be set to an integer[m
[32m+[m[32m    # rather than a bool, which 'use_user_site is False' wouldn't catch.[m
[32m+[m[32m    if (use_user_site is not None) and (not use_user_site):[m
[32m+[m[32m        logger.debug("Non-user install by explicit request")[m
[32m+[m[32m        return False[m
[32m+[m
[32m+[m[32m    if use_user_site:[m
[32m+[m[32m        if prefix_path:[m
[32m+[m[32m            raise CommandError([m
[32m+[m[32m                "Can not combine '--user' and '--prefix' as they imply "[m
[32m+[m[32m                "different installation locations"[m
[32m+[m[32m            )[m
[32m+[m[32m        if virtualenv_no_global():[m
[32m+[m[32m            raise InstallationError([m
[32m+[m[32m                "Can not perform a '--user' install. User site-packages "[m
[32m+[m[32m                "are not visible in this virtualenv."[m
[32m+[m[32m            )[m
[32m+[m[32m        logger.debug("User install by explicit request")[m
[32m+[m[32m        return True[m
[32m+[m
[32m+[m[32m    # If we are here, user installs have not been explicitly requested/avoided[m
[32m+[m[32m    assert use_user_site is None[m
[32m+[m
[32m+[m[32m    # user install incompatible with --prefix/--target[m
[32m+[m[32m    if prefix_path or target_dir:[m
[32m+[m[32m        logger.debug("Non-user install due to --prefix or --target option")[m
[32m+[m[32m        return False[m
[32m+[m
[32m+[m[32m    # If user installs are not enabled, choose a non-user install[m
[32m+[m[32m    if not site.ENABLE_USER_SITE:[m
[32m+[m[32m        logger.debug("Non-user install because user site-packages disabled")[m
[32m+[m[32m        return False[m
[32m+[m
[32m+[m[32m    # If we have permission for a non-user install, do that,[m
[32m+[m[32m    # otherwise do a user install.[m
[32m+[m[32m    if site_packages_writable(root=root_path, isolated=isolated_mode):[m
[32m+[m[32m        logger.debug("Non-user install because site-packages writeable")[m
[32m+[m[32m        return False[m
[32m+[m
[32m+[m[32m    logger.info([m
[32m+[m[32m        "Defaulting to user installation because normal site-packages "[m
[32m+[m[32m        "is not writeable"[m
[32m+[m[32m    )[m
[32m+[m[32m    return True[m
[32m+[m
[32m+[m
[32m+[m[32mdef create_os_error_message([m
[32m+[m[32m    error: OSError, show_traceback: bool, using_user_site: bool[m
[32m+[m[32m) -> str:[m
[32m+[m[32m    """Format an error message for an OSError[m
[32m+[m
[32m+[m[32m    It may occur anytime during the execution of the install command.[m
[32m+[m[32m    """[m
[32m+[m[32m    parts = [][m
[32m+[m
[32m+[m[32m    # Mention the error if we are not going to show a traceback[m
[32m+[m[32m    parts.append("Could not install packages due to an OSError")[m
[32m+[m[32m    if not show_traceback:[m
[32m+[m[32m        parts.append(": ")[m
[32m+[m[32m        parts.append(str(error))[m
[32m+[m[32m    else:[m
[32m+[m[32m        parts.append(".")[m
[32m+[m
[32m+[m[32m    # Spilt the error indication from a helper message (if any)[m
[32m+[m[32m    parts[-1] += "\n"[m
[32m+[m
[32m+[m[32m    # Suggest useful actions to the user:[m
[32m+[m[32m    #  (1) using user site-packages or (2) verifying the permissions[m
[32m+[m[32m    if error.errno == errno.EACCES:[m
[32m+[m[32m        user_option_part = "Consider using the `--user` option"[m
[32m+[m[32m        permissions_part = "Check the permissions"[m
[32m+[m
[32m+[m[32m        if not running_under_virtualenv() and not using_user_site:[m
[32m+[m[32m            parts.extend([m
[32m+[m[32m                [[m
[32m+[m[32m                    user_option_part,[m
[32m+[m[32m                    " or ",[m
[32m+[m[32m                    permissions_part.lower(),[m
[32m+[m[32m                ][m
[32m+[m[32m            )[m
[32m+[m[32m        else:[m
[32m+[m[32m            parts.append(permissions_part)[m
[32m+[m[32m        parts.append(".\n")[m
[32m+[m
[32m+[m[32m    # Suggest the user to enable Long Paths if path length is[m
[32m+[m[32m    # more than 260[m
[32m+[m[32m    if ([m
[32m+[m[32m        WINDOWS[m
[32m+[m[32m        and error.errno == errno.ENOENT[m
[32m+[m[32m        and error.filename[m
[32m+[m[32m        and len(error.filename) > 260[m
[32m+[m[32m    ):[m
[32m+[m[32m        parts.append([m
[32m+[m[32m            "HINT: This error might have occurred since "[m
[32m+[m[32m            "this system does not have Windows Long Path "[m
[32m+[m[32m            "support enabled. You can find information on "[m
[32m+[m[32m            "how to enable this at "[m
[32m+[m[32m            "https://pip.pypa.io/warnings/enable-long-paths\n"[m
[32m+[m[32m        )[m
[32m+[m
[32m+[m[32m    return "".join(parts).strip() + "\n"[m
[1mdiff --git a/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/list.py b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/list.py[m
[1mnew file mode 100644[m
[1mindex 0000000..e551dda[m
[1m--- /dev/null[m
[1m+++ b/ProjectDetails/ProjectDetails/Lib/site-packages/pip/_internal/commands/list.py[m
[36m@@ -0,0 +1,368 @@[m
[32m+[m[32mimport json[m
[32m+[m[32mimport logging[m
[32m+[m[32mfrom optparse import Values[m
[32m+[m[32mfrom typing import TYPE_CHECKING, Generator, List, Optional, Sequence, Tuple, cast[m
[32m+[m
[32m+[m[32mfrom pip._vendor.packaging.utils import canonicalize_name[m
[32m+[m
[32m+[m[32mfrom pip._internal.cli import cmdoptions[m
[32m+[m[32mfrom pip._internal.cli.req_command import IndexGroupCommand[m
[32m+[m[32mfrom pip._internal.cli.status_codes import SUCCESS[m
[32m+[m[32mfrom pip._internal.exceptions import CommandError[m
[32m+[m[32mfrom pip._internal.index.collector import LinkCollector[m
[32m+[m[32mfrom pip._internal.index.package_finder import PackageFinder[m
[32m+[m[32mfrom pip._internal.metadata import BaseDistribution, get_environment[m
[32m+[m[32mfrom pip._internal